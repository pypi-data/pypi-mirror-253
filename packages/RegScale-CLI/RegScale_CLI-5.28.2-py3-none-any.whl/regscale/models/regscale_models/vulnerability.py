#!/usr/bin/env python3
# -*- coding: utf-8 -*-
""" Model for Vulnerability in the application """
import logging
from typing import List, Optional
from urllib.parse import urljoin

from requests import Response

from regscale.core.app.api import Api
from regscale.core.app.application import Application
from regscale.core.app.logz import create_logger
from regscale.core.app.utils.app_utils import get_current_datetime
from regscale.models.regscale_models.regscale_model import RegScaleModel


class Vulnerability(RegScaleModel):
    """Vulnerability Model"""

    id: Optional[int]
    uuid: Optional[str]
    scanId: Optional[int]
    parentId: Optional[int]
    parentModule: Optional[str]
    lastSeen: Optional[str]
    firstSeen: Optional[str]
    daysOpen: Optional[int]
    dns: Optional[str]
    ipAddress: Optional[str]
    mitigated: Optional[bool]
    uuid: Optional[str]
    scanId: Optional[int]
    parentId: Optional[int]
    parentModule: Optional[str]
    lastSeen: Optional[str]
    firstSeen: Optional[str]
    daysOpen: Optional[int]
    dns: Optional[str]
    ipAddress: Optional[str]
    mitigated: Optional[bool]
    operatingSystem: Optional[str]
    port: Optional[str]
    port: Optional[str]
    protocol: Optional[str]
    severity: Optional[str]
    severity: Optional[str]
    plugInName: Optional[str]
    plugInId: Optional[int]
    cve: Optional[str]
    vprScore: Optional[int]
    exploitAvailable: Optional[bool]
    title: Optional[str]
    vprScore: Optional[int]
    exploitAvailable: Optional[bool]
    cvsSv3BaseScore: Optional[int]
    title: Optional[str]
    description: Optional[str]
    plugInText: Optional[str]
    createdById: Optional[str]
    lastUpdatedById: Optional[str]
    tenantsId: Optional[int] = 0
    dateCreated: Optional[str] = get_current_datetime()
    dateLastUpdated: Optional[str] = get_current_datetime()

    def __hash__(self) -> hash:
        """
        Enable object to be hashable

        :return: Hashed Vulnerability
        :rtype: hash
        """
        return hash(
            (
                self.title,
                self.scanId,
                self.ipAddress,
                self.parentModule,
                self.parentId,
                self.uuid,
            )
        )

    def __eq__(self, other) -> bool:
        """
        Enable object to be equal

        :param other: Object to compare to
        :return: True if equal
        :rtype: bool
        """
        return (
            self.title == other.title
            and self.scanId == other.scanId
            and self.ipAddress == other.ipAddress
            and self.parentModule == other.parentModule
            and self.parentId == other.parentId
            and self.uuid == other.uuid
        )

    @classmethod
    def logger(cls) -> logging.Logger:
        """
        Logger for Vulnerability Model

        :return: Logger
        :rtype: logging.Logger
        """
        logger = create_logger()
        return logger

    @staticmethod
    def find_vulns_by_scan(app: Application, scan_id: int) -> List["Vulnerability"]:
        """
        Find Vulnerabilities by Scan ID

        :param Application app: Application instance
        :param int scan_id: Scan ID
        :return: List of Vulnerabilities
        :rtype: List[Vulnerability]
        """
        api = Api(app)
        api_url = urljoin(
            app.config.get("domain"), f"/api/vulnerability/getAllByParent/{scan_id}"
        )
        response = api.get(url=api_url, params={"scanId": scan_id})
        if response.ok:
            return [Vulnerability(**v) for v in response.json()]
        else:
            response.raise_for_status()

    @staticmethod
    def determine_cvss3_severity_text(cvs_sv3_base_score: float) -> str:
        """
        Determine CVSS3 Severity Text from CVSS3 Base Score

        :param float cvs_sv3_base_score: CVSS3 Base Score
        :return: CVSS3 Severity Text
        :rtype: str
        """
        results = "low"
        if 4.0 <= cvs_sv3_base_score <= 6.9:
            results = "medium"
        elif 7.0 <= cvs_sv3_base_score <= 8.9:
            results = "high"
        elif cvs_sv3_base_score > 8.9:
            results = "critical"
        return results

    @staticmethod
    def post_vulnerability(vulnerability: "Vulnerability") -> dict:
        """
        Post a vulnerability to the API

        :param Vulnerability vulnerability: The vulnerability to be posted
        :return: The response from the API as a dictionary
        :rtype: dict
        """
        app = Application()
        api = Api(app)
        api_url = urljoin(app.config.get("domain"), "/api/vulnerability")
        payload = vulnerability.dict()
        response = api.post(url=api_url, json=payload)
        return response.json() if response.ok else response.raise_for_status()

    @staticmethod
    def post_vulnerabilities(
        app: Application,
        vulnerabilities: List["Vulnerability"],
        output_to_console: Optional[bool] = True,
    ) -> None:
        """
        Insert new vulnerabilities into RegScale

        :param Application app: Application object
        :param List[Vulnerability] vulnerabilities: List of Vulnerability objects
        :param Optional[bool] output_to_console: Whether to output to console, defaults to True
        :return: None
        """

        def batch_post(url: str, dat: list[dict]) -> Response:
            """
            Simple wrapper to post a list of JSON data to a URL

            :param url: URL to post to
            :param dat: A list of JSON data to post
            :return: Response object
            :rtype: Response
            """
            res = api.post(url=url, json=dat)
            return res

        api = Api(app)
        if output_to_console:
            api.logger.info(
                "Creating %i new vulnerabilities in RegScale...", len(vulnerabilities)
            )
        # Create batches of vulnerabilities to post
        batch_size = 500
        batches = [
            vulnerabilities[i : i + batch_size]
            for i in range(0, len(vulnerabilities), batch_size)
        ]
        for batch in batches:
            batch_post(
                url=urljoin(app.config.get("domain"), "/api/vulnerability/batchcreate"),
                dat=[vuln.dict() for vuln in batch],
            )

    @staticmethod
    def process_vulns(app: Application, new_vulns: List["Vulnerability"]) -> None:
        """
        Process Vulnerabilities

        :param Application app: Application Instance
        :param List[Vulnerability] new_vulns: A list of new vulnerabilties
        :return: None
        """

        # Filter Vulns
        Vulnerability.post_vulnerabilities(app=app, vulnerabilities=new_vulns)
