# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'AdaptiveDynamicStreamingTemplateStreamInfoArgs',
    'AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs',
    'AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs',
    'ProcedureTemplateMediaProcessTaskArgs',
    'ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListArgs',
    'ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListArgs',
    'ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskListArgs',
    'ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListArgs',
    'ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkListArgs',
    'ProcedureTemplateMediaProcessTaskImageSpriteTaskListArgs',
    'ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListArgs',
    'ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkListArgs',
    'ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListArgs',
    'ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListArgs',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskListArgs',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicListArgs',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkListArgs',
    'SuperPlayerConfigDrmStreamingInfoArgs',
    'SuperPlayerConfigResolutionNameArgs',
]

@pulumi.input_type
class AdaptiveDynamicStreamingTemplateStreamInfoArgs:
    def __init__(__self__, *,
                 audio: pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs'],
                 video: pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs'],
                 remove_audio: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs'] audio: Audio parameter information.
        :param pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs'] video: Video parameter information.
        :param pulumi.Input[bool] remove_audio: Whether to remove audio stream. Valid values: `false`: no, `true`: yes. `false` by default.
        """
        pulumi.set(__self__, "audio", audio)
        pulumi.set(__self__, "video", video)
        if remove_audio is not None:
            pulumi.set(__self__, "remove_audio", remove_audio)

    @property
    @pulumi.getter
    def audio(self) -> pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs']:
        """
        Audio parameter information.
        """
        return pulumi.get(self, "audio")

    @audio.setter
    def audio(self, value: pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs']):
        pulumi.set(self, "audio", value)

    @property
    @pulumi.getter
    def video(self) -> pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs']:
        """
        Video parameter information.
        """
        return pulumi.get(self, "video")

    @video.setter
    def video(self, value: pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs']):
        pulumi.set(self, "video", value)

    @property
    @pulumi.getter(name="removeAudio")
    def remove_audio(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to remove audio stream. Valid values: `false`: no, `true`: yes. `false` by default.
        """
        return pulumi.get(self, "remove_audio")

    @remove_audio.setter
    def remove_audio(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remove_audio", value)


@pulumi.input_type
class AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs:
    def __init__(__self__, *,
                 bitrate: pulumi.Input[int],
                 codec: pulumi.Input[str],
                 sample_rate: pulumi.Input[int],
                 audio_channel: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] bitrate: Audio stream bitrate in Kbps. Value range: `0` and `[26, 256]`. If the value is `0`, the bitrate of the audio stream will be the same as that of the original audio.
        :param pulumi.Input[str] codec: Audio stream encoder. Valid value are: `libfdk_aac` and `libmp3lame`. while `libfdk_aac` is recommended.
        :param pulumi.Input[int] sample_rate: Audio stream sample rate. Valid values: `32000`, `44100`, `48000`Hz.
        :param pulumi.Input[str] audio_channel: Audio channel system. Valid values: mono, dual, stereo. Default value: dual.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "sample_rate", sample_rate)
        if audio_channel is not None:
            pulumi.set(__self__, "audio_channel", audio_channel)

    @property
    @pulumi.getter
    def bitrate(self) -> pulumi.Input[int]:
        """
        Audio stream bitrate in Kbps. Value range: `0` and `[26, 256]`. If the value is `0`, the bitrate of the audio stream will be the same as that of the original audio.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: pulumi.Input[int]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Audio stream encoder. Valid value are: `libfdk_aac` and `libmp3lame`. while `libfdk_aac` is recommended.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> pulumi.Input[int]:
        """
        Audio stream sample rate. Valid values: `32000`, `44100`, `48000`Hz.
        """
        return pulumi.get(self, "sample_rate")

    @sample_rate.setter
    def sample_rate(self, value: pulumi.Input[int]):
        pulumi.set(self, "sample_rate", value)

    @property
    @pulumi.getter(name="audioChannel")
    def audio_channel(self) -> Optional[pulumi.Input[str]]:
        """
        Audio channel system. Valid values: mono, dual, stereo. Default value: dual.
        """
        return pulumi.get(self, "audio_channel")

    @audio_channel.setter
    def audio_channel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_channel", value)


@pulumi.input_type
class AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs:
    def __init__(__self__, *,
                 bitrate: pulumi.Input[int],
                 codec: pulumi.Input[str],
                 fps: pulumi.Input[int],
                 fill_type: Optional[pulumi.Input[str]] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 resolution_adaptive: Optional[pulumi.Input[bool]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bitrate: Bitrate of video stream in Kbps. Value range: `0` and `[128, 35000]`. If the value is `0`, the bitrate of the video will be the same as that of the source video.
        :param pulumi.Input[str] codec: Video stream encoder. Valid values: `libx264`,`libx265`,`av1`. `libx264`: H.264, `libx265`: H.265, `av1`: AOMedia Video 1. Currently, a resolution within 640x480 must be specified for `H.265`. and the `av1` container only supports mp4.
        :param pulumi.Input[int] fps: Video frame rate in Hz. Value range: `[0, 60]`. If the value is `0`, the frame rate will be the same as that of the source video.
        :param pulumi.Input[str] fill_type: Fill type. Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. Default value: black. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[int] height: Maximum value of the height (or short side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[bool] resolution_adaptive: Resolution adaption. Valid values: `true`,`false`. `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height. Default value: `true`. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[int] width: Maximum value of the width (or long side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "fps", fps)
        if fill_type is not None:
            pulumi.set(__self__, "fill_type", fill_type)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if resolution_adaptive is not None:
            pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> pulumi.Input[int]:
        """
        Bitrate of video stream in Kbps. Value range: `0` and `[128, 35000]`. If the value is `0`, the bitrate of the video will be the same as that of the source video.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: pulumi.Input[int]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Video stream encoder. Valid values: `libx264`,`libx265`,`av1`. `libx264`: H.264, `libx265`: H.265, `av1`: AOMedia Video 1. Currently, a resolution within 640x480 must be specified for `H.265`. and the `av1` container only supports mp4.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter
    def fps(self) -> pulumi.Input[int]:
        """
        Video frame rate in Hz. Value range: `[0, 60]`. If the value is `0`, the frame rate will be the same as that of the source video.
        """
        return pulumi.get(self, "fps")

    @fps.setter
    def fps(self, value: pulumi.Input[int]):
        pulumi.set(self, "fps", value)

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> Optional[pulumi.Input[str]]:
        """
        Fill type. Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. Default value: black. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "fill_type")

    @fill_type.setter
    def fill_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fill_type", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum value of the height (or short side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> Optional[pulumi.Input[bool]]:
        """
        Resolution adaption. Valid values: `true`,`false`. `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height. Default value: `true`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "resolution_adaptive")

    @resolution_adaptive.setter
    def resolution_adaptive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "resolution_adaptive", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum value of the width (or long side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskArgs:
    def __init__(__self__, *,
                 adaptive_dynamic_streaming_task_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListArgs']]]] = None,
                 animated_graphic_task_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskListArgs']]]] = None,
                 cover_by_snapshot_task_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListArgs']]]] = None,
                 image_sprite_task_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskImageSpriteTaskListArgs']]]] = None,
                 sample_snapshot_task_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListArgs']]]] = None,
                 snapshot_by_time_offset_task_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListArgs']]]] = None,
                 transcode_task_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListArgs']]] adaptive_dynamic_streaming_task_lists: List of adaptive bitrate streaming tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskListArgs']]] animated_graphic_task_lists: List of animated image generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListArgs']]] cover_by_snapshot_task_lists: List of cover generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskImageSpriteTaskListArgs']]] image_sprite_task_lists: List of image sprite generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListArgs']]] sample_snapshot_task_lists: List of sampled screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListArgs']]] snapshot_by_time_offset_task_lists: List of time point screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListArgs']]] transcode_task_lists: List of transcoding tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        if adaptive_dynamic_streaming_task_lists is not None:
            pulumi.set(__self__, "adaptive_dynamic_streaming_task_lists", adaptive_dynamic_streaming_task_lists)
        if animated_graphic_task_lists is not None:
            pulumi.set(__self__, "animated_graphic_task_lists", animated_graphic_task_lists)
        if cover_by_snapshot_task_lists is not None:
            pulumi.set(__self__, "cover_by_snapshot_task_lists", cover_by_snapshot_task_lists)
        if image_sprite_task_lists is not None:
            pulumi.set(__self__, "image_sprite_task_lists", image_sprite_task_lists)
        if sample_snapshot_task_lists is not None:
            pulumi.set(__self__, "sample_snapshot_task_lists", sample_snapshot_task_lists)
        if snapshot_by_time_offset_task_lists is not None:
            pulumi.set(__self__, "snapshot_by_time_offset_task_lists", snapshot_by_time_offset_task_lists)
        if transcode_task_lists is not None:
            pulumi.set(__self__, "transcode_task_lists", transcode_task_lists)

    @property
    @pulumi.getter(name="adaptiveDynamicStreamingTaskLists")
    def adaptive_dynamic_streaming_task_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListArgs']]]]:
        """
        List of adaptive bitrate streaming tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "adaptive_dynamic_streaming_task_lists")

    @adaptive_dynamic_streaming_task_lists.setter
    def adaptive_dynamic_streaming_task_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListArgs']]]]):
        pulumi.set(self, "adaptive_dynamic_streaming_task_lists", value)

    @property
    @pulumi.getter(name="animatedGraphicTaskLists")
    def animated_graphic_task_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskListArgs']]]]:
        """
        List of animated image generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "animated_graphic_task_lists")

    @animated_graphic_task_lists.setter
    def animated_graphic_task_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskListArgs']]]]):
        pulumi.set(self, "animated_graphic_task_lists", value)

    @property
    @pulumi.getter(name="coverBySnapshotTaskLists")
    def cover_by_snapshot_task_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListArgs']]]]:
        """
        List of cover generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "cover_by_snapshot_task_lists")

    @cover_by_snapshot_task_lists.setter
    def cover_by_snapshot_task_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListArgs']]]]):
        pulumi.set(self, "cover_by_snapshot_task_lists", value)

    @property
    @pulumi.getter(name="imageSpriteTaskLists")
    def image_sprite_task_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskImageSpriteTaskListArgs']]]]:
        """
        List of image sprite generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "image_sprite_task_lists")

    @image_sprite_task_lists.setter
    def image_sprite_task_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskImageSpriteTaskListArgs']]]]):
        pulumi.set(self, "image_sprite_task_lists", value)

    @property
    @pulumi.getter(name="sampleSnapshotTaskLists")
    def sample_snapshot_task_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListArgs']]]]:
        """
        List of sampled screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "sample_snapshot_task_lists")

    @sample_snapshot_task_lists.setter
    def sample_snapshot_task_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListArgs']]]]):
        pulumi.set(self, "sample_snapshot_task_lists", value)

    @property
    @pulumi.getter(name="snapshotByTimeOffsetTaskLists")
    def snapshot_by_time_offset_task_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListArgs']]]]:
        """
        List of time point screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "snapshot_by_time_offset_task_lists")

    @snapshot_by_time_offset_task_lists.setter
    def snapshot_by_time_offset_task_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListArgs']]]]):
        pulumi.set(self, "snapshot_by_time_offset_task_lists", value)

    @property
    @pulumi.getter(name="transcodeTaskLists")
    def transcode_task_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListArgs']]]]:
        """
        List of transcoding tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "transcode_task_lists")

    @transcode_task_lists.setter
    def transcode_task_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListArgs']]]]):
        pulumi.set(self, "transcode_task_lists", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 watermark_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListArgs']]]] = None):
        """
        :param pulumi.Input[str] definition: Adaptive bitrate streaming template ID.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListArgs']]] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Adaptive bitrate streaming template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListArgs']]]]:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")

    @watermark_lists.setter
    def watermark_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListArgs']]]]):
        pulumi.set(self, "watermark_lists", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 svg_content: Optional[pulumi.Input[str]] = None,
                 text_content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] definition: Watermarking template ID.
        :param pulumi.Input[float] end_time_offset: End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        :param pulumi.Input[float] start_time_offset: Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        :param pulumi.Input[str] svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[str] text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Watermarking template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[pulumi.Input[str]]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @svg_content.setter
    def svg_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "svg_content", value)

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[pulumi.Input[str]]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")

    @text_content.setter
    def text_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_content", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 end_time_offset: pulumi.Input[float],
                 start_time_offset: pulumi.Input[float]):
        """
        :param pulumi.Input[str] definition: Animated image generating template ID.
        :param pulumi.Input[float] end_time_offset: End time of animated image in video in seconds.
        :param pulumi.Input[float] start_time_offset: Start time of animated image in video in seconds.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "end_time_offset", end_time_offset)
        pulumi.set(__self__, "start_time_offset", start_time_offset)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Animated image generating template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> pulumi.Input[float]:
        """
        End time of animated image in video in seconds.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: pulumi.Input[float]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> pulumi.Input[float]:
        """
        Start time of animated image in video in seconds.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: pulumi.Input[float]):
        pulumi.set(self, "start_time_offset", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 position_type: pulumi.Input[str],
                 position_value: pulumi.Input[float],
                 watermark_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkListArgs']]]] = None):
        """
        :param pulumi.Input[str] definition: Time point screen capturing template ID.
        :param pulumi.Input[str] position_type: Screen capturing mode. Valid values: `Time`, `Percent`. `Time`: screen captures by time point, `Percent`: screen captures by percentage.
        :param pulumi.Input[float] position_value: Screenshot position: For time point screen capturing, this means to take a screenshot at a specified time point (in seconds) and use it as the cover. For percentage screen capturing, this value means to take a screenshot at a specified percentage of the video duration and use it as the cover.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkListArgs']]] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "position_type", position_type)
        pulumi.set(__self__, "position_value", position_value)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Time point screen capturing template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="positionType")
    def position_type(self) -> pulumi.Input[str]:
        """
        Screen capturing mode. Valid values: `Time`, `Percent`. `Time`: screen captures by time point, `Percent`: screen captures by percentage.
        """
        return pulumi.get(self, "position_type")

    @position_type.setter
    def position_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "position_type", value)

    @property
    @pulumi.getter(name="positionValue")
    def position_value(self) -> pulumi.Input[float]:
        """
        Screenshot position: For time point screen capturing, this means to take a screenshot at a specified time point (in seconds) and use it as the cover. For percentage screen capturing, this value means to take a screenshot at a specified percentage of the video duration and use it as the cover.
        """
        return pulumi.get(self, "position_value")

    @position_value.setter
    def position_value(self, value: pulumi.Input[float]):
        pulumi.set(self, "position_value", value)

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkListArgs']]]]:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")

    @watermark_lists.setter
    def watermark_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkListArgs']]]]):
        pulumi.set(self, "watermark_lists", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 svg_content: Optional[pulumi.Input[str]] = None,
                 text_content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] definition: Watermarking template ID.
        :param pulumi.Input[float] end_time_offset: End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        :param pulumi.Input[float] start_time_offset: Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        :param pulumi.Input[str] svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[str] text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Watermarking template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[pulumi.Input[str]]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @svg_content.setter
    def svg_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "svg_content", value)

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[pulumi.Input[str]]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")

    @text_content.setter
    def text_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_content", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskImageSpriteTaskListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str]):
        """
        :param pulumi.Input[str] definition: Image sprite generating template ID.
        """
        pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Image sprite generating template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 watermark_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkListArgs']]]] = None):
        """
        :param pulumi.Input[str] definition: Sampled screen capturing template ID.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkListArgs']]] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Sampled screen capturing template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkListArgs']]]]:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")

    @watermark_lists.setter
    def watermark_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkListArgs']]]]):
        pulumi.set(self, "watermark_lists", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 svg_content: Optional[pulumi.Input[str]] = None,
                 text_content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] definition: Watermarking template ID.
        :param pulumi.Input[float] end_time_offset: End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        :param pulumi.Input[float] start_time_offset: Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        :param pulumi.Input[str] svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[str] text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Watermarking template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[pulumi.Input[str]]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @svg_content.setter
    def svg_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "svg_content", value)

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[pulumi.Input[str]]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")

    @text_content.setter
    def text_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_content", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 ext_time_offset_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 watermark_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListArgs']]]] = None):
        """
        :param pulumi.Input[str] definition: Time point screen capturing template ID.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ext_time_offset_lists: The list of screenshot time points. `s` and `%` formats are supported: When a time point string ends with `s`, its unit is second. For example, `3.5s` means the 3.5th second of the video; When a time point string ends with `%`, it is marked with corresponding percentage of the video duration. For example, `10%` means that the time point is at the 10% of the video entire duration.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListArgs']]] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if ext_time_offset_lists is not None:
            pulumi.set(__self__, "ext_time_offset_lists", ext_time_offset_lists)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Time point screen capturing template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="extTimeOffsetLists")
    def ext_time_offset_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of screenshot time points. `s` and `%` formats are supported: When a time point string ends with `s`, its unit is second. For example, `3.5s` means the 3.5th second of the video; When a time point string ends with `%`, it is marked with corresponding percentage of the video duration. For example, `10%` means that the time point is at the 10% of the video entire duration.
        """
        return pulumi.get(self, "ext_time_offset_lists")

    @ext_time_offset_lists.setter
    def ext_time_offset_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ext_time_offset_lists", value)

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListArgs']]]]:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")

    @watermark_lists.setter
    def watermark_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListArgs']]]]):
        pulumi.set(self, "watermark_lists", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 svg_content: Optional[pulumi.Input[str]] = None,
                 text_content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] definition: Watermarking template ID.
        :param pulumi.Input[float] end_time_offset: End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        :param pulumi.Input[float] start_time_offset: Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        :param pulumi.Input[str] svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[str] text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Watermarking template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[pulumi.Input[str]]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @svg_content.setter
    def svg_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "svg_content", value)

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[pulumi.Input[str]]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")

    @text_content.setter
    def text_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_content", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 mosaic_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicListArgs']]]] = None,
                 watermark_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkListArgs']]]] = None):
        """
        :param pulumi.Input[str] definition: Video transcoding template ID.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicListArgs']]] mosaic_lists: List of blurs. Up to 10 ones can be supported.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkListArgs']]] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if mosaic_lists is not None:
            pulumi.set(__self__, "mosaic_lists", mosaic_lists)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Video transcoding template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="mosaicLists")
    def mosaic_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicListArgs']]]]:
        """
        List of blurs. Up to 10 ones can be supported.
        """
        return pulumi.get(self, "mosaic_lists")

    @mosaic_lists.setter
    def mosaic_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicListArgs']]]]):
        pulumi.set(self, "mosaic_lists", value)

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkListArgs']]]]:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")

    @watermark_lists.setter
    def watermark_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkListArgs']]]]):
        pulumi.set(self, "watermark_lists", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicListArgs:
    def __init__(__self__, *,
                 coordinate_origin: Optional[pulumi.Input[str]] = None,
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 height: Optional[pulumi.Input[str]] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 width: Optional[pulumi.Input[str]] = None,
                 x_pos: Optional[pulumi.Input[str]] = None,
                 y_pos: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] coordinate_origin: Origin position, which currently can only be: `TopLeft`: the origin of coordinates is in the top-left corner of the video, and the origin of the blur is in the top-left corner of the image or text. Default value: TopLeft.
        :param pulumi.Input[float] end_time_offset: End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        :param pulumi.Input[str] height: Blur height. `%` and `px` formats are supported: If the string ends in `%`, the `height` of the blur will be the specified percentage of the video height; for example, 10% means that Height is 10% of the video height; If the string ends in `px`, the `height` of the blur will be in px; for example, 100px means that Height is 100 px. Default value: `10%`.
        :param pulumi.Input[float] start_time_offset: Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        :param pulumi.Input[str] width: Blur width. `%` and `px` formats are supported: If the string ends in `%`, the `width` of the blur will be the specified percentage of the video width; for example, 10% means that `width` is 10% of the video width; If the string ends in `px`, the `width` of the blur will be in px; for example, 100px means that Width is 100 px. Default value: `10%`.
        :param pulumi.Input[str] x_pos: The horizontal position of the origin of the blur relative to the origin of coordinates of the video. `%` and `px` formats are supported: If the string ends in `%`, the XPos of the blur will be the specified percentage of the video width; for example, 10% means that XPos is 10% of the video width; If the string ends in `px`, the XPos of the blur will be the specified px; for example, 100px means that XPos is 100 px. Default value: `0px`.
        :param pulumi.Input[str] y_pos: Vertical position of the origin of blur relative to the origin of coordinates of video. `%` and `px` formats are supported: If the string ends in `%`, the YPos of the blur will be the specified percentage of the video height; for example, 10% means that YPos is 10% of the video height; If the string ends in `px`, the YPos of the blur will be the specified px; for example, 100px means that YPos is 100 px. Default value: `0px`.
        """
        if coordinate_origin is not None:
            pulumi.set(__self__, "coordinate_origin", coordinate_origin)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if x_pos is not None:
            pulumi.set(__self__, "x_pos", x_pos)
        if y_pos is not None:
            pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter(name="coordinateOrigin")
    def coordinate_origin(self) -> Optional[pulumi.Input[str]]:
        """
        Origin position, which currently can only be: `TopLeft`: the origin of coordinates is in the top-left corner of the video, and the origin of the blur is in the top-left corner of the image or text. Default value: TopLeft.
        """
        return pulumi.get(self, "coordinate_origin")

    @coordinate_origin.setter
    def coordinate_origin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "coordinate_origin", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        Blur height. `%` and `px` formats are supported: If the string ends in `%`, the `height` of the blur will be the specified percentage of the video height; for example, 10% means that Height is 10% of the video height; If the string ends in `px`, the `height` of the blur will be in px; for example, 100px means that Height is 100 px. Default value: `10%`.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        Blur width. `%` and `px` formats are supported: If the string ends in `%`, the `width` of the blur will be the specified percentage of the video width; for example, 10% means that `width` is 10% of the video width; If the string ends in `px`, the `width` of the blur will be in px; for example, 100px means that Width is 100 px. Default value: `10%`.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> Optional[pulumi.Input[str]]:
        """
        The horizontal position of the origin of the blur relative to the origin of coordinates of the video. `%` and `px` formats are supported: If the string ends in `%`, the XPos of the blur will be the specified percentage of the video width; for example, 10% means that XPos is 10% of the video width; If the string ends in `px`, the XPos of the blur will be the specified px; for example, 100px means that XPos is 100 px. Default value: `0px`.
        """
        return pulumi.get(self, "x_pos")

    @x_pos.setter
    def x_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_pos", value)

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> Optional[pulumi.Input[str]]:
        """
        Vertical position of the origin of blur relative to the origin of coordinates of video. `%` and `px` formats are supported: If the string ends in `%`, the YPos of the blur will be the specified percentage of the video height; for example, 10% means that YPos is 10% of the video height; If the string ends in `px`, the YPos of the blur will be the specified px; for example, 100px means that YPos is 100 px. Default value: `0px`.
        """
        return pulumi.get(self, "y_pos")

    @y_pos.setter
    def y_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "y_pos", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 svg_content: Optional[pulumi.Input[str]] = None,
                 text_content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] definition: Watermarking template ID.
        :param pulumi.Input[float] end_time_offset: End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        :param pulumi.Input[float] start_time_offset: Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        :param pulumi.Input[str] svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[str] text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Watermarking template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[pulumi.Input[str]]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @svg_content.setter
    def svg_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "svg_content", value)

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[pulumi.Input[str]]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")

    @text_content.setter
    def text_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_content", value)


@pulumi.input_type
class SuperPlayerConfigDrmStreamingInfoArgs:
    def __init__(__self__, *,
                 simple_aes_definition: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] simple_aes_definition: ID of the adaptive dynamic streaming template whose protection type is `SimpleAES`.
        """
        if simple_aes_definition is not None:
            pulumi.set(__self__, "simple_aes_definition", simple_aes_definition)

    @property
    @pulumi.getter(name="simpleAesDefinition")
    def simple_aes_definition(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the adaptive dynamic streaming template whose protection type is `SimpleAES`.
        """
        return pulumi.get(self, "simple_aes_definition")

    @simple_aes_definition.setter
    def simple_aes_definition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "simple_aes_definition", value)


@pulumi.input_type
class SuperPlayerConfigResolutionNameArgs:
    def __init__(__self__, *,
                 min_edge_length: pulumi.Input[int],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[int] min_edge_length: Length of video short side in px.
        :param pulumi.Input[str] name: Display name.
        """
        pulumi.set(__self__, "min_edge_length", min_edge_length)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="minEdgeLength")
    def min_edge_length(self) -> pulumi.Input[int]:
        """
        Length of video short side in px.
        """
        return pulumi.get(self, "min_edge_length")

    @min_edge_length.setter
    def min_edge_length(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_edge_length", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Display name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


