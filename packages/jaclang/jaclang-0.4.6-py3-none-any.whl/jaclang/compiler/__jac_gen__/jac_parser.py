# The file was automatically generated by Lark v1.1.8
__version__ = "1.1.8"

#
#
#   Lark Stand-alone Generator Tool
# ----------------------------------
# Generates a stand-alone LALR(1) parser
#
# Git:    https://github.com/erezsh/lark
# Author: Erez Shinan (erezshin@gmail.com)
#
#
#    >>> LICENSE
#
#    This tool and its generated code use a separate license from Lark,
#    and are subject to the terms of the Mozilla Public License, v. 2.0.
#    If a copy of the MPL was not distributed with this
#    file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
#    If you wish to purchase a commercial license for this tool and its
#    generated code, you may contact me via email or otherwise.
#
#    If MPL2 is incompatible with your free or open-source project,
#    contact me and we'll work it out.
#
#

from copy import deepcopy
from abc import ABC, abstractmethod
from types import ModuleType
from typing import (
    TypeVar,
    Generic,
    Type,
    Tuple,
    List,
    Dict,
    Iterator,
    Collection,
    Callable,
    Optional,
    FrozenSet,
    Any,
    Union,
    Iterable,
    IO,
    TYPE_CHECKING,
    overload,
    Sequence,
    Pattern as REPattern,
    ClassVar,
    Set,
    Mapping,
)




class LarkError(Exception):
    pass


class ConfigurationError(LarkError, ValueError):
    pass


def assert_config(value, options: Collection, msg="Got %r, expected one of %s"):
    if value not in options:
        raise ConfigurationError(msg % (value, options))


class GrammarError(LarkError):
    pass


class ParseError(LarkError):
    pass


class LexError(LarkError):
    pass


T = TypeVar("T")


class UnexpectedInput(LarkError):
    #--

    line: int
    column: int
    pos_in_stream = None
    state: Any
    _terminals_by_name = None
    interactive_parser: "InteractiveParser"

    def get_context(self, text: str, span: int = 40) -> str:
        #--
        assert self.pos_in_stream is not None, self
        pos = self.pos_in_stream
        start = max(pos - span, 0)
        end = pos + span
        if not isinstance(text, bytes):
            before = text[start:pos].rsplit("\n", 1)[-1]
            after = text[pos:end].split("\n", 1)[0]
            return before + after + "\n" + " " * len(before.expandtabs()) + "^\n"
        else:
            before = text[start:pos].rsplit(b"\n", 1)[-1]
            after = text[pos:end].split(b"\n", 1)[0]
            return (
                before + after + b"\n" + b" " * len(before.expandtabs()) + b"^\n"
            ).decode("ascii", "backslashreplace")

    def match_examples(
        self,
        parse_fn: "Callable[[str], Tree]",
        examples: Union[Mapping[T, Iterable[str]], Iterable[Tuple[T, Iterable[str]]]],
        token_type_match_fallback: bool = False,
        use_accepts: bool = True,
    ) -> Optional[T]:
        #--
        assert self.state is not None, "Not supported for this exception"

        if isinstance(examples, Mapping):
            examples = examples.items()

        candidate = (None, False)
        for i, (label, example) in enumerate(examples):
            assert not isinstance(example, str), "Expecting a list"

            for j, malformed in enumerate(example):
                try:
                    parse_fn(malformed)
                except UnexpectedInput as ut:
                    if ut.state == self.state:
                        if (
                            use_accepts
                            and isinstance(self, UnexpectedToken)
                            and isinstance(ut, UnexpectedToken)
                            and ut.accepts != self.accepts
                        ):
                            logger.debug(
                                "Different accepts with same state[%d]: %s != %s at example [%s][%s]"
                                % (self.state, self.accepts, ut.accepts, i, j)
                            )
                            continue
                        if isinstance(
                            self, (UnexpectedToken, UnexpectedEOF)
                        ) and isinstance(ut, (UnexpectedToken, UnexpectedEOF)):
                            if ut.token == self.token:  ##

                                logger.debug("Exact Match at example [%s][%s]" % (i, j))
                                return label

                            if token_type_match_fallback:
                                ##

                                if (ut.token.type == self.token.type) and not candidate[
                                    -1
                                ]:
                                    logger.debug(
                                        "Token Type Fallback at example [%s][%s]"
                                        % (i, j)
                                    )
                                    candidate = label, True

                        if candidate[0] is None:
                            logger.debug(
                                "Same State match at example [%s][%s]" % (i, j)
                            )
                            candidate = label, False

        return candidate[0]

    def _format_expected(self, expected):
        if self._terminals_by_name:
            d = self._terminals_by_name
            expected = [
                d[t_name].user_repr() if t_name in d else t_name for t_name in expected
            ]
        return "Expected one of: \n\t* %s\n" % "\n\t* ".join(expected)


class UnexpectedEOF(ParseError, UnexpectedInput):
    #--

    expected: "List[Token]"

    def __init__(self, expected, state=None, terminals_by_name=None):
        super(UnexpectedEOF, self).__init__()

        self.expected = expected
        self.state = state
        from .lexer import Token

        self.token = Token("<EOF>", "")  ##

        self.pos_in_stream = -1
        self.line = -1
        self.column = -1
        self._terminals_by_name = terminals_by_name

    def __str__(self):
        message = "Unexpected end-of-input. "
        message += self._format_expected(self.expected)
        return message


class UnexpectedCharacters(LexError, UnexpectedInput):
    #--

    allowed: Set[str]
    considered_tokens: Set[Any]

    def __init__(
        self,
        seq,
        lex_pos,
        line,
        column,
        allowed=None,
        considered_tokens=None,
        state=None,
        token_history=None,
        terminals_by_name=None,
        considered_rules=None,
    ):
        super(UnexpectedCharacters, self).__init__()

        ##

        self.line = line
        self.column = column
        self.pos_in_stream = lex_pos
        self.state = state
        self._terminals_by_name = terminals_by_name

        self.allowed = allowed
        self.considered_tokens = considered_tokens
        self.considered_rules = considered_rules
        self.token_history = token_history

        if isinstance(seq, bytes):
            self.char = seq[lex_pos : lex_pos + 1].decode("ascii", "backslashreplace")
        else:
            self.char = seq[lex_pos]
        self._context = self.get_context(seq)

    def __str__(self):
        message = (
            "No terminal matches '%s' in the current parser context, at line %d col %d"
            % (self.char, self.line, self.column)
        )
        message += "\n\n" + self._context
        if self.allowed:
            message += self._format_expected(self.allowed)
        if self.token_history:
            message += "\nPrevious tokens: %s\n" % ", ".join(
                repr(t) for t in self.token_history
            )
        return message


class UnexpectedToken(ParseError, UnexpectedInput):
    #--

    expected: Set[str]
    considered_rules: Set[str]

    def __init__(
        self,
        token,
        expected,
        considered_rules=None,
        state=None,
        interactive_parser=None,
        terminals_by_name=None,
        token_history=None,
    ):
        super(UnexpectedToken, self).__init__()

        ##

        self.line = getattr(token, "line", "?")
        self.column = getattr(token, "column", "?")
        self.pos_in_stream = getattr(token, "start_pos", None)
        self.state = state

        self.token = token
        self.expected = expected  ##

        self._accepts = NO_VALUE
        self.considered_rules = considered_rules
        self.interactive_parser = interactive_parser
        self._terminals_by_name = terminals_by_name
        self.token_history = token_history

    @property
    def accepts(self) -> Set[str]:
        if self._accepts is NO_VALUE:
            self._accepts = (
                self.interactive_parser and self.interactive_parser.accepts()
            )
        return self._accepts

    def __str__(self):
        message = "Unexpected token %r at line %s, column %s.\n%s" % (
            self.token,
            self.line,
            self.column,
            self._format_expected(self.accepts or self.expected),
        )
        if self.token_history:
            message += "Previous tokens: %r\n" % self.token_history

        return message


class VisitError(LarkError):
    #--

    obj: "Union[Tree, Token]"
    orig_exc: Exception

    def __init__(self, rule, obj, orig_exc):
        message = 'Error trying to process rule "%s":\n\n%s' % (rule, orig_exc)
        super(VisitError, self).__init__(message)

        self.rule = rule
        self.obj = obj
        self.orig_exc = orig_exc


class MissingVariableError(LarkError):
    pass



import sys, re
import logging

logger: logging.Logger = logging.getLogger("lark")
logger.addHandler(logging.StreamHandler())
##

##

logger.setLevel(logging.CRITICAL)


NO_VALUE = object()

T = TypeVar("T")


def classify(
    seq: Iterable, key: Optional[Callable] = None, value: Optional[Callable] = None
) -> Dict:
    d: Dict[Any, Any] = {}
    for item in seq:
        k = key(item) if (key is not None) else item
        v = value(item) if (value is not None) else item
        try:
            d[k].append(v)
        except KeyError:
            d[k] = [v]
    return d


def _deserialize(data: Any, namespace: Dict[str, Any], memo: Dict) -> Any:
    if isinstance(data, dict):
        if "__type__" in data:  ##

            class_ = namespace[data["__type__"]]
            return class_.deserialize(data, memo)
        elif "@" in data:
            return memo[data["@"]]
        return {
            key: _deserialize(value, namespace, memo) for key, value in data.items()
        }
    elif isinstance(data, list):
        return [_deserialize(value, namespace, memo) for value in data]
    return data


_T = TypeVar("_T", bound="Serialize")


class Serialize:
    #--

    def memo_serialize(self, types_to_memoize: List) -> Any:
        memo = SerializeMemoizer(types_to_memoize)
        return self.serialize(memo), memo.serialize()

    def serialize(self, memo=None) -> Dict[str, Any]:
        if memo and memo.in_types(self):
            return {"@": memo.memoized.get(self)}

        fields = getattr(self, "__serialize_fields__")
        res = {f: _serialize(getattr(self, f), memo) for f in fields}
        res["__type__"] = type(self).__name__
        if hasattr(self, "_serialize"):
            self._serialize(res, memo)  ##

        return res

    @classmethod
    def deserialize(cls: Type[_T], data: Dict[str, Any], memo: Dict[int, Any]) -> _T:
        namespace = getattr(cls, "__serialize_namespace__", [])
        namespace = {c.__name__: c for c in namespace}

        fields = getattr(cls, "__serialize_fields__")

        if "@" in data:
            return memo[data["@"]]

        inst = cls.__new__(cls)
        for f in fields:
            try:
                setattr(inst, f, _deserialize(data[f], namespace, memo))
            except KeyError as e:
                raise KeyError("Cannot find key for class", cls, e)

        if hasattr(inst, "_deserialize"):
            inst._deserialize()  ##


        return inst


class SerializeMemoizer(Serialize):
    #--

    __serialize_fields__ = ("memoized",)

    def __init__(self, types_to_memoize: List) -> None:
        self.types_to_memoize = tuple(types_to_memoize)
        self.memoized = Enumerator()

    def in_types(self, value: Serialize) -> bool:
        return isinstance(value, self.types_to_memoize)

    def serialize(self) -> Dict[int, Any]:  ##

        return _serialize(self.memoized.reversed(), None)

    @classmethod
    def deserialize(cls, data: Dict[int, Any], namespace: Dict[str, Any], memo: Dict[Any, Any]) -> Dict[int, Any]:  ##

        return _deserialize(data, namespace, memo)


try:
    import regex

    _has_regex = True
except ImportError:
    _has_regex = False

if sys.version_info >= (3, 11):
    import re._parser as sre_parse
    import re._constants as sre_constants
else:
    import sre_parse
    import sre_constants

categ_pattern = re.compile(r"\\p{[A-Za-z_]+}")


def get_regexp_width(expr: str) -> Union[Tuple[int, int], List[int]]:
    if _has_regex:
        ##

        ##

        ##

        regexp_final = re.sub(categ_pattern, "A", expr)
    else:
        if re.search(categ_pattern, expr):
            raise ImportError(
                "`regex` module must be installed in order to use Unicode categories.",
                expr,
            )
        regexp_final = expr
    try:
        ##

        return [int(x) for x in sre_parse.parse(regexp_final).getwidth()]  ##

    except sre_constants.error:
        if not _has_regex:
            raise ValueError(expr)
        else:
            ##

            ##

            c = regex.compile(regexp_final)
            if c.match("") is None:
                ##

                return 1, int(sre_constants.MAXREPEAT)
            else:
                return 0, int(sre_constants.MAXREPEAT)



from collections import OrderedDict


class Meta:
    empty: bool
    line: int
    column: int
    start_pos: int
    end_line: int
    end_column: int
    end_pos: int
    orig_expansion: "List[TerminalDef]"
    match_tree: bool

    def __init__(self):
        self.empty = True


_Leaf_T = TypeVar("_Leaf_T")
Branch = Union[_Leaf_T, "Tree[_Leaf_T]"]


class Tree(Generic[_Leaf_T]):
    #--

    data: str
    children: "List[Branch[_Leaf_T]]"

    def __init__(
        self, data: str, children: "List[Branch[_Leaf_T]]", meta: Optional[Meta] = None
    ) -> None:
        self.data = data
        self.children = children
        self._meta = meta

    @property
    def meta(self) -> Meta:
        if self._meta is None:
            self._meta = Meta()
        return self._meta

    def __repr__(self):
        return "Tree(%r, %r)" % (self.data, self.children)

    def _pretty_label(self):
        return self.data

    def _pretty(self, level, indent_str):
        yield f"{indent_str*level}{self._pretty_label()}"
        if len(self.children) == 1 and not isinstance(self.children[0], Tree):
            yield f"\t{self.children[0]}\n"
        else:
            yield "\n"
            for n in self.children:
                if isinstance(n, Tree):
                    yield from n._pretty(level + 1, indent_str)
                else:
                    yield f"{indent_str*(level+1)}{n}\n"

    def pretty(self, indent_str: str = "  ") -> str:
        #--
        return "".join(self._pretty(0, indent_str))

    def __rich__(self, parent: Optional["rich.tree.Tree"] = None) -> "rich.tree.Tree":
        #--
        return self._rich(parent)

    def _rich(self, parent):
        if parent:
            tree = parent.add(f"[bold]{self.data}[/bold]")
        else:
            import rich.tree

            tree = rich.tree.Tree(self.data)

        for c in self.children:
            if isinstance(c, Tree):
                c._rich(tree)
            else:
                tree.add(f"[green]{c}[/green]")

        return tree

    def __eq__(self, other):
        try:
            return self.data == other.data and self.children == other.children
        except AttributeError:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self) -> int:
        return hash((self.data, tuple(self.children)))

    def iter_subtrees(self) -> "Iterator[Tree[_Leaf_T]]":
        #--
        queue = [self]
        subtrees = OrderedDict()
        for subtree in queue:
            subtrees[id(subtree)] = subtree
            ##

            queue += [
                c
                for c in reversed(subtree.children)  ##

                if isinstance(c, Tree) and id(c) not in subtrees
            ]

        del queue
        return reversed(list(subtrees.values()))

    def iter_subtrees_topdown(self):
        #--
        stack = [self]
        stack_append = stack.append
        stack_pop = stack.pop
        while stack:
            node = stack_pop()
            if not isinstance(node, Tree):
                continue
            yield node
            for child in reversed(node.children):
                stack_append(child)

    def find_pred(
        self, pred: "Callable[[Tree[_Leaf_T]], bool]"
    ) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return filter(pred, self.iter_subtrees())

    def find_data(self, data: str) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return self.find_pred(lambda t: t.data == data)


from functools import wraps, update_wrapper
from inspect import getmembers, getmro

_Return_T = TypeVar("_Return_T")
_Return_V = TypeVar("_Return_V")
_Leaf_T = TypeVar("_Leaf_T")
_Leaf_U = TypeVar("_Leaf_U")
_R = TypeVar("_R")
_FUNC = Callable[..., _Return_T]
_DECORATED = Union[_FUNC, type]


class _DiscardType:
    #--

    def __repr__(self):
        return "lark.visitors.Discard"


Discard = _DiscardType()

##



class _Decoratable:
    #--

    @classmethod
    def _apply_v_args(cls, visit_wrapper):
        mro = getmro(cls)
        assert mro[0] is cls
        libmembers = {name for _cls in mro[1:] for name, _ in getmembers(_cls)}
        for name, value in getmembers(cls):
            ##

            if name.startswith("_") or (
                name in libmembers and name not in cls.__dict__
            ):
                continue
            if not callable(value):
                continue

            ##

            if isinstance(cls.__dict__[name], _VArgsWrapper):
                continue

            setattr(cls, name, _VArgsWrapper(cls.__dict__[name], visit_wrapper))
        return cls

    def __class_getitem__(cls, _):
        return cls


class Transformer(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    __visit_tokens__ = True  ##


    def __init__(self, visit_tokens: bool = True) -> None:
        self.__visit_tokens__ = visit_tokens

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            try:
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    return f.visit_wrapper(f, tree.data, children, tree.meta)
                else:
                    return f(children)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(tree.data, tree, e)

    def _call_userfunc_token(self, token):
        try:
            f = getattr(self, token.type)
        except AttributeError:
            return self.__default_token__(token)
        else:
            try:
                return f(token)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(token.type, token, e)

    def _transform_children(self, children):
        for c in children:
            if isinstance(c, Tree):
                res = self._transform_tree(c)
            elif self.__visit_tokens__ and isinstance(c, Token):
                res = self._call_userfunc_token(c)
            else:
                res = c

            if res is not Discard:
                yield res

    def _transform_tree(self, tree):
        children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree, children)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        #--
        return self._transform_tree(tree)

    def __mul__(
        self: "Transformer[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V,]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        #--
        return TransformerChain(self, other)

    def __default__(self, data, children, meta):
        #--
        return Tree(data, children, meta)

    def __default_token__(self, token):
        #--
        return token


def merge_transformers(base_transformer=None, **transformers_to_merge):
    #--
    if base_transformer is None:
        base_transformer = Transformer()
    for prefix, transformer in transformers_to_merge.items():
        for method_name in dir(transformer):
            method = getattr(transformer, method_name)
            if not callable(method):
                continue
            if method_name.startswith("_") or method_name == "transform":
                continue
            prefixed_method = prefix + "__" + method_name
            if hasattr(base_transformer, prefixed_method):
                raise AttributeError(
                    "Cannot merge: method '%s' appears more than once" % prefixed_method
                )

            setattr(base_transformer, prefixed_method, method)

    return base_transformer


class InlineTransformer(Transformer):  ##

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            return f(*children)


class TransformerChain(Generic[_Leaf_T, _Return_T]):
    transformers: "Tuple[Union[Transformer, TransformerChain], ...]"

    def __init__(self, *transformers: "Union[Transformer, TransformerChain]") -> None:
        self.transformers = transformers

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for t in self.transformers:
            tree = t.transform(tree)
        return cast(_Return_T, tree)

    def __mul__(
        self: "TransformerChain[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        return TransformerChain(*self.transformers + (other,))


class Transformer_InPlace(Transformer[_Leaf_T, _Return_T]):
    #--

    def _transform_tree(self, tree):  ##

        return self._call_userfunc(tree)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for subtree in tree.iter_subtrees():
            subtree.children = list(self._transform_children(subtree.children))

        return self._transform_tree(tree)


class Transformer_NonRecursive(Transformer[_Leaf_T, _Return_T]):
    #--

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        rev_postfix = []
        q: List[Branch[_Leaf_T]] = [tree]
        while q:
            t = q.pop()
            rev_postfix.append(t)
            if isinstance(t, Tree):
                q += t.children

        ##

        stack: List = []
        for x in reversed(rev_postfix):
            if isinstance(x, Tree):
                size = len(x.children)
                if size:
                    args = stack[-size:]
                    del stack[-size:]
                else:
                    args = []

                res = self._call_userfunc(x, args)
                if res is not Discard:
                    stack.append(res)

            elif self.__visit_tokens__ and isinstance(x, Token):
                res = self._call_userfunc_token(x)
                if res is not Discard:
                    stack.append(res)
            else:
                stack.append(x)

        (result,) = stack  ##

        ##

        ##

        ##

        return cast(_Return_T, result)


class Transformer_InPlaceRecursive(Transformer):
    #--

    def _transform_tree(self, tree):
        tree.children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree)


##



class VisitorBase:
    def _call_userfunc(self, tree):
        return getattr(self, tree.data, self.__default__)(tree)

    def __default__(self, tree):
        #--
        return tree

    def __class_getitem__(cls, _):
        return cls


class Visitor(VisitorBase, ABC, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees():
            self._call_userfunc(subtree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees_topdown():
            self._call_userfunc(subtree)
        return tree


class Visitor_Recursive(VisitorBase, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

        self._call_userfunc(tree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        self._call_userfunc(tree)

        for child in tree.children:
            if isinstance(child, Tree):
                self.visit_topdown(child)

        return tree


class Interpreter(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        ##

        ##

        return self._visit_tree(tree)

    def _visit_tree(self, tree: Tree[_Leaf_T]):
        f = getattr(self, tree.data)
        wrapper = getattr(f, "visit_wrapper", None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta)
        else:
            return f(tree)

    def visit_children(self, tree: Tree[_Leaf_T]) -> List:
        return [
            self._visit_tree(child) if isinstance(child, Tree) else child
            for child in tree.children
        ]

    def __getattr__(self, name):
        return self.__default__

    def __default__(self, tree):
        return self.visit_children(tree)


_InterMethod = Callable[[Type[Interpreter], _Return_T], _R]


def visit_children_decor(func: _InterMethod) -> _InterMethod:
    #--

    @wraps(func)
    def inner(cls, tree):
        values = cls.visit_children(tree)
        return func(cls, values)

    return inner


##



def _apply_v_args(obj, visit_wrapper):
    try:
        _apply = obj._apply_v_args
    except AttributeError:
        return _VArgsWrapper(obj, visit_wrapper)
    else:
        return _apply(visit_wrapper)


class _VArgsWrapper:
    #--

    base_func: Callable

    def __init__(
        self, func: Callable, visit_wrapper: Callable[[Callable, str, list, Any], Any]
    ):
        if isinstance(func, _VArgsWrapper):
            func = func.base_func
        ##

        self.base_func = func  ##

        self.visit_wrapper = visit_wrapper
        update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        return self.base_func(*args, **kwargs)

    def __get__(self, instance, owner=None):
        try:
            ##

            ##

            g = type(self.base_func).__get__
        except AttributeError:
            return self
        else:
            return _VArgsWrapper(g(self.base_func, instance, owner), self.visit_wrapper)

    def __set_name__(self, owner, name):
        try:
            f = type(self.base_func).__set_name__
        except AttributeError:
            return
        else:
            f(self.base_func, owner, name)


def _vargs_inline(f, _data, children, _meta):
    return f(*children)


def _vargs_meta_inline(f, _data, children, meta):
    return f(meta, *children)


def _vargs_meta(f, _data, children, meta):
    return f(meta, children)


def _vargs_tree(f, data, children, meta):
    return f(Tree(data, children, meta))


def v_args(
    inline: bool = False,
    meta: bool = False,
    tree: bool = False,
    wrapper: Optional[Callable] = None,
) -> Callable[[_DECORATED], _DECORATED]:
    #--
    if tree and (meta or inline):
        raise ValueError(
            "Visitor functions cannot combine 'tree' with 'meta' or 'inline'."
        )

    func = None
    if meta:
        if inline:
            func = _vargs_meta_inline
        else:
            func = _vargs_meta
    elif inline:
        func = _vargs_inline
    elif tree:
        func = _vargs_tree

    if wrapper is not None:
        if func is not None:
            raise ValueError(
                "Cannot use 'wrapper' along with 'tree', 'meta' or 'inline'."
            )
        func = wrapper

    def _visitor_args_dec(obj):
        return _apply_v_args(obj, func)

    return _visitor_args_dec



TOKEN_DEFAULT_PRIORITY = 0


class Symbol(Serialize):
    __slots__ = ("name",)

    name: str
    is_term: ClassVar[bool] = NotImplemented

    def __init__(self, name: str) -> None:
        self.name = name

    def __eq__(self, other):
        assert isinstance(other, Symbol), other
        return self.is_term == other.is_term and self.name == other.name

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return "%s(%r)" % (type(self).__name__, self.name)

    fullrepr = property(__repr__)

    def renamed(self, f):
        return type(self)(f(self.name))


class Terminal(Symbol):
    __serialize_fields__ = "name", "filter_out"

    is_term: ClassVar[bool] = True

    def __init__(self, name, filter_out=False):
        self.name = name
        self.filter_out = filter_out

    @property
    def fullrepr(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.filter_out)

    def renamed(self, f):
        return type(self)(f(self.name), self.filter_out)


class NonTerminal(Symbol):
    __serialize_fields__ = ("name",)

    is_term: ClassVar[bool] = False


class RuleOptions(Serialize):
    __serialize_fields__ = (
        "keep_all_tokens",
        "expand1",
        "priority",
        "template_source",
        "empty_indices",
    )

    keep_all_tokens: bool
    expand1: bool
    priority: Optional[int]
    template_source: Optional[str]
    empty_indices: Tuple[bool, ...]

    def __init__(
        self,
        keep_all_tokens: bool = False,
        expand1: bool = False,
        priority: Optional[int] = None,
        template_source: Optional[str] = None,
        empty_indices: Tuple[bool, ...] = (),
    ) -> None:
        self.keep_all_tokens = keep_all_tokens
        self.expand1 = expand1
        self.priority = priority
        self.template_source = template_source
        self.empty_indices = empty_indices

    def __repr__(self):
        return "RuleOptions(%r, %r, %r, %r)" % (
            self.keep_all_tokens,
            self.expand1,
            self.priority,
            self.template_source,
        )


class Rule(Serialize):
    #--

    __slots__ = ("origin", "expansion", "alias", "options", "order", "_hash")

    __serialize_fields__ = "origin", "expansion", "order", "alias", "options"
    __serialize_namespace__ = Terminal, NonTerminal, RuleOptions

    origin: NonTerminal
    expansion: Sequence[Symbol]
    order: int
    alias: Optional[str]
    options: RuleOptions
    _hash: int

    def __init__(
        self,
        origin: NonTerminal,
        expansion: Sequence[Symbol],
        order: int = 0,
        alias: Optional[str] = None,
        options: Optional[RuleOptions] = None,
    ):
        self.origin = origin
        self.expansion = expansion
        self.alias = alias
        self.order = order
        self.options = options or RuleOptions()
        self._hash = hash((self.origin, tuple(self.expansion)))

    def _deserialize(self):
        self._hash = hash((self.origin, tuple(self.expansion)))

    def __str__(self):
        return "<%s : %s>" % (
            self.origin.name,
            " ".join(x.name for x in self.expansion),
        )

    def __repr__(self):
        return "Rule(%r, %r, %r, %r)" % (
            self.origin,
            self.expansion,
            self.alias,
            self.options,
        )

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return self.origin == other.origin and self.expansion == other.expansion



from copy import copy

try:  ##

    has_interegular = bool(interegular)
except NameError:
    has_interegular = False


class Pattern(Serialize, ABC):
    #--

    value: str
    flags: Collection[str]
    raw: Optional[str]
    type: ClassVar[str]

    def __init__(
        self, value: str, flags: Collection[str] = (), raw: Optional[str] = None
    ) -> None:
        self.value = value
        self.flags = frozenset(flags)
        self.raw = raw

    def __repr__(self):
        return repr(self.to_regexp())

    ##

    def __hash__(self):
        return hash((type(self), self.value, self.flags))

    def __eq__(self, other):
        return (
            type(self) == type(other)
            and self.value == other.value
            and self.flags == other.flags
        )

    @abstractmethod
    def to_regexp(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def min_width(self) -> int:
        raise NotImplementedError()

    @property
    @abstractmethod
    def max_width(self) -> int:
        raise NotImplementedError()

    def _get_flags(self, value):
        for f in self.flags:
            value = "(?%s:%s)" % (f, value)
        return value


class PatternStr(Pattern):
    __serialize_fields__ = "value", "flags", "raw"

    type: ClassVar[str] = "str"

    def to_regexp(self) -> str:
        return self._get_flags(re.escape(self.value))

    @property
    def min_width(self) -> int:
        return len(self.value)

    @property
    def max_width(self) -> int:
        return len(self.value)


class PatternRE(Pattern):
    __serialize_fields__ = "value", "flags", "raw", "_width"

    type: ClassVar[str] = "re"

    def to_regexp(self) -> str:
        return self._get_flags(self.value)

    _width = None

    def _get_width(self):
        if self._width is None:
            self._width = get_regexp_width(self.to_regexp())
        return self._width

    @property
    def min_width(self) -> int:
        return self._get_width()[0]

    @property
    def max_width(self) -> int:
        return self._get_width()[1]


class TerminalDef(Serialize):
    #--
    __serialize_fields__ = "name", "pattern", "priority"
    __serialize_namespace__ = PatternStr, PatternRE

    name: str
    pattern: Pattern
    priority: int

    def __init__(
        self, name: str, pattern: Pattern, priority: int = TOKEN_DEFAULT_PRIORITY
    ) -> None:
        assert isinstance(pattern, Pattern), pattern
        self.name = name
        self.pattern = pattern
        self.priority = priority

    def __repr__(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.pattern)

    def user_repr(self) -> str:
        if self.name.startswith("__"):  ##

            return self.pattern.raw or self.name
        else:
            return self.name


_T = TypeVar("_T", bound="Token")


class Token(str):
    #--

    __slots__ = (
        "type",
        "start_pos",
        "value",
        "line",
        "column",
        "end_line",
        "end_column",
        "end_pos",
    )

    __match_args__ = ("type", "value")

    type: str
    start_pos: Optional[int]
    value: Any
    line: Optional[int]
    column: Optional[int]
    end_line: Optional[int]
    end_column: Optional[int]
    end_pos: Optional[int]

    @overload
    def __new__(
        cls,
        type: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    @overload
    def __new__(
        cls,
        type_: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    def __new__(cls, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return cls._future_new(*args, **kwargs)

    @classmethod
    def _future_new(
        cls,
        type,
        value,
        start_pos=None,
        line=None,
        column=None,
        end_line=None,
        end_column=None,
        end_pos=None,
    ):
        inst = super(Token, cls).__new__(cls, value)

        inst.type = type
        inst.start_pos = start_pos
        inst.value = value
        inst.line = line
        inst.column = column
        inst.end_line = end_line
        inst.end_column = end_column
        inst.end_pos = end_pos
        return inst

    @overload
    def update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    @overload
    def update(
        self, type_: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    def update(self, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return self._future_update(*args, **kwargs)

    def _future_update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        return Token.new_borrow_pos(
            type if type is not None else self.type,
            value if value is not None else self.value,
            self,
        )

    @classmethod
    def new_borrow_pos(cls: Type[_T], type_: str, value: Any, borrow_t: "Token") -> _T:
        return cls(
            type_,
            value,
            borrow_t.start_pos,
            borrow_t.line,
            borrow_t.column,
            borrow_t.end_line,
            borrow_t.end_column,
            borrow_t.end_pos,
        )

    def __reduce__(self):
        return (
            self.__class__,
            (self.type, self.value, self.start_pos, self.line, self.column),
        )

    def __repr__(self):
        return "Token(%r, %r)" % (self.type, self.value)

    def __deepcopy__(self, memo):
        return Token(self.type, self.value, self.start_pos, self.line, self.column)

    def __eq__(self, other):
        if isinstance(other, Token) and self.type != other.type:
            return False

        return str.__eq__(self, other)

    __hash__ = str.__hash__


class LineCounter:
    #--

    __slots__ = "char_pos", "line", "column", "line_start_pos", "newline_char"

    def __init__(self, newline_char):
        self.newline_char = newline_char
        self.char_pos = 0
        self.line = 1
        self.column = 1
        self.line_start_pos = 0

    def __eq__(self, other):
        if not isinstance(other, LineCounter):
            return NotImplemented

        return (
            self.char_pos == other.char_pos and self.newline_char == other.newline_char
        )

    def feed(self, token: Token, test_newline=True):
        #--
        if test_newline:
            newlines = token.count(self.newline_char)
            if newlines:
                self.line += newlines
                self.line_start_pos = (
                    self.char_pos + token.rindex(self.newline_char) + 1
                )

        self.char_pos += len(token)
        self.column = self.char_pos - self.line_start_pos + 1


class UnlessCallback:
    def __init__(self, scanner):
        self.scanner = scanner

    def __call__(self, t):
        res = self.scanner.match(t.value, 0)
        if res:
            _value, t.type = res
        return t


class CallChain:
    def __init__(self, callback1, callback2, cond):
        self.callback1 = callback1
        self.callback2 = callback2
        self.cond = cond

    def __call__(self, t):
        t2 = self.callback1(t)
        return self.callback2(t) if self.cond(t2) else t2


def _get_match(re_, regexp, s, flags):
    m = re_.match(regexp, s, flags)
    if m:
        return m.group(0)


def _create_unless(terminals, g_regex_flags, re_, use_bytes):
    tokens_by_type = classify(terminals, lambda t: type(t.pattern))
    assert len(tokens_by_type) <= 2, tokens_by_type.keys()
    embedded_strs = set()
    callback = {}
    for retok in tokens_by_type.get(PatternRE, []):
        unless = []
        for strtok in tokens_by_type.get(PatternStr, []):
            if strtok.priority != retok.priority:
                continue
            s = strtok.pattern.value
            if s == _get_match(re_, retok.pattern.to_regexp(), s, g_regex_flags):
                unless.append(strtok)
                if strtok.pattern.flags <= retok.pattern.flags:
                    embedded_strs.add(strtok)
        if unless:
            callback[retok.name] = UnlessCallback(
                Scanner(
                    unless, g_regex_flags, re_, match_whole=True, use_bytes=use_bytes
                )
            )

    new_terminals = [t for t in terminals if t not in embedded_strs]
    return new_terminals, callback


class Scanner:
    def __init__(self, terminals, g_regex_flags, re_, use_bytes, match_whole=False):
        self.terminals = terminals
        self.g_regex_flags = g_regex_flags
        self.re_ = re_
        self.use_bytes = use_bytes
        self.match_whole = match_whole

        self.allowed_types = {t.name for t in self.terminals}

        self._mres = self._build_mres(terminals, len(terminals))

    def _build_mres(self, terminals, max_size):
        ##

        ##

        ##

        postfix = "$" if self.match_whole else ""
        mres = []
        while terminals:
            pattern = "|".join(
                "(?P<%s>%s)" % (t.name, t.pattern.to_regexp() + postfix)
                for t in terminals[:max_size]
            )
            if self.use_bytes:
                pattern = pattern.encode("latin-1")
            try:
                mre = self.re_.compile(pattern, self.g_regex_flags)
            except AssertionError:  ##

                return self._build_mres(terminals, max_size // 2)

            mres.append(mre)
            terminals = terminals[max_size:]
        return mres

    def match(self, text, pos):
        for mre in self._mres:
            m = mre.match(text, pos)
            if m:
                return m.group(0), m.lastgroup


def _regexp_has_newline(r: str):
    #--
    return (
        "\n" in r or "\\n" in r or "\\s" in r or "[^" in r or ("(?s" in r and "." in r)
    )


class LexerState:
    #--

    __slots__ = "text", "line_ctr", "last_token"

    text: str
    line_ctr: LineCounter
    last_token: Optional[Token]

    def __init__(
        self,
        text: str,
        line_ctr: Optional[LineCounter] = None,
        last_token: Optional[Token] = None,
    ):
        self.text = text
        self.line_ctr = line_ctr or LineCounter(
            b"\n" if isinstance(text, bytes) else "\n"
        )
        self.last_token = last_token

    def __eq__(self, other):
        if not isinstance(other, LexerState):
            return NotImplemented

        return (
            self.text is other.text
            and self.line_ctr == other.line_ctr
            and self.last_token == other.last_token
        )

    def __copy__(self):
        return type(self)(self.text, copy(self.line_ctr), self.last_token)


class LexerThread:
    #--

    def __init__(self, lexer: "Lexer", lexer_state: LexerState):
        self.lexer = lexer
        self.state = lexer_state

    @classmethod
    def from_text(cls, lexer: "Lexer", text: str) -> "LexerThread":
        return cls(lexer, LexerState(text))

    def lex(self, parser_state):
        return self.lexer.lex(self.state, parser_state)

    def __copy__(self):
        return type(self)(self.lexer, copy(self.state))

    _Token = Token


_Callback = Callable[[Token], Token]


class Lexer(ABC):
    #--

    @abstractmethod
    def lex(self, lexer_state: LexerState, parser_state: Any) -> Iterator[Token]:
        return NotImplemented

    def make_lexer_state(self, text):
        #--
        return LexerState(text)


def _check_regex_collisions(
    terminal_to_regexp: Dict[TerminalDef, str],
    comparator,
    strict_mode,
    max_collisions_to_show=8,
):
    if not comparator:
        comparator = interegular.Comparator.from_regexes(terminal_to_regexp)

    ##

    ##

    max_time = 2 if strict_mode else 0.2

    ##

    if comparator.count_marked_pairs() >= max_collisions_to_show:
        return
    for group in classify(terminal_to_regexp, lambda t: t.priority).values():
        for a, b in comparator.check(group, skip_marked=True):
            assert a.priority == b.priority
            ##

            comparator.mark(a, b)

            ##

            message = f"Collision between Terminals {a.name} and {b.name}. "
            try:
                example = comparator.get_example_overlap(
                    a, b, max_time
                ).format_multiline()
            except ValueError:
                ##

                example = "No example could be found fast enough. However, the collision does still exists"
            if strict_mode:
                raise LexError(f"{message}\n{example}")
            logger.warning(
                "%s The lexer will choose between them arbitrarily.\n%s",
                message,
                example,
            )
            if comparator.count_marked_pairs() >= max_collisions_to_show:
                logger.warning("Found 8 regex collisions, will not check for more.")
                return


class AbstractBasicLexer(Lexer):
    terminals_by_name: Dict[str, TerminalDef]

    @abstractmethod
    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        ...

    @abstractmethod
    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        ...

    def lex(self, state: LexerState, parser_state: Any) -> Iterator[Token]:
        with suppress(EOFError):
            while True:
                yield self.next_token(state, parser_state)


class BasicLexer(AbstractBasicLexer):
    terminals: Collection[TerminalDef]
    ignore_types: FrozenSet[str]
    newline_types: FrozenSet[str]
    user_callbacks: Dict[str, _Callback]
    callback: Dict[str, _Callback]
    re: ModuleType

    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        terminals = list(conf.terminals)
        assert all(isinstance(t, TerminalDef) for t in terminals), terminals

        self.re = conf.re_module

        if not conf.skip_validation:
            ##

            terminal_to_regexp = {}
            for t in terminals:
                regexp = t.pattern.to_regexp()
                try:
                    self.re.compile(regexp, conf.g_regex_flags)
                except self.re.error:
                    raise LexError("Cannot compile token %s: %s" % (t.name, t.pattern))

                if t.pattern.min_width == 0:
                    raise LexError(
                        "Lexer does not allow zero-width terminals. (%s: %s)"
                        % (t.name, t.pattern)
                    )
                if t.pattern.type == "re":
                    terminal_to_regexp[t] = regexp

            if not (set(conf.ignore) <= {t.name for t in terminals}):
                raise LexError(
                    "Ignore terminals are not defined: %s"
                    % (set(conf.ignore) - {t.name for t in terminals})
                )

            if has_interegular:
                _check_regex_collisions(terminal_to_regexp, comparator, conf.strict)
            elif conf.strict:
                raise LexError(
                    "interegular must be installed for strict mode. Use `pip install 'lark[interegular]'`."
                )

        ##

        self.newline_types = frozenset(
            t.name for t in terminals if _regexp_has_newline(t.pattern.to_regexp())
        )
        self.ignore_types = frozenset(conf.ignore)

        terminals.sort(
            key=lambda x: (
                -x.priority,
                -x.pattern.max_width,
                -len(x.pattern.value),
                x.name,
            )
        )
        self.terminals = terminals
        self.user_callbacks = conf.callbacks
        self.g_regex_flags = conf.g_regex_flags
        self.use_bytes = conf.use_bytes
        self.terminals_by_name = conf.terminals_by_name

        self._scanner = None

    def _build_scanner(self):
        terminals, self.callback = _create_unless(
            self.terminals, self.g_regex_flags, self.re, self.use_bytes
        )
        assert all(self.callback.values())

        for type_, f in self.user_callbacks.items():
            if type_ in self.callback:
                ##

                self.callback[type_] = CallChain(
                    self.callback[type_], f, lambda t: t.type == type_
                )
            else:
                self.callback[type_] = f

        self._scanner = Scanner(terminals, self.g_regex_flags, self.re, self.use_bytes)

    @property
    def scanner(self):
        if self._scanner is None:
            self._build_scanner()
        return self._scanner

    def match(self, text, pos):
        return self.scanner.match(text, pos)

    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        line_ctr = lex_state.line_ctr
        while line_ctr.char_pos < len(lex_state.text):
            res = self.match(lex_state.text, line_ctr.char_pos)
            if not res:
                allowed = self.scanner.allowed_types - self.ignore_types
                if not allowed:
                    allowed = {"<END-OF-FILE>"}
                raise UnexpectedCharacters(
                    lex_state.text,
                    line_ctr.char_pos,
                    line_ctr.line,
                    line_ctr.column,
                    allowed=allowed,
                    token_history=lex_state.last_token and [lex_state.last_token],
                    state=parser_state,
                    terminals_by_name=self.terminals_by_name,
                )

            value, type_ = res

            ignored = type_ in self.ignore_types
            t = None
            if not ignored or type_ in self.callback:
                t = Token(
                    type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column
                )
            line_ctr.feed(value, type_ in self.newline_types)
            if t is not None:
                t.end_line = line_ctr.line
                t.end_column = line_ctr.column
                t.end_pos = line_ctr.char_pos
                if t.type in self.callback:
                    t = self.callback[t.type](t)
                if not ignored:
                    if not isinstance(t, Token):
                        raise LexError(
                            "Callbacks must return a token (returned %r)" % t
                        )
                    lex_state.last_token = t
                    return t

        ##

        raise EOFError(self)


class ContextualLexer(Lexer):
    lexers: Dict[int, AbstractBasicLexer]
    root_lexer: AbstractBasicLexer

    BasicLexer: Type[AbstractBasicLexer] = BasicLexer

    def __init__(
        self,
        conf: "LexerConf",
        states: Dict[int, Collection[str]],
        always_accept: Collection[str] = (),
    ) -> None:
        terminals = list(conf.terminals)
        terminals_by_name = conf.terminals_by_name

        trad_conf = copy(conf)
        trad_conf.terminals = terminals

        if has_interegular and not conf.skip_validation:
            comparator = interegular.Comparator.from_regexes(
                {t: t.pattern.to_regexp() for t in terminals}
            )
        else:
            comparator = None
        lexer_by_tokens: Dict[FrozenSet[str], AbstractBasicLexer] = {}
        self.lexers = {}
        for state, accepts in states.items():
            key = frozenset(accepts)
            try:
                lexer = lexer_by_tokens[key]
            except KeyError:
                accepts = set(accepts) | set(conf.ignore) | set(always_accept)
                lexer_conf = copy(trad_conf)
                lexer_conf.terminals = [
                    terminals_by_name[n] for n in accepts if n in terminals_by_name
                ]
                lexer = self.BasicLexer(lexer_conf, comparator)
                lexer_by_tokens[key] = lexer

            self.lexers[state] = lexer

        assert trad_conf.terminals is terminals
        trad_conf.skip_validation = True  ##

        self.root_lexer = self.BasicLexer(trad_conf, comparator)

    def lex(
        self, lexer_state: LexerState, parser_state: "ParserState"
    ) -> Iterator[Token]:
        try:
            while True:
                lexer = self.lexers[parser_state.position]
                yield lexer.next_token(lexer_state, parser_state)
        except EOFError:
            pass
        except UnexpectedCharacters as e:
            ##

            ##

            try:
                last_token = (
                    lexer_state.last_token
                )  ##

                token = self.root_lexer.next_token(lexer_state, parser_state)
                raise UnexpectedToken(
                    token,
                    e.allowed,
                    state=parser_state,
                    token_history=[last_token],
                    terminals_by_name=self.root_lexer.terminals_by_name,
                )
            except UnexpectedCharacters:
                raise e  ##





_ParserArgType: "TypeAlias" = 'Literal["earley", "lalr", "cyk", "auto"]'
_LexerArgType: "TypeAlias" = 'Union[Literal["auto", "basic", "contextual", "dynamic", "dynamic_complete"], Type[Lexer]]'
_LexerCallback = Callable[[Token], Token]
ParserCallbacks = Dict[str, Callable]


class LexerConf(Serialize):
    __serialize_fields__ = (
        "terminals",
        "ignore",
        "g_regex_flags",
        "use_bytes",
        "lexer_type",
    )
    __serialize_namespace__ = (TerminalDef,)

    terminals: Collection[TerminalDef]
    re_module: ModuleType
    ignore: Collection[str]
    postlex: "Optional[PostLex]"
    callbacks: Dict[str, _LexerCallback]
    g_regex_flags: int
    skip_validation: bool
    use_bytes: bool
    lexer_type: Optional[_LexerArgType]
    strict: bool

    def __init__(
        self,
        terminals: Collection[TerminalDef],
        re_module: ModuleType,
        ignore: Collection[str] = (),
        postlex: "Optional[PostLex]" = None,
        callbacks: Optional[Dict[str, _LexerCallback]] = None,
        g_regex_flags: int = 0,
        skip_validation: bool = False,
        use_bytes: bool = False,
        strict: bool = False,
    ):
        self.terminals = terminals
        self.terminals_by_name = {t.name: t for t in self.terminals}
        assert len(self.terminals) == len(self.terminals_by_name)
        self.ignore = ignore
        self.postlex = postlex
        self.callbacks = callbacks or {}
        self.g_regex_flags = g_regex_flags
        self.re_module = re_module
        self.skip_validation = skip_validation
        self.use_bytes = use_bytes
        self.strict = strict
        self.lexer_type = None

    def _deserialize(self):
        self.terminals_by_name = {t.name: t for t in self.terminals}

    def __deepcopy__(self, memo=None):
        return type(self)(
            deepcopy(self.terminals, memo),
            self.re_module,
            deepcopy(self.ignore, memo),
            deepcopy(self.postlex, memo),
            deepcopy(self.callbacks, memo),
            deepcopy(self.g_regex_flags, memo),
            deepcopy(self.skip_validation, memo),
            deepcopy(self.use_bytes, memo),
        )


class ParserConf(Serialize):
    __serialize_fields__ = "rules", "start", "parser_type"

    rules: List["Rule"]
    callbacks: ParserCallbacks
    start: List[str]
    parser_type: _ParserArgType

    def __init__(
        self, rules: List["Rule"], callbacks: ParserCallbacks, start: List[str]
    ):
        assert isinstance(start, list)
        self.rules = rules
        self.callbacks = callbacks
        self.start = start



from functools import partial, wraps
from itertools import product


class ExpandSingleChild:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        if len(children) == 1:
            return children[0]
        else:
            return self.node_builder(children)


class PropagatePositions:
    def __init__(self, node_builder, node_filter=None):
        self.node_builder = node_builder
        self.node_filter = node_filter

    def __call__(self, children):
        res = self.node_builder(children)

        if isinstance(res, Tree):
            ##

            ##

            ##

            ##


            res_meta = res.meta

            first_meta = self._pp_get_meta(children)
            if first_meta is not None:
                if not hasattr(res_meta, "line"):
                    ##

                    res_meta.line = getattr(
                        first_meta, "container_line", first_meta.line
                    )
                    res_meta.column = getattr(
                        first_meta, "container_column", first_meta.column
                    )
                    res_meta.start_pos = getattr(
                        first_meta, "container_start_pos", first_meta.start_pos
                    )
                    res_meta.empty = False

                res_meta.container_line = getattr(
                    first_meta, "container_line", first_meta.line
                )
                res_meta.container_column = getattr(
                    first_meta, "container_column", first_meta.column
                )
                res_meta.container_start_pos = getattr(
                    first_meta, "container_start_pos", first_meta.start_pos
                )

            last_meta = self._pp_get_meta(reversed(children))
            if last_meta is not None:
                if not hasattr(res_meta, "end_line"):
                    res_meta.end_line = getattr(
                        last_meta, "container_end_line", last_meta.end_line
                    )
                    res_meta.end_column = getattr(
                        last_meta, "container_end_column", last_meta.end_column
                    )
                    res_meta.end_pos = getattr(
                        last_meta, "container_end_pos", last_meta.end_pos
                    )
                    res_meta.empty = False

                res_meta.container_end_line = getattr(
                    last_meta, "container_end_line", last_meta.end_line
                )
                res_meta.container_end_column = getattr(
                    last_meta, "container_end_column", last_meta.end_column
                )
                res_meta.container_end_pos = getattr(
                    last_meta, "container_end_pos", last_meta.end_pos
                )

        return res

    def _pp_get_meta(self, children):
        for c in children:
            if self.node_filter is not None and not self.node_filter(c):
                continue
            if isinstance(c, Tree):
                if not c.meta.empty:
                    return c.meta
            elif isinstance(c, Token):
                return c
            elif hasattr(c, "__lark_meta__"):
                return c.__lark_meta__()


def make_propagate_positions(option):
    if callable(option):
        return partial(PropagatePositions, node_filter=option)
    elif option is True:
        return PropagatePositions
    elif option is False:
        return None

    raise ConfigurationError("Invalid option for propagate_positions: %r" % option)


class ChildFilter:
    def __init__(self, to_include, append_none, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include
        self.append_none = append_none

    def __call__(self, children):
        filtered = []

        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                filtered += children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR(ChildFilter):
    #--

    def __call__(self, children):
        filtered = []
        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR_NoPlaceholders(ChildFilter):
    #--

    def __init__(self, to_include, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])
        return self.node_builder(filtered)


def _should_expand(sym):
    return not sym.is_term and sym.name.startswith("_")


def maybe_create_child_filter(
    expansion, keep_all_tokens, ambiguous, _empty_indices: List[bool]
):
    ##

    if _empty_indices:
        assert _empty_indices.count(False) == len(expansion)
        s = "".join(str(int(b)) for b in _empty_indices)
        empty_indices = [len(ones) for ones in s.split("0")]
        assert len(empty_indices) == len(expansion) + 1, (empty_indices, len(expansion))
    else:
        empty_indices = [0] * (len(expansion) + 1)

    to_include = []
    nones_to_add = 0
    for i, sym in enumerate(expansion):
        nones_to_add += empty_indices[i]
        if keep_all_tokens or not (sym.is_term and sym.filter_out):
            to_include.append((i, _should_expand(sym), nones_to_add))
            nones_to_add = 0

    nones_to_add += empty_indices[len(expansion)]

    if (
        _empty_indices
        or len(to_include) < len(expansion)
        or any(to_expand for i, to_expand, _ in to_include)
    ):
        if _empty_indices or ambiguous:
            return partial(
                ChildFilter if ambiguous else ChildFilterLALR, to_include, nones_to_add
            )
        else:
            ##

            return partial(
                ChildFilterLALR_NoPlaceholders, [(i, x) for i, x, _ in to_include]
            )


class AmbiguousExpander:
    #--

    def __init__(self, to_expand, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class
        self.to_expand = to_expand

    def __call__(self, children):
        def _is_ambig_tree(t):
            return hasattr(t, "data") and t.data == "_ambig"

        ##

        ##

        ##

        ##

        ambiguous = []
        for i, child in enumerate(children):
            if _is_ambig_tree(child):
                if i in self.to_expand:
                    ambiguous.append(i)

                child.expand_kids_by_data("_ambig")

        if not ambiguous:
            return self.node_builder(children)

        expand = [
            child.children if i in ambiguous else (child,)
            for i, child in enumerate(children)
        ]
        return self.tree_class(
            "_ambig", [self.node_builder(list(f)) for f in product(*expand)]
        )


def maybe_create_ambiguous_expander(tree_class, expansion, keep_all_tokens):
    to_expand = [
        i
        for i, sym in enumerate(expansion)
        if keep_all_tokens
        or ((not (sym.is_term and sym.filter_out)) and _should_expand(sym))
    ]
    if to_expand:
        return partial(AmbiguousExpander, to_expand, tree_class)


class AmbiguousIntermediateExpander:
    #--

    def __init__(self, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class

    def __call__(self, children):
        def _is_iambig_tree(child):
            return hasattr(child, "data") and child.data == "_iambig"

        def _collapse_iambig(children):
            #--

            ##

            ##

            if children and _is_iambig_tree(children[0]):
                iambig_node = children[0]
                result = []
                for grandchild in iambig_node.children:
                    collapsed = _collapse_iambig(grandchild.children)
                    if collapsed:
                        for child in collapsed:
                            child.children += children[1:]
                        result += collapsed
                    else:
                        new_tree = self.tree_class(
                            "_inter", grandchild.children + children[1:]
                        )
                        result.append(new_tree)
                return result

        collapsed = _collapse_iambig(children)
        if collapsed:
            processed_nodes = [self.node_builder(c.children) for c in collapsed]
            return self.tree_class("_ambig", processed_nodes)

        return self.node_builder(children)


def inplace_transformer(func):
    @wraps(func)
    def f(children):
        ##

        tree = Tree(func.__name__, children)
        return func(tree)

    return f


def apply_visit_wrapper(func, name, wrapper):
    if wrapper is _vargs_meta or wrapper is _vargs_meta_inline:
        raise NotImplementedError("Meta args not supported for internal transformer")

    @wraps(func)
    def f(children):
        return wrapper(func, name, children, None)

    return f


class ParseTreeBuilder:
    def __init__(
        self,
        rules,
        tree_class,
        propagate_positions=False,
        ambiguous=False,
        maybe_placeholders=False,
    ):
        self.tree_class = tree_class
        self.propagate_positions = propagate_positions
        self.ambiguous = ambiguous
        self.maybe_placeholders = maybe_placeholders

        self.rule_builders = list(self._init_builders(rules))

    def _init_builders(self, rules):
        propagate_positions = make_propagate_positions(self.propagate_positions)

        for rule in rules:
            options = rule.options
            keep_all_tokens = options.keep_all_tokens
            expand_single_child = options.expand1

            wrapper_chain = list(
                filter(
                    None,
                    [
                        (expand_single_child and not rule.alias) and ExpandSingleChild,
                        maybe_create_child_filter(
                            rule.expansion,
                            keep_all_tokens,
                            self.ambiguous,
                            options.empty_indices if self.maybe_placeholders else None,
                        ),
                        propagate_positions,
                        self.ambiguous
                        and maybe_create_ambiguous_expander(
                            self.tree_class, rule.expansion, keep_all_tokens
                        ),
                        self.ambiguous
                        and partial(AmbiguousIntermediateExpander, self.tree_class),
                    ],
                )
            )

            yield rule, wrapper_chain

    def create_callback(self, transformer=None):
        callbacks = {}

        default_handler = getattr(transformer, "__default__", None)
        if default_handler:

            def default_callback(data, children):
                return default_handler(data, children, None)

        else:
            default_callback = self.tree_class

        for rule, wrapper_chain in self.rule_builders:
            user_callback_name = (
                rule.alias or rule.options.template_source or rule.origin.name
            )
            try:
                f = getattr(transformer, user_callback_name)
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    f = apply_visit_wrapper(f, user_callback_name, wrapper)
                elif isinstance(transformer, Transformer_InPlace):
                    f = inplace_transformer(f)
            except AttributeError:
                f = partial(default_callback, user_callback_name)

            for w in wrapper_chain:
                f = w(f)

            if rule in callbacks:
                raise GrammarError("Rule '%s' already exists" % (rule,))

            callbacks[rule] = f

        return callbacks





class Action:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def __repr__(self):
        return str(self)


Shift = Action("Shift")
Reduce = Action("Reduce")

StateT = TypeVar("StateT")


class ParseTableBase(Generic[StateT]):
    states: Dict[StateT, Dict[str, Tuple]]
    start_states: Dict[str, StateT]
    end_states: Dict[str, StateT]

    def __init__(self, states, start_states, end_states):
        self.states = states
        self.start_states = start_states
        self.end_states = end_states

    def serialize(self, memo):
        tokens = Enumerator()

        states = {
            state: {
                tokens.get(token): (
                    (1, arg.serialize(memo)) if action is Reduce else (0, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in self.states.items()
        }

        return {
            "tokens": tokens.reversed(),
            "states": states,
            "start_states": self.start_states,
            "end_states": self.end_states,
        }

    @classmethod
    def deserialize(cls, data, memo):
        tokens = data["tokens"]
        states = {
            state: {
                tokens[token]: (
                    (Reduce, Rule.deserialize(arg, memo))
                    if action == 1
                    else (Shift, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in data["states"].items()
        }
        return cls(states, data["start_states"], data["end_states"])


class ParseTable(ParseTableBase["State"]):
    #--

    pass


class IntParseTable(ParseTableBase[int]):
    #--

    @classmethod
    def from_ParseTable(cls, parse_table: ParseTable):
        enum = list(parse_table.states)
        state_to_idx: Dict["State", int] = {s: i for i, s in enumerate(enum)}
        int_states = {}

        for s, la in parse_table.states.items():
            la = {
                k: (v[0], state_to_idx[v[1]]) if v[0] is Shift else v
                for k, v in la.items()
            }
            int_states[state_to_idx[s]] = la

        start_states = {
            start: state_to_idx[s] for start, s in parse_table.start_states.items()
        }
        end_states = {
            start: state_to_idx[s] for start, s in parse_table.end_states.items()
        }
        return cls(int_states, start_states, end_states)





class ParseConf(Generic[StateT]):
    __slots__ = (
        "parse_table",
        "callbacks",
        "start",
        "start_state",
        "end_state",
        "states",
    )

    parse_table: ParseTableBase[StateT]
    callbacks: ParserCallbacks
    start: str

    start_state: StateT
    end_state: StateT
    states: Dict[StateT, Dict[str, tuple]]

    def __init__(
        self,
        parse_table: ParseTableBase[StateT],
        callbacks: ParserCallbacks,
        start: str,
    ):
        self.parse_table = parse_table

        self.start_state = self.parse_table.start_states[start]
        self.end_state = self.parse_table.end_states[start]
        self.states = self.parse_table.states

        self.callbacks = callbacks
        self.start = start


class ParserState(Generic[StateT]):
    __slots__ = "parse_conf", "lexer", "state_stack", "value_stack"

    parse_conf: ParseConf[StateT]
    lexer: LexerThread
    state_stack: List[StateT]
    value_stack: list

    def __init__(
        self,
        parse_conf: ParseConf[StateT],
        lexer: LexerThread,
        state_stack=None,
        value_stack=None,
    ):
        self.parse_conf = parse_conf
        self.lexer = lexer
        self.state_stack = state_stack or [self.parse_conf.start_state]
        self.value_stack = value_stack or []

    @property
    def position(self) -> StateT:
        return self.state_stack[-1]

    ##

    def __eq__(self, other) -> bool:
        if not isinstance(other, ParserState):
            return NotImplemented
        return (
            len(self.state_stack) == len(other.state_stack)
            and self.position == other.position
        )

    def __copy__(self):
        return type(self)(
            self.parse_conf,
            self.lexer,  ##

            copy(self.state_stack),
            deepcopy(self.value_stack),
        )

    def copy(self) -> "ParserState[StateT]":
        return copy(self)

    def feed_token(self, token: Token, is_end=False) -> Any:
        state_stack = self.state_stack
        value_stack = self.value_stack
        states = self.parse_conf.states
        end_state = self.parse_conf.end_state
        callbacks = self.parse_conf.callbacks

        while True:
            state = state_stack[-1]
            try:
                action, arg = states[state][token.type]
            except KeyError:
                expected = {s for s in states[state].keys() if s.isupper()}
                raise UnexpectedToken(
                    token, expected, state=self, interactive_parser=None
                )

            assert arg != end_state

            if action is Shift:
                ##

                assert not is_end
                state_stack.append(arg)
                value_stack.append(
                    token
                    if token.type not in callbacks
                    else callbacks[token.type](token)
                )
                return
            else:
                ##

                rule = arg
                size = len(rule.expansion)
                if size:
                    s = value_stack[-size:]
                    del state_stack[-size:]
                    del value_stack[-size:]
                else:
                    s = []

                value = callbacks[rule](s) if callbacks else s

                _action, new_state = states[state_stack[-1]][rule.origin.name]
                assert _action is Shift
                state_stack.append(new_state)
                value_stack.append(value)

                if is_end and state_stack[-1] == end_state:
                    return value_stack[-1]





class LALR_Parser(Serialize):
    def __init__(
        self, parser_conf: ParserConf, debug: bool = False, strict: bool = False
    ):
        analysis = LALR_Analyzer(parser_conf, debug=debug, strict=strict)
        analysis.compute_lalr()
        callbacks = parser_conf.callbacks

        self._parse_table = analysis.parse_table
        self.parser_conf = parser_conf
        self.parser = _Parser(analysis.parse_table, callbacks, debug)

    @classmethod
    def deserialize(cls, data, memo, callbacks, debug=False):
        inst = cls.__new__(cls)
        inst._parse_table = IntParseTable.deserialize(data, memo)
        inst.parser = _Parser(inst._parse_table, callbacks, debug)
        return inst

    def serialize(self, memo: Any = None) -> Dict[str, Any]:
        return self._parse_table.serialize(memo)

    def parse_interactive(self, lexer: LexerThread, start: str):
        return self.parser.parse(lexer, start, start_interactive=True)

    def parse(self, lexer, start, on_error=None):
        try:
            return self.parser.parse(lexer, start)
        except UnexpectedInput as e:
            if on_error is None:
                raise

            while True:
                if isinstance(e, UnexpectedCharacters):
                    s = e.interactive_parser.lexer_thread.state
                    p = s.line_ctr.char_pos

                if not on_error(e):
                    raise e

                if isinstance(e, UnexpectedCharacters):
                    ##

                    if p == s.line_ctr.char_pos:
                        s.line_ctr.feed(s.text[p : p + 1])

                try:
                    return e.interactive_parser.resume_parse()
                except UnexpectedToken as e2:
                    if (
                        isinstance(e, UnexpectedToken)
                        and e.token.type == e2.token.type == "$END"
                        and e.interactive_parser == e2.interactive_parser
                    ):
                        ##

                        raise e2
                    e = e2
                except UnexpectedCharacters as e2:
                    e = e2


class _Parser:
    parse_table: ParseTableBase
    callbacks: ParserCallbacks
    debug: bool

    def __init__(
        self,
        parse_table: ParseTableBase,
        callbacks: ParserCallbacks,
        debug: bool = False,
    ):
        self.parse_table = parse_table
        self.callbacks = callbacks
        self.debug = debug

    def parse(
        self,
        lexer: LexerThread,
        start: str,
        value_stack=None,
        state_stack=None,
        start_interactive=False,
    ):
        parse_conf = ParseConf(self.parse_table, self.callbacks, start)
        parser_state = ParserState(parse_conf, lexer, state_stack, value_stack)
        if start_interactive:
            return InteractiveParser(self, parser_state, parser_state.lexer)
        return self.parse_from_state(parser_state)

    def parse_from_state(self, state: ParserState, last_token: Optional[Token] = None):
        #--
        try:
            token = last_token
            for token in state.lexer.lex(state):
                assert token is not None
                state.feed_token(token)

            end_token = (
                Token.new_borrow_pos("$END", "", token)
                if token
                else Token("$END", "", 0, 1, 1)
            )
            return state.feed_token(end_token, True)
        except UnexpectedInput as e:
            try:
                e.interactive_parser = InteractiveParser(self, state, state.lexer)
            except NameError:
                pass
            raise e
        except Exception as e:
            if self.debug:
                print("")
                print("STATE STACK DUMP")
                print("----------------")
                for i, s in enumerate(state.state_stack):
                    print("%d)" % i, s)
                print("")

            raise





class InteractiveParser:
    #--

    def __init__(self, parser, parser_state, lexer_thread: LexerThread):
        self.parser = parser
        self.parser_state = parser_state
        self.lexer_thread = lexer_thread
        self.result = None

    @property
    def lexer_state(self) -> LexerThread:
        warnings.warn(
            "lexer_state will be removed in subsequent releases. Use lexer_thread instead.",
            DeprecationWarning,
        )
        return self.lexer_thread

    def feed_token(self, token: Token):
        #--
        return self.parser_state.feed_token(token, token.type == "$END")

    def iter_parse(self) -> Iterator[Token]:
        #--
        for token in self.lexer_thread.lex(self.parser_state):
            yield token
            self.result = self.feed_token(token)

    def exhaust_lexer(self) -> List[Token]:
        #--
        return list(self.iter_parse())

    def feed_eof(self, last_token=None):
        #--
        eof = (
            Token.new_borrow_pos("$END", "", last_token)
            if last_token is not None
            else self.lexer_thread._Token("$END", "", 0, 1, 1)
        )
        return self.feed_token(eof)

    def __copy__(self):
        #--
        return type(self)(
            self.parser,
            copy(self.parser_state),
            copy(self.lexer_thread),
        )

    def copy(self):
        return copy(self)

    def __eq__(self, other):
        if not isinstance(other, InteractiveParser):
            return False

        return (
            self.parser_state == other.parser_state
            and self.lexer_thread == other.lexer_thread
        )

    def as_immutable(self):
        #--
        p = copy(self)
        return ImmutableInteractiveParser(p.parser, p.parser_state, p.lexer_thread)

    def pretty(self):
        #--
        out = ["Parser choices:"]
        for k, v in self.choices().items():
            out.append("\t- %s -> %r" % (k, v))
        out.append("stack size: %s" % len(self.parser_state.state_stack))
        return "\n".join(out)

    def choices(self):
        #--
        return self.parser_state.parse_conf.parse_table.states[
            self.parser_state.position
        ]

    def accepts(self):
        #--
        accepts = set()
        conf_no_callbacks = copy(self.parser_state.parse_conf)
        ##

        ##

        conf_no_callbacks.callbacks = {}
        for t in self.choices():
            if t.isupper():  ##

                new_cursor = copy(self)
                new_cursor.parser_state.parse_conf = conf_no_callbacks
                try:
                    new_cursor.feed_token(self.lexer_thread._Token(t, ""))
                except UnexpectedToken:
                    pass
                else:
                    accepts.add(t)
        return accepts

    def resume_parse(self):
        #--
        return self.parser.parse_from_state(
            self.parser_state, last_token=self.lexer_thread.state.last_token
        )


class ImmutableInteractiveParser(InteractiveParser):
    #--

    result = None

    def __hash__(self):
        return hash((self.parser_state, self.lexer_thread))

    def feed_token(self, token):
        c = copy(self)
        c.result = InteractiveParser.feed_token(c, token)
        return c

    def exhaust_lexer(self):
        #--
        cursor = self.as_mutable()
        cursor.exhaust_lexer()
        return cursor.as_immutable()

    def as_mutable(self):
        #--
        p = copy(self)
        return InteractiveParser(p.parser, p.parser_state, p.lexer_thread)





def _wrap_lexer(lexer_class):
    future_interface = getattr(lexer_class, "__future_interface__", False)
    if future_interface:
        return lexer_class
    else:

        class CustomLexerWrapper(Lexer):
            def __init__(self, lexer_conf):
                self.lexer = lexer_class(lexer_conf)

            def lex(self, lexer_state, parser_state):
                return self.lexer.lex(lexer_state.text)

        return CustomLexerWrapper


def _deserialize_parsing_frontend(data, memo, lexer_conf, callbacks, options):
    parser_conf = ParserConf.deserialize(data["parser_conf"], memo)
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    parser = cls.deserialize(data["parser"], memo, callbacks, options.debug)
    parser_conf.callbacks = callbacks
    return ParsingFrontend(lexer_conf, parser_conf, options, parser=parser)


_parser_creators: "Dict[str, Callable[[LexerConf, Any, Any], Any]]" = {}


class ParsingFrontend(Serialize):
    __serialize_fields__ = "lexer_conf", "parser_conf", "parser"

    lexer_conf: LexerConf
    parser_conf: ParserConf
    options: Any

    def __init__(
        self, lexer_conf: LexerConf, parser_conf: ParserConf, options, parser=None
    ):
        self.parser_conf = parser_conf
        self.lexer_conf = lexer_conf
        self.options = options

        ##

        if parser:  ##

            self.parser = parser
        else:
            create_parser = _parser_creators.get(parser_conf.parser_type)
            assert (
                create_parser is not None
            ), "{} is not supported in standalone mode".format(parser_conf.parser_type)
            self.parser = create_parser(lexer_conf, parser_conf, options)

        ##

        lexer_type = lexer_conf.lexer_type
        self.skip_lexer = False
        if lexer_type in ("dynamic", "dynamic_complete"):
            assert lexer_conf.postlex is None
            self.skip_lexer = True
            return

        if isinstance(lexer_type, type):
            assert issubclass(lexer_type, Lexer)
            self.lexer = _wrap_lexer(lexer_type)(lexer_conf)
        elif isinstance(lexer_type, str):
            create_lexer = {
                "basic": create_basic_lexer,
                "contextual": create_contextual_lexer,
            }[lexer_type]
            self.lexer = create_lexer(
                lexer_conf, self.parser, lexer_conf.postlex, options
            )
        else:
            raise TypeError("Bad value for lexer_type: {lexer_type}")

        if lexer_conf.postlex:
            self.lexer = PostLexConnector(self.lexer, lexer_conf.postlex)

    def _verify_start(self, start=None):
        if start is None:
            start_decls = self.parser_conf.start
            if len(start_decls) > 1:
                raise ConfigurationError(
                    "Lark initialized with more than 1 possible start rule. Must specify which start rule to parse",
                    start_decls,
                )
            (start,) = start_decls
        elif start not in self.parser_conf.start:
            raise ConfigurationError(
                "Unknown start rule %s. Must be one of %r"
                % (start, self.parser_conf.start)
            )
        return start

    def _make_lexer_thread(self, text: str) -> Union[str, LexerThread]:
        cls = (self.options and self.options._plugins.get("LexerThread")) or LexerThread
        return text if self.skip_lexer else cls.from_text(self.lexer, text)

    def parse(self, text: str, start=None, on_error=None):
        chosen_start = self._verify_start(start)
        kw = {} if on_error is None else {"on_error": on_error}
        stream = self._make_lexer_thread(text)
        return self.parser.parse(stream, chosen_start, **kw)

    def parse_interactive(self, text: Optional[str] = None, start=None):
        ##

        ##

        chosen_start = self._verify_start(start)
        if self.parser_conf.parser_type != "lalr":
            raise ConfigurationError(
                "parse_interactive() currently only works with parser='lalr' "
            )
        stream = self._make_lexer_thread(text)  ##

        return self.parser.parse_interactive(stream, chosen_start)


def _validate_frontend_args(parser, lexer) -> None:
    assert_config(parser, ("lalr", "earley", "cyk"))
    if not isinstance(lexer, type):  ##

        expected = {
            "lalr": ("basic", "contextual"),
            "earley": ("basic", "dynamic", "dynamic_complete"),
            "cyk": ("basic",),
        }[parser]
        assert_config(
            lexer,
            expected,
            "Parser %r does not support lexer %%r, expected one of %%s" % parser,
        )


def _get_lexer_callbacks(transformer, terminals):
    result = {}
    for terminal in terminals:
        callback = getattr(transformer, terminal.name, None)
        if callback is not None:
            result[terminal.name] = callback
    return result


class PostLexConnector:
    def __init__(self, lexer, postlexer):
        self.lexer = lexer
        self.postlexer = postlexer

    def lex(self, lexer_state, parser_state):
        i = self.lexer.lex(lexer_state, parser_state)
        return self.postlexer.process(i)


def create_basic_lexer(lexer_conf, parser, postlex, options) -> BasicLexer:
    cls = (options and options._plugins.get("BasicLexer")) or BasicLexer
    return cls(lexer_conf)


def create_contextual_lexer(
    lexer_conf: LexerConf, parser, postlex, options
) -> ContextualLexer:
    cls = (options and options._plugins.get("ContextualLexer")) or ContextualLexer
    parse_table: ParseTableBase[int] = parser._parse_table
    states: Dict[int, Collection[str]] = {
        idx: list(t.keys()) for idx, t in parse_table.states.items()
    }
    always_accept: Collection[str] = postlex.always_accept if postlex else ()
    return cls(lexer_conf, states, always_accept=always_accept)


def create_lalr_parser(
    lexer_conf: LexerConf, parser_conf: ParserConf, options=None
) -> LALR_Parser:
    debug = options.debug if options else False
    strict = options.strict if options else False
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    return cls(parser_conf, debug=debug, strict=strict)


_parser_creators["lalr"] = create_lalr_parser




class PostLex(ABC):
    @abstractmethod
    def process(self, stream: Iterator[Token]) -> Iterator[Token]:
        return stream

    always_accept: Iterable[str] = ()


class LarkOptions(Serialize):
    #--

    start: List[str]
    debug: bool
    strict: bool
    transformer: "Optional[Transformer]"
    propagate_positions: Union[bool, str]
    maybe_placeholders: bool
    cache: Union[bool, str]
    regex: bool
    g_regex_flags: int
    keep_all_tokens: bool
    tree_class: Optional[Callable[[str, List], Any]]
    parser: _ParserArgType
    lexer: _LexerArgType
    ambiguity: 'Literal["auto", "resolve", "explicit", "forest"]'
    postlex: Optional[PostLex]
    priority: 'Optional[Literal["auto", "normal", "invert"]]'
    lexer_callbacks: Dict[str, Callable[[Token], Token]]
    use_bytes: bool
    ordered_sets: bool
    edit_terminals: Optional[Callable[[TerminalDef], TerminalDef]]
    import_paths: "List[Union[str, Callable[[Union[None, str, PackageResource], str], Tuple[str, str]]]]"
    source_path: Optional[str]

    OPTIONS_DOC = r"""
    **===  General Options  ===**

    start
            The start symbol. Either a string, or a list of strings for multiple possible starts (Default: "start")
    debug
            Display debug information and extra warnings. Use only when debugging (Default: ``False``)
            When used with Earley, it generates a forest graph as "sppf.png", if 'dot' is installed.
    strict
            Throw an exception on any potential ambiguity, including shift/reduce conflicts, and regex collisions.
    transformer
            Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)
    propagate_positions
            Propagates positional attributes into the 'meta' attribute of all tree branches.
            Sets attributes: (line, column, end_line, end_column, start_pos, end_pos,
                              container_line, container_column, container_end_line, container_end_column)
            Accepts ``False``, ``True``, or a callable, which will filter which nodes to ignore when propagating.
    maybe_placeholders
            When ``True``, the ``[]`` operator returns ``None`` when not matched.
            When ``False``,  ``[]`` behaves like the ``?`` operator, and returns no value at all.
            (default= ``True``)
    cache
            Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.

            - When ``False``, does nothing (default)
            - When ``True``, caches to a temporary file in the local directory
            - When given a string, caches to the path pointed by the string
    regex
            When True, uses the ``regex`` module instead of the stdlib ``re``.
    g_regex_flags
            Flags that are applied to all terminals (both regex and strings)
    keep_all_tokens
            Prevent the tree builder from automagically removing "punctuation" tokens (Default: ``False``)
    tree_class
            Lark will produce trees comprised of instances of this class instead of the default ``lark.Tree``.

    **=== Algorithm Options ===**

    parser
            Decides which parser engine to use. Accepts "earley" or "lalr". (Default: "earley").
            (there is also a "cyk" option for legacy)
    lexer
            Decides whether or not to use a lexer stage

            - "auto" (default): Choose for me based on the parser
            - "basic": Use a basic lexer
            - "contextual": Stronger lexer (only works with parser="lalr")
            - "dynamic": Flexible and powerful (only with parser="earley")
            - "dynamic_complete": Same as dynamic, but tries *every* variation of tokenizing possible.
    ambiguity
            Decides how to handle ambiguity in the parse. Only relevant if parser="earley"

            - "resolve": The parser will automatically choose the simplest derivation
              (it chooses consistently: greedy for tokens, non-greedy for rules)
            - "explicit": The parser will return all derivations wrapped in "_ambig" tree nodes (i.e. a forest).
            - "forest": The parser will return the root of the shared packed parse forest.

    **=== Misc. / Domain Specific Options ===**

    postlex
            Lexer post-processing (Default: ``None``) Only works with the basic and contextual lexers.
    priority
            How priorities should be evaluated - "auto", ``None``, "normal", "invert" (Default: "auto")
    lexer_callbacks
            Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.
    use_bytes
            Accept an input of type ``bytes`` instead of ``str``.
    ordered_sets
            Should Earley use ordered-sets to achieve stable output (~10% slower than regular sets. Default: True)
    edit_terminals
            A callback for editing the terminals before parse.
    import_paths
            A List of either paths or loader functions to specify from where grammars are imported
    source_path
            Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading
    **=== End of Options ===**
    """
    if __doc__:
        __doc__ += OPTIONS_DOC

    ##

    ##

    ##

    ##

    ##

    ##

    _defaults: Dict[str, Any] = {
        "debug": False,
        "strict": False,
        "keep_all_tokens": False,
        "tree_class": None,
        "cache": False,
        "postlex": None,
        "parser": "earley",
        "lexer": "auto",
        "transformer": None,
        "start": "start",
        "priority": "auto",
        "ambiguity": "auto",
        "regex": False,
        "propagate_positions": False,
        "lexer_callbacks": {},
        "maybe_placeholders": True,
        "edit_terminals": None,
        "g_regex_flags": 0,
        "use_bytes": False,
        "ordered_sets": True,
        "import_paths": [],
        "source_path": None,
        "_plugins": {},
    }

    def __init__(self, options_dict: Dict[str, Any]) -> None:
        o = dict(options_dict)

        options = {}
        for name, default in self._defaults.items():
            if name in o:
                value = o.pop(name)
                if isinstance(default, bool) and name not in (
                    "cache",
                    "use_bytes",
                    "propagate_positions",
                ):
                    value = bool(value)
            else:
                value = default

            options[name] = value

        if isinstance(options["start"], str):
            options["start"] = [options["start"]]

        self.__dict__["options"] = options

        assert_config(self.parser, ("earley", "lalr", "cyk", None))

        if self.parser == "earley" and self.transformer:
            raise ConfigurationError(
                "Cannot specify an embedded transformer when using the Earley algorithm. "
                "Please use your transformer on the resulting parse tree, or use a different algorithm (i.e. LALR)"
            )

        if o:
            raise ConfigurationError("Unknown options: %s" % o.keys())

    def __getattr__(self, name: str) -> Any:
        try:
            return self.__dict__["options"][name]
        except KeyError as e:
            raise AttributeError(e)

    def __setattr__(self, name: str, value: str) -> None:
        assert_config(
            name, self.options.keys(), "%r isn't a valid option. Expected one of: %s"
        )
        self.options[name] = value

    def serialize(self, memo=None) -> Dict[str, Any]:
        return self.options

    @classmethod
    def deserialize(
        cls, data: Dict[str, Any], memo: Dict[int, Union[TerminalDef, Rule]]
    ) -> "LarkOptions":
        return cls(data)


##

##

_LOAD_ALLOWED_OPTIONS = {
    "postlex",
    "transformer",
    "lexer_callbacks",
    "use_bytes",
    "debug",
    "g_regex_flags",
    "regex",
    "propagate_positions",
    "tree_class",
    "_plugins",
}

_VALID_PRIORITY_OPTIONS = ("auto", "normal", "invert", None)
_VALID_AMBIGUITY_OPTIONS = ("auto", "resolve", "explicit", "forest")


_T = TypeVar("_T", bound="Lark")


class Lark(Serialize):
    #--

    source_path: str
    source_grammar: str
    grammar: "Grammar"
    options: LarkOptions
    lexer: Lexer
    parser: "ParsingFrontend"
    terminals: Collection[TerminalDef]

    def __init__(self, grammar: "Union[Grammar, str, IO[str]]", **options) -> None:
        self.options = LarkOptions(options)
        re_module: types.ModuleType

        ##

        use_regex = self.options.regex
        if use_regex:
            if _has_regex:
                re_module = regex
            else:
                raise ImportError(
                    "`regex` module must be installed if calling `Lark(regex=True)`."
                )
        else:
            re_module = re

        ##

        if self.options.source_path is None:
            try:
                self.source_path = grammar.name  ##

            except AttributeError:
                self.source_path = "<string>"
        else:
            self.source_path = self.options.source_path

        ##

        try:
            read = grammar.read  ##

        except AttributeError:
            pass
        else:
            grammar = read()

        cache_fn = None
        cache_sha256 = None
        if isinstance(grammar, str):
            self.source_grammar = grammar
            if self.options.use_bytes:
                if not isascii(grammar):
                    raise ConfigurationError(
                        "Grammar must be ascii only, when use_bytes=True"
                    )

            if self.options.cache:
                if self.options.parser != "lalr":
                    raise ConfigurationError(
                        "cache only works with parser='lalr' for now"
                    )

                unhashable = (
                    "transformer",
                    "postlex",
                    "lexer_callbacks",
                    "edit_terminals",
                    "_plugins",
                )
                options_str = "".join(
                    k + str(v) for k, v in options.items() if k not in unhashable
                )
                from . import __version__

                s = grammar + options_str + __version__ + str(sys.version_info[:2])
                cache_sha256 = sha256_digest(s)

                if isinstance(self.options.cache, str):
                    cache_fn = self.options.cache
                else:
                    if self.options.cache is not True:
                        raise ConfigurationError("cache argument must be bool or str")

                    try:
                        username = getpass.getuser()
                    except Exception:
                        ##

                        ##

                        ##

                        username = "unknown"

                    cache_fn = (
                        tempfile.gettempdir()
                        + "/.lark_cache_%s_%s_%s_%s.tmp"
                        % (username, cache_sha256, *sys.version_info[:2])
                    )

                old_options = self.options
                try:
                    with FS.open(cache_fn, "rb") as f:
                        logger.debug("Loading grammar from cache: %s", cache_fn)
                        ##

                        for name in set(options) - _LOAD_ALLOWED_OPTIONS:
                            del options[name]
                        file_sha256 = f.readline().rstrip(b"\n")
                        cached_used_files = pickle.load(f)
                        if file_sha256 == cache_sha256.encode(
                            "utf8"
                        ) and verify_used_files(cached_used_files):
                            cached_parser_data = pickle.load(f)
                            self._load(cached_parser_data, **options)
                            return
                except FileNotFoundError:
                    ##

                    pass
                except (
                    Exception
                ):  ##

                    logger.exception(
                        "Failed to load Lark from cache: %r. We will try to carry on.",
                        cache_fn,
                    )

                    ##

                    ##

                    self.options = old_options

            ##

            self.grammar, used_files = load_grammar(
                grammar,
                self.source_path,
                self.options.import_paths,
                self.options.keep_all_tokens,
            )
        else:
            assert isinstance(grammar, Grammar)
            self.grammar = grammar

        if self.options.lexer == "auto":
            if self.options.parser == "lalr":
                self.options.lexer = "contextual"
            elif self.options.parser == "earley":
                if self.options.postlex is not None:
                    logger.info(
                        "postlex can't be used with the dynamic lexer, so we use 'basic' instead. "
                        "Consider using lalr with contextual instead of earley"
                    )
                    self.options.lexer = "basic"
                else:
                    self.options.lexer = "dynamic"
            elif self.options.parser == "cyk":
                self.options.lexer = "basic"
            else:
                assert False, self.options.parser
        lexer = self.options.lexer
        if isinstance(lexer, type):
            assert issubclass(
                lexer, Lexer
            )  ##

        else:
            assert_config(lexer, ("basic", "contextual", "dynamic", "dynamic_complete"))
            if self.options.postlex is not None and "dynamic" in lexer:
                raise ConfigurationError(
                    "Can't use postlex with a dynamic lexer. Use basic or contextual instead"
                )

        if self.options.ambiguity == "auto":
            if self.options.parser == "earley":
                self.options.ambiguity = "resolve"
        else:
            assert_config(
                self.options.parser,
                ("earley", "cyk"),
                "%r doesn't support disambiguation. Use one of these parsers instead: %s",
            )

        if self.options.priority == "auto":
            self.options.priority = "normal"

        if self.options.priority not in _VALID_PRIORITY_OPTIONS:
            raise ConfigurationError(
                "invalid priority option: %r. Must be one of %r"
                % (self.options.priority, _VALID_PRIORITY_OPTIONS)
            )
        if self.options.ambiguity not in _VALID_AMBIGUITY_OPTIONS:
            raise ConfigurationError(
                "invalid ambiguity option: %r. Must be one of %r"
                % (self.options.ambiguity, _VALID_AMBIGUITY_OPTIONS)
            )

        if self.options.parser is None:
            terminals_to_keep = "*"
        elif self.options.postlex is not None:
            terminals_to_keep = set(self.options.postlex.always_accept)
        else:
            terminals_to_keep = set()

        ##

        self.terminals, self.rules, self.ignore_tokens = self.grammar.compile(
            self.options.start, terminals_to_keep
        )

        if self.options.edit_terminals:
            for t in self.terminals:
                self.options.edit_terminals(t)

        self._terminals_dict = {t.name: t for t in self.terminals}

        ##

        if self.options.priority == "invert":
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = -rule.options.priority
            for term in self.terminals:
                term.priority = -term.priority
        ##

        ##

        ##

        elif self.options.priority is None:
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = None
            for term in self.terminals:
                term.priority = 0

        ##

        self.lexer_conf = LexerConf(
            self.terminals,
            re_module,
            self.ignore_tokens,
            self.options.postlex,
            self.options.lexer_callbacks,
            self.options.g_regex_flags,
            use_bytes=self.options.use_bytes,
            strict=self.options.strict,
        )

        if self.options.parser:
            self.parser = self._build_parser()
        elif lexer:
            self.lexer = self._build_lexer()

        if cache_fn:
            logger.debug("Saving grammar to cache: %s", cache_fn)
            try:
                with FS.open(cache_fn, "wb") as f:
                    assert cache_sha256 is not None
                    f.write(cache_sha256.encode("utf8") + b"\n")
                    pickle.dump(used_files, f)
                    self.save(f, _LOAD_ALLOWED_OPTIONS)
            except IOError as e:
                logger.exception("Failed to save Lark to cache: %r.", cache_fn, e)

    if __doc__:
        __doc__ += "\n\n" + LarkOptions.OPTIONS_DOC

    __serialize_fields__ = "parser", "rules", "options"

    def _build_lexer(self, dont_ignore: bool = False) -> BasicLexer:
        lexer_conf = self.lexer_conf
        if dont_ignore:
            from copy import copy

            lexer_conf = copy(lexer_conf)
            lexer_conf.ignore = ()
        return BasicLexer(lexer_conf)

    def _prepare_callbacks(self) -> None:
        self._callbacks = {}
        ##

        if self.options.ambiguity != "forest":
            self._parse_tree_builder = ParseTreeBuilder(
                self.rules,
                self.options.tree_class or Tree,
                self.options.propagate_positions,
                self.options.parser != "lalr" and self.options.ambiguity == "explicit",
                self.options.maybe_placeholders,
            )
            self._callbacks = self._parse_tree_builder.create_callback(
                self.options.transformer
            )
        self._callbacks.update(
            _get_lexer_callbacks(self.options.transformer, self.terminals)
        )

    def _build_parser(self) -> "ParsingFrontend":
        self._prepare_callbacks()
        _validate_frontend_args(self.options.parser, self.options.lexer)
        parser_conf = ParserConf(self.rules, self._callbacks, self.options.start)
        return _construct_parsing_frontend(
            self.options.parser,
            self.options.lexer,
            self.lexer_conf,
            parser_conf,
            options=self.options,
        )

    def save(self, f, exclude_options: Collection[str] = ()) -> None:
        #--
        if self.options.parser != "lalr":
            raise NotImplementedError(
                "Lark.save() is only implemented for the LALR(1) parser."
            )
        data, m = self.memo_serialize([TerminalDef, Rule])
        if exclude_options:
            data["options"] = {
                n: v for n, v in data["options"].items() if n not in exclude_options
            }
        pickle.dump({"data": data, "memo": m}, f, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls: Type[_T], f) -> _T:
        #--
        inst = cls.__new__(cls)
        return inst._load(f)

    def _deserialize_lexer_conf(
        self,
        data: Dict[str, Any],
        memo: Dict[int, Union[TerminalDef, Rule]],
        options: LarkOptions,
    ) -> LexerConf:
        lexer_conf = LexerConf.deserialize(data["lexer_conf"], memo)
        lexer_conf.callbacks = options.lexer_callbacks or {}
        lexer_conf.re_module = regex if options.regex else re
        lexer_conf.use_bytes = options.use_bytes
        lexer_conf.g_regex_flags = options.g_regex_flags
        lexer_conf.skip_validation = True
        lexer_conf.postlex = options.postlex
        return lexer_conf

    def _load(self: _T, f: Any, **kwargs) -> _T:
        if isinstance(f, dict):
            d = f
        else:
            d = pickle.load(f)
        memo_json = d["memo"]
        data = d["data"]

        assert memo_json
        memo = SerializeMemoizer.deserialize(
            memo_json, {"Rule": Rule, "TerminalDef": TerminalDef}, {}
        )
        options = dict(data["options"])
        if (set(kwargs) - _LOAD_ALLOWED_OPTIONS) & set(LarkOptions._defaults):
            raise ConfigurationError(
                "Some options are not allowed when loading a Parser: {}".format(
                    set(kwargs) - _LOAD_ALLOWED_OPTIONS
                )
            )
        options.update(kwargs)
        self.options = LarkOptions.deserialize(options, memo)
        self.rules = [Rule.deserialize(r, memo) for r in data["rules"]]
        self.source_path = "<deserialized>"
        _validate_frontend_args(self.options.parser, self.options.lexer)
        self.lexer_conf = self._deserialize_lexer_conf(
            data["parser"], memo, self.options
        )
        self.terminals = self.lexer_conf.terminals
        self._prepare_callbacks()
        self._terminals_dict = {t.name: t for t in self.terminals}
        self.parser = _deserialize_parsing_frontend(
            data["parser"],
            memo,
            self.lexer_conf,
            self._callbacks,
            self.options,  ##

        )
        return self

    @classmethod
    def _load_from_dict(cls, data, memo, **kwargs):
        inst = cls.__new__(cls)
        return inst._load({"data": data, "memo": memo}, **kwargs)

    @classmethod
    def open(
        cls: Type[_T], grammar_filename: str, rel_to: Optional[str] = None, **options
    ) -> _T:
        #--
        if rel_to:
            basepath = os.path.dirname(rel_to)
            grammar_filename = os.path.join(basepath, grammar_filename)
        with open(grammar_filename, encoding="utf8") as f:
            return cls(f, **options)

    @classmethod
    def open_from_package(
        cls: Type[_T],
        package: str,
        grammar_path: str,
        search_paths: "Sequence[str]" = [""],
        **options
    ) -> _T:
        #--
        package_loader = FromPackageLoader(package, search_paths)
        full_path, text = package_loader(None, grammar_path)
        options.setdefault("source_path", full_path)
        options.setdefault("import_paths", [])
        options["import_paths"].append(package_loader)
        return cls(text, **options)

    def __repr__(self):
        return "Lark(open(%r), parser=%r, lexer=%r, ...)" % (
            self.source_path,
            self.options.parser,
            self.options.lexer,
        )

    def lex(self, text: str, dont_ignore: bool = False) -> Iterator[Token]:
        #--
        lexer: Lexer
        if not hasattr(self, "lexer") or dont_ignore:
            lexer = self._build_lexer(dont_ignore)
        else:
            lexer = self.lexer
        lexer_thread = LexerThread.from_text(lexer, text)
        stream = lexer_thread.lex(None)
        if self.options.postlex:
            return self.options.postlex.process(stream)
        return stream

    def get_terminal(self, name: str) -> TerminalDef:
        #--
        return self._terminals_dict[name]

    def parse_interactive(
        self, text: Optional[str] = None, start: Optional[str] = None
    ) -> "InteractiveParser":
        #--
        return self.parser.parse_interactive(text, start=start)

    def parse(
        self,
        text: str,
        start: Optional[str] = None,
        on_error: "Optional[Callable[[UnexpectedInput], bool]]" = None,
    ) -> "ParseTree":
        #--
        return self.parser.parse(text, start=start, on_error=on_error)





class DedentError(LarkError):
    pass


class Indenter(PostLex, ABC):
    paren_level: int
    indent_level: List[int]

    def __init__(self) -> None:
        self.paren_level = 0
        self.indent_level = [0]
        assert self.tab_len > 0

    def handle_NL(self, token: Token) -> Iterator[Token]:
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit("\n", 1)[1]  ##

        indent = indent_str.count(" ") + indent_str.count("\t") * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            if indent != self.indent_level[-1]:
                raise DedentError(
                    "Unexpected dedent to column %s. Expected dedent to %s"
                    % (indent, self.indent_level[-1])
                )

    def _process(self, stream):
        for token in stream:
            if token.type == self.NL_type:
                yield from self.handle_NL(token)
            else:
                yield token

            if token.type in self.OPEN_PAREN_types:
                self.paren_level += 1
            elif token.type in self.CLOSE_PAREN_types:
                self.paren_level -= 1
                assert self.paren_level >= 0

        while len(self.indent_level) > 1:
            self.indent_level.pop()
            yield Token(self.DEDENT_type, "")

        assert self.indent_level == [0], self.indent_level

    def process(self, stream):
        self.paren_level = 0
        self.indent_level = [0]
        return self._process(stream)

    ##

    @property
    def always_accept(self):
        return (self.NL_type,)

    @property
    @abstractmethod
    def NL_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def OPEN_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def CLOSE_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def INDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def DEDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def tab_len(self) -> int:
        raise NotImplementedError()


class PythonIndenter(Indenter):
    NL_type = "_NEWLINE"
    OPEN_PAREN_types = ["LPAR", "LSQB", "LBRACE"]
    CLOSE_PAREN_types = ["RPAR", "RSQB", "RBRACE"]
    INDENT_type = "_INDENT"
    DEDENT_type = "_DEDENT"
    tab_len = 8



import pickle, zlib, base64
DATA = (
b'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HmgtdC80AZoI3QdFoPuhSdAD0B5oMhSH1kHHoQehi1AxdCt0BnoYWg41QyshN7QKWg2dg7qgdOgRKBO6BJ2AHoUC0H7oAHQSaoFCUAf0GHQKqoZqoN1QLtQI7YUOQmOgx6FxUB4Uhi5DT0KF0DFoH9QGHYJOQxtNxawy8+CLXs4kXArkhlKhNKgXlA71hjxQBuSF+kB9oUyoH9QfGgANhHxQFpQNDYJyoMHQEGgolAsNg4ZDI6CR0ChoNDQGGguNg/Kg8dAEaCKUD02CJkNToKlQATQNKoSmQ0VQMXQJCkDVUBCaAc2EZkGzoTnQXGgeNB8qgRZApdBCaBFUBpVDi6El0FLID1VAy6BKqApaDllQCKqBaqE6KAzVQw3QCmgN1Ao1QWuhCLQOaoZWQqug1VAL1Ag9ZSpmlf/v/zpZ955XuTe6r7xtz13YPSbA/xY/ifr/7w+g/mV+Tewv/SNii9U3vNT6+CrGVq+qSmGJWSl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4USl4VaWw1GyLC535tzPQRSgGrYSaITe0CkqDzkFdUDrUDmVCl6AM6AS0GdoPHYBOQlnQcagDyoFOQbuhYVAutBM6DDVCe6GD0FnoAnQUOg9tgvKgcdAEaCIUgSZBe6A4VAgdg/ZBbdAh6DS0ESo2FbP85izzi5iVeRGzzC9ilvlFzDK/iFmZFzHL/CIqoRdVJVRhPuozeNRn8KjP4FGfwaM+g0d9Bo/6DB71GfWoy/R38K2fGD1UP/U+VKrvjzuXWV807spBzKr62xzpKgvbdHmVtw95fROHvP5fPdJVHoobx+Dj7UNe3+Ih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pSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSOopSPpWnrxZ+lawsz3uAJrTQXWvQqs1hVY2yqwtlVgbavA2laBdbYCa2kF1tIKVIUVWFkrsEJWoFaowNpdkV4ha54d7nx2uPNzfbhTHdM0yztR/mSnPD8Dhzs9ei3ufz8fm37z0xt7S/Al+7H3tx/7w/tx1mB/+pe/lvrlTvVkUs/Qucm/wlL18bpsfryJNM/mx+chN35ISmRD4SfIgp8kAjKv+E+8Leyn+9If95L/2V7qP8Ur/GM3nP35Hd/+cV7Y/019s7Wf9ZX907yiX1eX/bUmeTlXXfH3RupltibpPzCnX376rNQ7X9R/wn3Vn9xOPXuL5Cc3Sn9yX3Rx0/PMvcbTt1//Y9Pjf8qfq89lb1qeef08uSly9q7lqVvvOj/yqkNEOc7J8rWhbtV+0Ix7jKvbNd+RtwvXF6pHbabMXZGnmXE74+zdtTNPzMyT7uNPqMyNizN36HZeSD6YoR6o+7TXmuQ9jJ88l7L34X7K7YqvJh8sM+Mm2+qW3L9lfpxuITzRsjcpztxbO/lMSj46rx7NUo++aZL32daLUnd1Tteaj++4HUk+GDHjftqP75GtL1If2a1+h/nqUYtJPHkydyfWF6tPTVR/h8yJ3eupDF867myHHjOrT7yJmXUAM5AAZiABzEACmIEEMAMJYAYSwAwkgBlIADOQAGYgAcxAApiBBDADCWAGEsAMJIAZSAAzkABmIAHMQAKYgQQwAwlgBhLADCSAGUgAM5AAZiABzEACmIEEMAMJYAYSwAwkgBlIADOQAGYgAcxAApiBBDADCWAGEsAMJIAZSAAzkABmIAHMQAKYgQQw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arrxxHHjYE5qE2SFMqE+KAu6Cl2DciAHpEM7oSDUD12H2qEb0E2oA7oF3YZKoL3QbqgTOgrdgcqgEHQXqoTuQc2QBWqBWiEfdB+yQQ+g41AXFIFOQLVQHrQZ2gcdgvKhAagBegt6CD2CSqEj0H5oK3RYyqv1Pamqqq6roupqIuBWxwPyOav42/fieZWUJuXVruEmoOrmn/ctvqd3A1U3Af3Ss94EVH/yKtHkB7+PH2lS66Cp0BKoAZoOuaW8Wj9OHx29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QB29QD3ZC7yODpMLh6wLKYUL6bcLKYULCbALKYULKYULRYMLaZgLp4ULiZcLibMLB7cLyYcLaZgLqZYLiawLKagLaYoLKbYL6akLJYsLCakLSZkLKagL6bcL5UVSJigMeSErdBbaBmVCO6BzUB+UBeVADmgn5IcuQKegM1AQ2g5dh25ALqgIugndgoqh29BeaDd0FLoDXYLKoMtQCLoHWaDTkA9Kh+5DNugYVA0dgA5Cx6FdUAQ6AdVCddAeKA/aBx2C8qEBqAAqhB5Cj6BS6Ai0H9oKHYZOQuelvNoNmdNW/bX410/CK9Ek0SxhkbBKtEiclvBJbJM4JrFD4oHEAYmDEscldknkSOyRcEjslPBLbJbYJ3FI4pREUOKMxHaJAgmXRIdEscReid0S+yWOSByV2CpxWOKkRI+AV7uJSmi2RQaNpC5BXqgZaoIsUAtkhU5DPigd2gbZoCtQJnQM2gEdgA5Cx6Es6Ci0C8qBTkB7IAeUB+2E/NBmaB90CDoFXYCC0BloO1QIFUAuqAjqgIqhvdBuqBQ6Au2HtkKHoZNQ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wgWQmAWQ0AWQmAWQNgWQNgWQNgWQNgWQNgWQNgWQNgWQNgWQNgWQNgWQNgWQNgWQNgWQNgWQNgWQNgWQNgWQNgWQNgWQNgWQGgWQGgWQGgWQGgWQGgWQ8ASQ8ASQmAWQmAWQUgWQUgWQUgWSaZMdzcYf4a/5I/xAfoR/uB8lvz33/dZBZqkPDVo+0mJIYp9jgwUrIioF+q7F91F3RT6BDZH4Xz3+qFX9Hh91V6TqavzBcsvHtDSi5ahHmcnd6uezPmK8pdG1xFWT98zLbs+45Fav/vde3DXqM7nK9rw32Bw/h4vPqA7Vq+z+4L3fo9y46Iwr9ZlWLFUldSHtOV6PRi0xvID8gCvUqDeGX6pGBaL+9cMffPEOL0k+Cxuan4bFzEmonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPxIwP2onPyonPyonPyonPyonPyonPyonPyonPyonPyonPwoFPyonPwoKfyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPyonPzJ0mey2tpI5bV9u9TmhvPJWoeWZ1WckgjJP1DnsorVxqmnDvyMVIvvy/Fffxj/wLpUBnBFPTAyCZWFHFa59AhVymzzGYeblq4+0Bl/kKEebPQ9Pe+1l1TeXfDkeFd3WVPnXdUa39METGtSX5L/ZDUocYs2dbe1L8R//af4rwvivw7Ff13hS+QVVZ74r/8c/zXDl8wGslQf8cfxD6z1iduyTU38fefFP38rTUT1CpwwFbiqKnD9VSDqVSCWVeDqr8BVXIHrvQLXXwWeJxWIshV4tlXg6q/A9V6B670Cz8sKPIMr8EyswHO9AvGqAs/LCkShCjyjKvAcqsBzKCHvV00ms0n9p+Un/hFSJ3Ep7rxQirsrlOKNgkqTr0OalibfoSuG8XxS66Cp0BKoAZoOuaW8WkHij62OXzp/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/yreD7Yw+NXuCZqHPxK8+uelxazSH/IM6esM6esM6esM6esM6esM6esM6esM6esM6esM6esM6esM6esM6esM6esM6esM6esM6esM6esMeesMeesMeesMeesMeesMeesMeesMeauoDx4McYb4dYb4dYb4dYb4dYb4dYb4dYbAdYbAdYbAdYbAdYbAVdIjqApNRC+jSehVNBlNRdvQQfQaeh2tR2+gN9EGlEH9aBeai3agjegwyqJ56AR6Cy1Gq1EFWoPWojg6harRIDqKNqG30THUjGpQDO1GCTQNnUYrUA7lUR06hNrRFnQgrNboj59/pNr3/Ei1JwsvbvxherZa8Ayy+vHxr+5D1r4yz1bbVroXonSIXxXEs+3Rn/iIQ/y6wne/+gM41MtHePmY//Ic6t/DER6dGETP//WZHet/9eNDP8Gx/t3H+Oix/ymeo1g+oMuHePmgD3YZfu4HcKwHdej4+YP+uw/67fwg2z8lZJT0BLoZLUAr0Cz0eFit0f+bFsq/Kl4ZjkcVqBJVoQvQBHQhughNRBejS9ClqBpdhi5HV6Ar0VVoEroaXYMmoynoWnQdqkFT0fXoBnQjugndjKah6WgGmolmodmoFt2C5qC56FZ0G7od3YHqUD26E81DDegudDe6B81H96L70AJ0P3oALUQPokWoET2EHkaPoEdRBD2GHkdPoCfRYtSElqAoWoqa0TK0HD2FVqCn0TNoJYqhVagFrUZr0Fq0Dq1HG9BGtAltDqs12kqbbjZ/WbMpqrP5R51d+vYd36cfPN70nfgPbh3g75SXJzdVFd+N45rqgo//JCejep4QXM9TgOt57m89z/2t57m/9Tzpt54n/dbzxN56nspbz3N463kObz3P4a3nObz1PHm3nifo1vME3Xqei1vPY2rreTBtPY+breexsfU8KLaeh8HW8zDYeh7/Ws/zXut53ms9z3St55mu9TyptZ4ntdbzVNV6nqpaz1NO63nKaUkrURWaiF5Gk9CraDKairahg+g19Dpaj95Ab6INKIP60S40F+1AG9FhlEXz0An0FlqMVqMKtAatRXF0ClWjQXQUbUJvo2OoGdWgGNqNEmgaOo1WoBzKozp0CLWjLegAeims1uhOThW/wZn0Nzjn/gbnzt8onSp2UU3vqgi/C0pKoVa0GrWgCrQGVaGTKI4moGdRNUqjiegIeh51oP3o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lYHtqQxsT2VgeyoD21MZ2J7KwPZUBranMrA9lYHtqQxsT2VgeyoD21MZ2J7KwPZUBranMrA9lYHtqQxsT2VgeyoD21MZ2J7KwPZUBranMrA9lYHtqQxsT2VgeyoD21MZ2J7KwPZUBranMrA9lYHtqQxsT2VgeyoD21MZ2J7KwPZUBranMrA9lYHtqQxsT2VgeyoD21MZ2J7KwPZUBranMrA9lYHtqQxsT2VgeyoD21MZ2J7KwPZUBranMrA9lYHtqQxsT2VgeyoD21MZ2J7KwPZUBranMrA9lYHtqQxsT2VgeyoD21MZ2J7KwPZUBranMrA9lYHtqQxsT2VgeyoD21MZ2J7KwPZUBranMrA9lYHtqQxsT2VgeyoD21MZ2J7KwPZUBranMrA9lYHtqQxsT2VgeyoD21MZ2J7KwPZUBranMrA9lYHtqQzrwdANp9P2VI0TIoO7U73J3anee7tS5UdHpxjYvUO7Um18jQ71dZ92noi/wes/7XyShvSTmT87m1Rekfmpneamk3RbyWxSufmUW2dlU88vZv82W9RPVJtY7x6ifuJWWNUB3aoO6FZ1QLeqA7pVHdCt6oBuVQd0qzqgW9UB3aoO6FZ1QLeqA7pVHdCt6oBuVQd0qzqgW9UB3aoO6FZ1QLeqA7pVHdCt6oBuVQeyxW4bnKcDmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADzYwDmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbADmbDDau4/JbciWy8Ox196uPWWT6MKb86mMENAxaASUCloKKgMZIDKQcNAZ4AqQGeCKkHDQSNAZ4FGgkaBRoNsIDtoDOhs0Dmgc0FVoLGg80Dngy4AXQi6CDQOdDGoGlQDugQ0HjQBNBE0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'
)
DATA = pickle.loads(zlib.decompress(base64.b64decode(DATA)))
MEMO = (
b'eJzVXQl8G8XVT3zbsmPnviCHQxInIXESbuMkyLaciNVIRrLjhDhZZHkdS5ElI8k5wOEoLZTiFiimhZbS0gNK74Me3C2FHrT0pJTSFuhFb1p60PajH/12tSvt7MzOaK23q+SjvybZWc3M//3fmzdvzr2q8tYZM2bOUP47PtUiKH9MViTCo9LUZGW3L+DunZqsHgtnMlIqMaW8qzwcjo/LL1e2DAxtaBnYNDC0ft2E8teGdS37JM/+fRs27t+hPO2QCxiOhw+mp/ZPTZanwkemJle1FszUOjVZJR6JDmVG5GwtQtlbamdo/82UJmtEMXNsTBLFqcnaHhVT0DM1PlkzloomU9HMsSlhxsisSVevlBqNJsLxLml4alyYKcMeKZus6wp0iqHeoNe/c2qkQkmrmlze3NzcsmmibqJh3fod8r8n1q5dm3+W/z01UrN/aqRucnWr+sOBxMRAyvDTXIr81Do1Uq9grsIxj8waaRwfaVJwjcweF8pULNU9e/0+r9+TBzK/rW3sWFtbvm71MVf94tb861x9akKuynpOleVqlVWE6MtaUjsGd0wM7kjtWNe870BzQ93+9bJQ+w6sVf6Vl/y0VuJ3A6mBRO6X6r/zgpdxUFSoKCo6AgFfHkNdb2pcmugOx9NSrr76Vj0tV26FUJkvbqZaXKUmlNAv+r3+fIH1A4OJZGYgvSGaGBjMFTmrFU/lakkrvUov3RsylB5Ny8UohRlK11OtlF6tll6+y7MnX/SczfuO7tm/b/PG88Ibh90bu8X9G3IVzGul3+WqKecwXqNV04Hx49q8b7BDLmoLVn5DK5ZopeBareBAZ69OzeZ9yYCC8Rys5FmteKqVouu0or1+rGhF8qz44v71etF4aq7omZyiXZoB+vt8ugFW+JOJvOlVtSpPutFVkIqr1xyJ0O8JdYp+N9Lb76L27fvCGy9zb7xY3K/9wwh4SSvrF1Z4aciBx+tcwK9xUSu/Ph5ZszRJe/f2kC6zPJ1J5aqobJYfmqdkl1unueOQ/BIrp1Fzd0o5uE7Lo4mMXoj8oBQyksZyNqk5a5WcajeUyyt3KslwPnd1c/aRyj9bzV+j5Pd5Q3r2ing0nc9d1aw8UZnnYJX39vX4dM4rM+NjcUmvPPtI5Z+LiR3yYGKnJUxs+YHKOQ+D3eXFGljFUDSCwVaeqMzzscwGP1sxmEzG9czKE5V5ASZzx95eT0iXefBYRkrrMmcfqfwLMZnd/r26zOHEMV1m+YHKuQiDLf9fJ7tC6ex12MoTlXmx7qp9ONNxnOm4CdNL1IwuOaO7Q7ZxN0Z2eXgwjWEepKVdqrEl5w50XOjB8yYHY3pe+YHKe4rGlJzX4+9DurhSYnxUF1d5ovKequf1B7owqhLJIYwq5YnKu0zH7N3pDwT13FXRg4lkKp+/pll9pkpYrmlKLmG3N+TF2uThaDqKtcnsI5V9Rd5/ikGPsYDqlGQoorZZS6AKWaljCPW4+/W+rTI9Fj6S0DFkH6nszTqB/d7eXTqBR6JyyJknUHmi8q7Sq/b4e4O6jVdKiUzqmF519pHKfhqm9z2Y7BXS0SjWtJUnKu9qTHeoJxDsxXQ3OpZMZTDdZZ+pEtbo5Hv9nb4+zHiqo4lIfFy3n9pmLYEqZK0uQncwgJnucCqJma7yROVtUfNWKg1Ody5l4XxLq2gO0w1tHUZa107M4KWhg5jBK09U3vU6af1un+AJ6qQdCccPSSmdNPWZKmGDrnF3aK+/U9d4OH0sEdE1nn2ksp+OZe934+0lfCSMt5fsI5V9oy677I8xg5H9L2YwyhOVd5MuuzsU8uAGE06nJdxg1GeqhFZdX95uXV/RYV1f0WEq12ZMXz4sX4UU13PK+oqb5N2C5w3husYGCEreNK3rrXo/0B3QFV0+nMSiFfmByniGLmZvQBczk9TFzCSpXGfquTp0P1A2eEzPNUh7gLN0e+jf5cXDiiMjUTysyD5S2c/Wu6zOgL/X6+/TS6iJJBOZaGI8X0hdcy6FKuccHUZH0OMWsJ4+JYUPYT298khlP1fNXi9n7/KGPP6dbqxd1g5F01LiYFhvnK7mfBJV1Hk6kr1ej69LR3IsKsWHdCTZRyp7m24wIcHboxtM+lB0TDcY5YnKe77eQIIeo0dNSUaPqj5TJbTjJfT2Bf14CZnxVAIvQXmmStiml9DlkcMXncbyISmu2638QOXdrhs83hWVYx1RZbNZN7RDr9Szp9PTgwkuHY1IY5jg6jNVwgV6V9Lt9bt9Pr366mFl3iV+TO9KtASqELeu+qDbi7X2ylQ4msbaQvaRyt6BeSc/5p0SmHeiCe/EcmF9UBTrg6J0H9Slm1lP0LtbN7OxVPSwbmbKE5XXo6upp69DV9PY+KCuJvmBytiNVxrAIqWxVDIjRbBISUugStipV70L63HLR8JYcDti0ufu0i1kpy/Q4cYGEgfjyUFdYuWJyu3Vq+1066opj4QTerXyA5XxQr3aUK+716v3tlXpTDgTjeiGqT5TJQi6TSF3b6ce3VWOhjOREd2mso9Udp9Oeacb738iYbz/UZ6ovEjL6w4GA/JQRBe7fePGvNit8kN+uC+Uk6Nuv6EMrBPbuHG7Xob8wCkjoFGgltHh1YVox0qpUpBsN5vq0Irp0Zq4Jo7YswUvaKANL2igjYPnIkNBQbFnqy5WGy5WG1esIIlHL6asLU9whVxKfjJSKCMLCZFYtmAU6zLJFOsimRTTq1HcSeq6sn1gw0B+9qu6NfvIEarPWJCu8Eol43a9oOwjp6DdWmDQaaKuLKg2IyiewvqNZRk0VtGGwapqbeOj2kOhwnWvE1WpFMThey+FCDNGXLiqVlw2k5Iu1hrYLk/QIwb0eKGufWT7RPuIlJLy0tW36mm6jFVkifu0EkMeX7exxLScOy3Fh/ES82mcEge0Er1+b6+xxKicO5qIZvAS82mcEvdr8VpPINQrksU2tY8pZYwl0xnRUPicVvKN7i5cZBUHNEsO9fV4gnjxDe3p8TFF6vExKZUvu7HVkJwruFKoJgsWNTaCgQDBRkrOnkomDWzk0zhsXKL1MmrPhpdZ33awbaJN6dPC8bxNzWrFU/Vya8hyw5qV+gN+X6DTWHJjWyIuF5JIJuLJCFb47FbihU5xHVn+oIZbHckacR+Ry1BHsDhuLJWDO6IxrEwnGRhuS2SRDUltOsN6GofhIa1EZbxuLFGScysjdbzEfBqnREmTXZ1qw8usbUvK+ZODsXyRrtZ8kl5iJVnisIZRmW80cHnJRFtGzq7MNWJc4qn5+XMa58Gc5P4+hJda1aZM5uXLq2lVn/OLRXRJI7muqsPr8/buNYockaHIARQuci6JI3I0V6TY45WF7u7vwrrQ7VgXup3jQWOalWuFdAh4Ke1teintPD98SHMXFJDygQksJJAfOIXENaOggZS3D0xgMdfABKeUUU1lXbJ/MSLZhCPZxEOS0MRRyiCBbMKBbOIUktSYVYeS4i58uaRsI6afjTwoYxoUj2+3N4RbTfnADizAkR84hVyacwl9PtmN6dMDZQM7dBgDO/SGQK0fpTTdyFE46vOJnov0Mi7YppdxwTYOinSOVU9nwODvZl6QK6G89QIOiIw+EHH7daVUrVkzEU4M6Y1RfdaR6IGMtu43fjw/asSmlqoHJgYmJvTppdpWLcFMJq2kwxokd1cXTkr5wIZtmHI28Gg5ohUR6usw8LoR43Ujr4CjmqHJYyw5lJIDKqyUqoH18v+26dyoz5wg75gGh1Bz+cB6XKL1PECXafFJty8gK7rLuxsvqHKgdaA1X5QcCiuPHDyXa3iIYsqxQirxIkzwTOREChiUVLYaY3g1r4DjmvV3ZA3PUMYarIw1vDKu0Ky/Q7E5oyQTuCQTvEKu1IHsIUs5gJdygFfKVXopftnD4eJcgYlzBa+Mq7UyfKFd3m5DGeXt7RgS+YGj3DdopQTpUrZvx0qRHzilXKPpV8WCdV/tWPfVzhHmjVoBQaKA7ZiX3s7z0m9SCyj3YTN+Ze0Yl+08Lq/Vcu/Ec2/Hcm/n5b5OzV2GbT4qW4llXsnL/Gataj82IVWeSOpLra3ygxn1mv+7Xg9ig30hgym1YRjaeBjeonnjzoAvoE8vzWzTO4U2TqdwQ075HUF3p07BzMv17Jdzsk/mVE9kP65nP87J/lY1e0XIg/SZmZnn65nP52R+m6Y5D6a5bRhr23is3ZjLrFM+c5te7zZOvTdpSu/ClF6mBzZyKLCJk/tmrWKfnnlmu15xOyfr27WsO7Gs2/Ws2zlZb8kbCUJuPffpeu7TObmnNDX1+PqwWWJ9xkIWeQMn+61a5cjrx/LP3KhXvpGT+x2a58/1z9hch9wZY3Md8hNH4e/Ei5F7Z0yO9Zgc6zlIbtNaa75jxqDIfSgGRf4fB8rtOQPCSijT81dguU1QvEvLLXfHOperdS5Xc/K+W2uuHcYQcOYaPfsaTvY7NEV2GAK/Mn10IUOf4OR/j179HkMBB7ACDnAKuFMvAHe5M6/Q8V/Byf7enLPrcQc92CrJQAtWfwungPfl3B1ZwDqsgHWcAu5SC6j2hS7qc2M7TsoG9mEl7OOU8H6thCBVwn6shP2cEj6gllDXHeoNKisL2FJfmbIInV8dHmjWp/W1DuuDWivK5vXgJpTPWNGM59Pq/JCar0Gt8yKq2rV67uG1VK13q7ldudyGivNZy5vXUvXeg8va4/VgfVTtvgMDlw8cb9b3Z9a3qkkDzfruTLNdgRf+V/5PLf/DhFzGKuq08taa1LHWch335tyOUkeHJ4Tturj88onj+a62ujX7yBlufUSzHaUX8GDj6bmrBtbnt1oPrF81sWpT3icubFVf5jZaa6+t7Jr8qNZf9etOv75lR9u+FbX1DXX71+U48XNYeD3PwsfkAiarkqnowWhC64/q4uHUoU1x6aiUmpqs7E0ekhJTtyjb9YN9Po+cks6EU5kpYbFMxczMVFDZl+nyJxO53fBT45O10tGxcCIdTSam9muFVo0mh8aVvQezYtdWzJgxHp6sTKaG5BqEGZOV4Xg0nJ7yT1YnxzJypnT2BEDjIUkaE8PxuJhRIKSnrp+szpY7tGXq+pEm/2RjRhodi4czkphOjqciklxAg5ySOSZGE0PRiJSeWqdAC8rVBrRyx+WECiVhalz4uFxJ7HhF9jzCSFnsavlfLbE3yH/msQrKDKkmooo6dp38p8yqpvChZETMhA/mX2vJUlwalZSdp4bkRlFUyxUVAsXN+ddS7Ab5L2FGbFL+yx97qwopdqP89/Wxm5Q/ZWljN2dfvl3+U5YqdouSUf57Svlb+IRRlNvlf5kijt2BvVFT7sRSNCAziwfySatA7qSAvI8GUlY8kE8VBELjCKu1lhdf66cL1qpWUVF8FZ+xyDDLOJs04xSVrYei/JupgmqoLB7tZ63aw4OUPTxMA6kqHsh9Fu0Bx6HZQ3XxtX6O6WLy2hE+JFSb+hjNbWrb4ifrhqPxjJQSk+MZ2fvNmqzR3W0Y7D8+b8T5HQY7hrNNsR9kS54VexrjCuA6vsDkijZZ4TGhxg7HDPe8X2RrOFeZ8GuhjqNhl7qRVu4URnVgcJXebwT2B5ZK67U9uKb1A9T5gMX6a8OpyEhU3YFvrBzg/R+0WHl1eDAaV87z2dcFPGSx6jp1qVc8HE6RtQN6h4etsj6ckiQxkt3Mb6wc4OwfsVh5w9ixbNXiYDwZOUQCADj5Ry0C0DY22+bmv8R0AobGje6cKczjuS1s273Ru2qjw/T4oJg9Mku4tdw2ebNMOQRjYeXcgSGfNmtllqteyxWVQ+w0kU2dVTTmgjvSLxs5XFbJimuKJInDA0cggAN8jGkURpeLTikTFvKsAj9K4bzEABV+pWAzyEJBgTJhEU/g7AywmaTMF7WK+ENiShomBJ0niljV6sBrC9kM1JMiZuWqByHt5ulxI09+lqnHLpLfmMCKhRjpfZVkEN1faefo7onSAd/L+OU+Kh0+VvxqKcSSwJHF16Aw+eZRJO+AYOXrzgoEH71+w36A0+YXEA49aSd8CRwlfdMqHEfstKZ44N+yB7gGpLZ4IE8VD2TafNUVD/PbBWHSKLUg3FV8rd/hxFt4MItuLBMW88KP+fmYIZtBDRq2MoIr5Sc2Tid81yjEp1nUfZ6mDtCvf69g4JYVEz1SJizhjl9YYVjJQ6zvGyX6MovHx23l8QdMHvUYHf2yTFjKI1HbcFI6rp5mosbmZlB1ubCMO0oZkiLJVDiTTFHjRfW+AdvayA+NeJ9nesGfk15wsiEvkDiEGSk8Mn6meEyzcEyROAkKENf+qCAo9cUv6UYACFOftVjr7+laAbHkjy3W+gpdKyBAfI7ZdEitou5yYTnXdyoZRMM8qNawwpGIlE6bTGdXmc7Es12F+qYxmhiRUrJDHxKVKsnWWj8qjQ5KKWJuDt5qf2KkqqqK1UJqq8jYxUWlNFSZRzONjPTZZAkOzfn89EQKObeKijUBzuNnJ1KUZVQ6fPj8vJ0CWTY0M60A3NwLJ0YIpj4AvvPFUohiwj5gQP3zUkBmcg0Yev+ieOBgV2umA8Bg/JcnUhSmbgCD+l+VTiATTQCG+b8uHXAm74D5gpeKhw+y/friIf+mFJCZXDcUD/y39gM3YXZW8QB/Zz9AJo+NxcP8/XHWeIMY2aL3lQsreMONOcrOBzGTzI4BxMhIWLnRpiQDgT8wZcCnENB3yoWVnF0zc0VR/7U4Fh9Pi2fYuHvmj2yQ2HAM/b1caC5yLid/4Y7d0zl/MkL/GNOUP2luuPk7hOweHL0MBZa/GMnuBcA/M7VNDZbRmgrhNJ7KlQNIZuAXiSJRljqxfCbZ7GSLHo1GTJukckLJbnP5i1H2J5ha+TrDz32L8ojfZnk+gPG8YhEmp8nFnqRmAXhkmxYEt7W/WuX7Jwy+n6f4ftGB0fLfmE0Cm6hCd1UIazlOGrsR03S3KMBs/27E9yeaRh2CdnOu3RtW/2ERQv5OUVMAAFN6dRoAsrf4mgIAGMk/mUZiDB5QbaWwkec0c8dkzRznfFHEC1O95lnkVGjQrAC4d/yXUcKaalZrdVUzRjRUOtwX/ptJu0tjSt1YtrVS2FTELmnG9kw4mf9jxL2USeayatJRN4UH05lUOJIRyR27cDpfKx4WtX8Y3j/8p3g0Jlup4R3B/xaPp2YknDZuK4dPgL4OoIfe8wyfxfxvQTzqixXYC/BGZzRjpsVq19LVFj+NiGZarXYTXW3xU36ozGq1Z9HVFj8xh8qtVttOV1v8tBqqsFptJ11t8dNhqJKoFt+8kG/H6LZKobXQDnbtUlXW0FL5fILZO/Y6Z6NSfzidjh5MiOpXNawu5RXfWaEqgo+DTE8TY3T9cUb6GOmZYin7gwRUDcWfv9DXTIYEJcM0pCq+d0Q1YK1cDddK8b0pqrWMn2U9IOaL73hRHRj5NHAW3yEjl2WcLEsAMQzo1OvByKeBExAFNLB7CspToxcrhc28DqOAb+ccUWpSAt0hUckfiYfH01RUB3D+swgRP8Xqg79A98EAn93IZpaWFi2tErZwB9Wc7UHMnZo12SUEug9WLnQy7bWlo2MpudtWrnqwj/8mgojHmE3hCUZT+BrVFL6BpcC719mWEfKRqCnfZEjxFI0Z0HnOsQkzvBucywk28waI9lYJW4tcXXHGLOexYaubXNGbqoSzOBOiNcqvDFtPwTOhaD4B6m8MXzVZq1WO7TGFu6wFbEqw+tDdVcK53Kmo3EfKpjcycGQHZF0Wt82TX2ghQVRZDavxVdaYO4PqGrJR1jJ+6WKkN5AlOLMNEi06CWRtrLHTdS4+CSRaQqXDHfESB+SybH1mOgKMUJaeUFmY2gGMZU4poUQmugCMZU4tIXIm84AxzjIwfrBvNtMIYBJ1+UkgEVNTgFnaFSWXy0QvgOnelSXHz9QCYPa4GSwFqF0Uv6cSrSohcibzxW+tRKc5ht+E5+J3WKLVjuFkslr8Rku0hjNAzY/h0D+rhPP4myyzW2WSYjaL2SYjZ8Yaa9no8QrR2dVCe7HbMuaKol6UuinjbEI4dQBoWADWynVmtwZqIeR+L9PG3s+wpbupNvthlnUBxkfrwDiZqABjnPWFhvLqEuCl1cJ2ntGwx92lnUPcQIjzIE0yGzB8YuR0q9Xzb0MD6HMjW5/5fSvoq9VCZ3HHul1aGWYnqQFq20SgfprBW+zH2Au4uloLV1uQEf3z3WZWXq/zZecpb7TZKvLYSwxn8lu6owdMKWyxgUkuV4Apgq1WjetV2rgA4/gz2C3RKCk6p0bYCdxfoXwM175Z1Opw4pjJMlHt8HgiYtSOVosTOwfRmQSBM2tZNl5Ra27jVYz0mlqyw69j/LKe+uUsMsWh6dSzTkbpJ+ulw8qdvMTaq/rrplrKowA83Nkno/yxtVTKKVReuDc9p4SyW7BwM80C/PG5J5l0TA0CnP95J1RG2kpNNAiY6G07yaRjahAwGXy+YzIC+hozPQKmh9tPShmZ2gRMGG87CSS11CoBk8rbT0oZmdoETDzvcEzSItsgYCr6ghMqC1M7gMlpdwklstSmABPYHSdUFqZ2AJPcnZYlKsnoyUxfTcVL13WSScfU4OziZfScUBkttbg5xUvXfZJJx9Tg3OJl3OmAjEW2tXnFS7HrBEnB1Mj84mXxlkQWS21nQfFSXHiCpGBqZGHxsghgWWzulRYVL4vvhMrC1M7i4iVCJZTIUqtZUrws/hMqC1M7S4uXKACWqMg2ckrxmHtKgpnJ9qnFI7/IAeSWbH5Z8ZiDJcHMZHt58chD7GU1w+I0en+NsMvSPp3spWhm+3RKvN7VS0i2rY6lkwvqCKa56zJddZTlANal+tj80/d1oN/WCN7/10ubLmV5v0Mu0E1dJqT+wJmD6LsJloNMW+irM2+f/Yz0vaTtxPYxfrl/WlYWZpQSodLhNthfQnYoFmIilTJt2QHrontOqOwJuOyAddG9jsluuQ3YoX3A2unFJwEDNtgAYGV1n2MMOKJrwCrrQAkltUGngLXW/ZYldaBXs0PLgDXYAydUdhv0DliVFR2Q3RH9AlZlLymJjDboEbAeGwbLWNLWClitHSyhpDboFLCKGwFL6ojuAGu5Qw5IZIOOAGu5EmeLsWGohvpqhQsLXcXQ7+3dZfmohp7Ns8drPjJ2BT29fUG/uMvrN/8Bb5zuzPGQYYKwKhfLBGpd5mp0uUiFNzB+2chIn4uVAB8KHyyJRPBh64j9OLNHLzz+3uBe09vqWPzPtq4XwFA16oBeNsAtDTD0jJVEIvgA8RAY53Rb9DQsCjAcjJdcLhP8gEHeqAP44cOvBBjVdFvlNKwFMLRKllwuE/yAYdOYA/jhA51L2QEXtoKAPlErCPwj1j3uoMd8WaMpX444Fk6FR8lTclVBdt6TMOJKEYylmHocZ+jxCNVrHGP88nJG+pW2RlzpkkgEj7gyYJzT5fm4df4BkdV4yeUywQ+Iow47gB8eNR2xjMoG7QOioKNgnCZ4AFHNscJ4wDHKZZwld6q3QK/XCj5e57NYFMlM6k0e55Br4tmX4uFwysb+4HJClodpvtQXj2Ev4Cf9Jzgdty4m2lgnIB53NaFed1DsCfRPu3dlX5Bxcly+e5wg6Clmu/ouo119n5H+NCP9GVt75SvA+K3gVFOeZfzyOVoiQP99ZUkkgvfHV1nFqbUe1Oczna+B2M+09QLov6+2rJd/OddSAD39G8D4HdEIICa4piQSwWOFN1rGWdK2AIhM3lQSieCzIddaxukIw4B5kOtsRQ6fAXkzO5CqOxhPDobjaiR1Q53Qw50CKe6jQOpHI0aVpa2SfRToekLk8+pZKmivN1fBBfWk8XRQv4SHQG+xijO763anL9DhNu+Jt1NwpyEAIOK5wTLRATjRgIhnkt0GKANFT9UJF3G/hcI3ac63UOr0nDYOBN5KCCfSSlBfDGMv4AO0t/FmVvOf8ENNLqG36HVs7nrhZE16fFBUvpBSks3+NxLyXsq09QzD1g8z0i+rp/w9QC83sfVC3GGIQi6hn/MZjOqevX6f18+4dBFA5c1siBUZSWmDGZdwcSGr6fWEGBv8mSN3Zyzj7YQ4NzEt4xaGBbzTVgu4hU3v/OwRmmQqd95DO0WD7nEJ+3l8M/IZ213+NE/K1qsmpwhxPsCk926yM5msyeI2wQOg99bCeNQXH6b9LaCvfYfVaj9JVwvoOt/JNqY52XNYynkshWTNkl52CQfAlsRUG8CMbiMEeZTF3+O2dpO38/ijz7Oh5npBPFlb4rsIWb7DovBpWyl8twUKsau70d564RK4CWZLtJe/OwhBXmDx9ytb+XsPZwSIhwMfrRcixd4zPiudCWckVkzs1E3idxKS/ZnZNfyV0fO+6sCw7r1svkma0A/rhSFOCLZQFI05xLH4eFo818YPk72PE8fn655Cr9QLwxygrujoWDKVMV4jDwd3FwHO1WDeYuhPvMObzfut1m3yQXd4d/8By5JHh01ZB/T5H7Rad92RkWhcMq0eMF//IavV1wzLTtyscsBk+92WK8+kjplWDpgXv8cy8aPhjNyHmVUPmO7+sGWLPxLNmNcOmJq+t3DtuRvJtXlL+lQ4Zz4RMBn9EcvI6hPJhNyZThcbYLr5o1Z11qh+mjaSOWr+CQPAFPPHLPPjSkmZ8VTC7GsjHHoAx38+bt2ojkWl+JCorNVbRwY4rvMJ68hS4WhamiZngGM3n7SuznA6LZG9fkFogPMzn7JOmslca0FkgHsMP22dtCEpLmWmq0/A9YOfmU7zpKO4gtAAdwd+1ro+mUeaOMgAN/7dZxlZbSSTik+TMsAlfp+z6vD5X6wBXL33easIXEfC8UOSeYgGuDTvC1brN1NAGHzP3RfZA6Z8LI6WNApXcz+KLfSL3u5pHt4zm77WbFCKk8MA+Oj6fkLQ+1hNIPaFBvPR9f1YDjXlQTJFgU52bvAh+AMOQ4cvnT7IGXbrykR7GoU3FPwit+9kt6SHCGF/wFTHMwx1PEup47nSWNLDDkOHW9IjXEvKMYLe1ShcU9iSQqVcOHuUMzGJzSygpxqFa7mbfJU15F1eHwP7tFoBXKovsaXSJyyQq0m4vpBM7K+UKZtxugNBy7sM9E6nNzBNkpRMHeYL8OyauP6F0UgBlH+ZoLxuFquRNsxinJFjpM+eRTbeuYxfzqd+uZDxy8XUL5fOohwCwGU9ZpmNk0dqNeVUmgeAY/zK/0Me4HudHrcqNcDF1IczydFoxHThLBvZMi6ALC4eYfgLwAzzE5Yto5uhxV2M9Asp7foYv/RTv+yh7QAwkf1VyzI6LYuaEqSlA8yUf+2kkQ6+y/zrnIAhv8iAnmwS3lpofy5rpxy7ebmkoxFpzHTR1qTlaa1/OJoIx+PH7O7Fv0HwMM7U6VGGpi6jNDVBpVxha1/7ZEkwX2Vrv/hNa5hvLZsxc4byX9Hg4Z3Ztxyg9wor9AI6l6ccxgzvGr7tAEITDgHu/Tu2IoS76O+yXbTBg6L62cLbONsk5oki9nN1M8d5Nu6X+B5nRK1VnL1qffVs4cZCt3x79nR6ehjnPbijRXfopNiW+32Ci8eYNvQEw4a+Rln5U7Z2Hj9ga8vYxyJxtnAT9/vvSrDu9bt9PusBAJzhpznWhm1QQLfNFm4pNNeB3L2d073MjrchTW5pOgS1oW3ZXKJtaT9k89KkgoqE0/ltd8/OFqYKTcx1uhkTc66xcCYjKSvq0qVmA7HpTgxXdgZ8AfPRG2uLH5yvZwi+XmW21H8zWuprVEud2Wj+y/JGO1vwjzj9Aq4Z1DZHeCenX6hLpkTt9zb2Bs8S6GY3Urwez03ksaoHkPNjjnvA5EXhOcJtvAYgN2X95+rNF1u2kPdakvDhVvkcAX8Fg73YauwFnLWfcFjD1ISunSPczu0STEyqqD4azuRPOSumeXnunSO8m9NCGuNR+XfhuAPN5GcEvG2sZjI7HU0cjEuZZMKB1vK8VRSNkfBYZjwlsTAARoYvWMXQJDu1cSkRYYIAjPletEzEaHhsTNYICwNgDPdzqxgaIvFwmuk8AWO0X7DbDNUUkH+u8EFO2ymnb5eDt5pfEgCHWBRVdvsCbkb9gPbyK6v1u0bH4xk5YEnJpmJjW/k1W0EmfgLdNle4h6OiCn+fjzzbDdfRSwTGYyyOKjoCAUb1ABX9hmPDpBNDT88VPsIliO6Z4AT9lhOpUy4OVc0TPs6N1H2hi/rcQfNIfU52xB9NJCRWv7xEFMk6tWhnKxntBE0rgvfUvyP4uJk2GC0Sn2LE1+9oJCPxd1G/hMfdv7eKk3tzZ0GVxG4jpWHc5gmflP2DZebvYTB/L8X8x1jMA3rnP3LaNNkfoy/PEz5d7ImyOUPRCL+9LFaG+IYateZyRonG+X8iuLifqbOHGDp7hNLZYw60lpfBOJmoABb/Z7YlmTVMNGe+8BneCTSzmRB4D/EXAuUPmZ6Ge1kab2QF0OwrHA5N2g/qmi98lnu3CWuUdbzQ7JAp/fAm9ldCwJcK0M+66dEZ+v/Gpp8YGKAPzRc+z2OePTvO68EaDx3J+z7Tc7eczgqglb8Tcr/GdCivMxzKjCbz9AoqHa6lf1hFW6QS6jka4NwGBNEdwO2+all3sxk6mstIn99E7WxiaRMQgPyTs2hioBOtXCDcz2tyRerNIU/3L0KudU2M6cbNTXZON/6bE8+RBoouWiA8wO0++CbNIbVWucdpyOTUJOtSXYe08D8EHefTWtBaRwdl7V2MdtHdZOeSw2uc7d76sVx07wLh4eL3F3Nv5apXVo/EcNpMxc4sNP6HkDnE1Moehg4uprQ1YKtW/pfjlQx0oecXCI/wFLNAFPEM2pDmTHIGQPuNjSS/TogQZTmghK0O6L+cxYGckKhyofAod7GjmA0JztzLPaPMKM8xFo0TttI4s4xJI35cHvUsFB7j7vxQr5kUAz1sP233+m8ZG7vxQD0aWyh8hYfe5Q/4fYHOEuMvZ+PH6kNTC4XHeeDnimL+11qzP4vck0l3k3D4FQT8u1gWe7etFlvJZo26qwD9YqHwNa7iC31Ip9SngKrY0hkuQUAbFglPFtqKpQpXQidWTaB/hGUSX6b6W7hh1HBcGXZJA4osEp4qFOLs9Xp8XcwQpzsYQCVktZYQ7NvMMOZ7jDDmh7YGLXUcorE7J9Bdi4TvFiI66Payzg5yP0ZaYhW4CJF/zlTBrxgqeMlWFdQXxsOCA1/CbOD4KPxmD/SXRcIPCvkodyjkCU57uyjnsmRH9D+LEPk1pv5fZ+h/xmw79d/IUQF+TwhqXyw8U0gFXR6fp9d6I4Sz2cTt5PSrRFBmsfDjwp1cT2AaBgRHP5sTtul3eqCPLxZ+yrslWYYeErxkuAlfeZhDwFsz29w1ZN1vR9DjFmxfwJ9rFYJL2aMa8Pd6/X2MRXqAm5rHsTL8hhH0n8XCC7xNloej6ajtVxTOJ9Cdz+KoPiWxAQCUtMAqgFlDcpeeOBg+aH5jH0BDC61CcEUPJpIp8/oBc8KLOIEMxjmKLxF+XSiQ2e0NMT6P3hhNjEipaEYemSg3PpLf+WT3co6ceV9MyLyb5lzryfbONu/J9s0m58T2kym8O4wAJrsEjJ1CGhPpfhlg0UsdQDhC/RK+GnIKZ+rE4G/QN5YIvy10hCToYVt/ic37VEKwCaYCrmQo4OoSGfMyMNJrbDXd5WA8NzhgqCvYhkr2S2jJUuEP3IU7JdaVh5v+ne6d5uGuM98VWskJRPCODQWXCi8XCne9O/0BxlbBou66A8jVzOk+sSte0PVLhVeK/UTUPFHEvpujnsc6m+xBTa7ghEu3ipDuc8z28EVGe3iA8iScAQnAk5xmGSmFKPaQrT5kNQDJ4zQSgN9YYxUJ91KSaX+ylW2JgFMFay2z+gzF6rNUynPm1sqzTcB5hBabsMPPhq+zxSKqwuMHxeSYdQ8EOD2+3jJ3r1Dc/W06vgdw+/YGdh+QowrtPEX4B2d8XRsM7fJ294pUm4IPsk8n0JXPYQwwa318DADvvNEyho5+0R9gYwD45U3TwbAnEGRiAHjkVqsYamQMHAgAR7p5OjS4/V1MDACHuMUqhioUYAMA+MGtlgF0eXczAQDc2hlWAdR3+wKyIfBgADzXmdYV0edjAgB8HuAsywBCfR1MAIBvAJxtGYC7i22KgA8AnGO5PSJ3L08LgJv+z7WKwZXbKM5EAbjV/zzOUArrt1HfqahyJm8s1XAkHE/JgyR10GTH1Q78C14dWWFpI9i4mKGT2H7sBbynPt9itZOueHh0cChsjPfgvXQ72wgItaInTkW1XDuoDieOmWyLre13+4J9IdqE1dcVY1Hsa0RwRW4jJDrMUuRxWxW5nTPhgqsOVS5D9XwaeRtam4bHExFxSIoo515S4VFyZh+wuagqe3lLKbfu7CA4ezOtKm2wccMc8+mOt84hByG3MH556xxqYAfQ9gVg5Dcy0m+GSARwBG6wRNPACQjpO9jtTPUkaHQZauQ2MKPH0QYAPd4ej9jdb74Bq1bJIQ6Gbd1210lI8lmWo3rAVkfVxdlKoIuJPrwMzeGyaMKJ9iJLZYfA4NIlxQ9H02JkRLKVTQ8h1hMsNr9lK5vdHLePC4r+uAzN5/JpyotmnB7fbm+ItU+4bjCaOaLsgEvaORW9kxDsRyw+n7eVz12coBSTE525HC3i0mnGihaRZsf65raZy3TUVi69hFC/Y3H5F1u5vJBjm7ig6JLlaDHfNs140aIGdfaGT2c4MWQjnQK5MY5FZ9lcO+n0WaBTERTduBwtsUYnzotOp9tv7jkr0yPRYTsXrhEhUcNcBpHzbCXSzyZSExF9cTlayqWQ4EIjT53VNfeS8eTBqHI4w9aWHSBEWU4zqEVNzXOJuG6yysdEG1sz185otacwSrpa+NjyIo4vx7SBalegZXxfbqK74/nZBZbzyWWy1/kECaHOY3F5ga1tJsQbXmKCorNWoOV852PGiz4CZDmffLZE0k4X1EvIJbDoDNpKZ58FOhVB0dAKtIJLZ7k/YO5wHCJsN4F8P4OwyepIcnQsnKI+9AxgrZ/NWr42dMMKtJLL2GxR1H6snRw7h1zZDKeimZFRKRON2EjcHgJ8gmVpaVstbS9nsTIyOpZdrPzcCrTKnDK9XXpD5MwMfKnyYgLbFSxbyk7ikidT4dzss1q/QoCf+lILvIcamBYBjPoBkxn7rdZf5mfsVQesTB6wWnn5TuqkBnxNUrRcu49VO2BB8hLLxO9kXAcJWIwMW67cx6gcsAQ5aLlyD4N2wPJjhLd7T3f6yL8StfIjQpMuQmupyOvvY9wYnJFSozb2KEOENA8zg/8vUcF/RY/PHGXscVtDf6kwRrpauGMd5szSZrWAJlaizfxZWoO2NF+AAubRadVwOJKxdWR3kJz/Yir3OUq55V3e3aa6fd5W3Y4AINbm9zlYBQqwhigAKPeqOjOcgO44BsHZ5emUCTWfozXDCei5DxXGSVcL77LjnFBWa3/o0ZVoC7dZV6k7zkrUikcJyLXzWBsw2f1GbNY8O1ttwjIkdh9hggjQPJOFEWkcjSWPSNTuA0CDG+PMBKp1oZdXoq38mUAjKNxrsG5YlAeriYQUsXNYfikhSQuDw1jrPKpJAowpxR2Rq0Kitc3oLP6OA5IPLcjSkum9xy5tt7LNWzfShDRtrKYR2zaP9L8NQ9E0C2/MbWsLzhSGSVcLj6nGeVcgYPpAlzejc/lTgGbq0xqOckS8x91vvg2kCcto93L4YUK8Xqby+ynl17lF3vp9bJ+t+j9SGCldLVz/R9n6p/WCft6MzucaAVuXmpFonDIX8muG0mJ6LHzEzh1Bx8hJOha147a60cvY1OpSoh2r0HYupTQjVhpV1XhizN6mdDkhzlUsFq+zlcUJTnyoyYgmViE3n0Pu1dT2c3WcAP12ZjjGjSli77TVxVxRGJUKqhzfbwn3MVeyVZitCT26CnUVjO9Za0jqlqFIOB63UYFXEZA/wjL2T9pq7FcX2kaVFRP9aRXaybd37sYz82NhcNLeQKB/gGn1hbrWR221+2ss4+L6VDNUgFbxxmmhcve7ze8lMEMFGDy9qTAqulr4ssG1nGscDNaK9p2GLuTaPu/QY7XylSExQF4UpGUcjsYzUiq7jmjndMF1hGwvMGPQX5AxaOxX88zPuNar++fNsQKaypsdwOqShg5K8vDJ7NZOQPu53gmo0cSQdFRMx6MRaggKaFRvAUB9iW7egHZ2AwDJyzQSwLzfJADJqzQSwLLdWwFIXqeRANbw3mYVSfFOrqYr0MsefVGHbeDnqm+0zO4p80l2l803b6bVihCs2KF5PqUSwOLiTQ7AL+8yn6o2gw44FXkzAPoKc+hmCAHHJt8OQLjeOkLAocpbAAjPsI4QcOByqjDC44b5OcNISYvcZhVf/61W669Q6icrbiy+4nfwLiPCunF02mrk589U8z5bWNSnwm3O5NjnDt9JcLhvPsu8DzCM+RLK7AcZvxyifjnM+GWMSocHtredUEmZEgHi39tLKBFLUyPWJQWEz+86CSRlygUIxt9dQrmY+AEh/B1g/HBfMQ0LBAwR3nMSSMqUCzDguLOEcjHxAwYX73UMvw32Bhh1vK/kcjGlAAxA7nJMCiZawGDk/YXRqtFYTfb7NIfDVBQNGGd8oPAyvDr1/57VKFj09CfvI4512ZsfSvkRzQ+SG86Y5vEc1eh+yjCMFx0IHT/E2V+MkYa+vxr18g+3Zz/nNb3vAtYfOiLS2eDk300I9SeWtZsDgC913WMVgAlr8CXJD3O2EmfHqeiMNWgv7/iM6aw2/PTMvQSwqgUMWqipOrhKPlK4bgsflefcBePQF10/ahV3bP4CxpWhJtdeqjkWUzng45mPWdVxo2KKYiQZj0uRDM4nfMHt41YxZPsTUfssNgkAMHj4RIEVv3yV6KNrkMhrifWD49F4JpoQlTtubWyKnyQQnsGiqEKZcLf9HNunLFffEQgwqgc0qk9brd41Oi6zn86koomDJPuARvIZq/VXdvsCbsaRJkAD+azV+ssDnYzaAa3jPsu1d7BOEAKGu5+zXPsuzx7bT7J93nLt9HVk8KNsX+BE4rilo8haFOW5pfmiiP1eu/H9XBv90xc527SHcyjftBYd4h966w71BkVlFxrjigulKOVauAx5K1xNNqeH2pYFD07vJyQbZwYiDSr6izgCNGQFSF9qKoMrl58pBsCDP8AZOGCsohfWogTPkuaJov5z7Xj7eTYa0oMEzkmabjAXD3GuhDQqCK1sQUkeHQs1OnI5VEa2braRkYcJtLc7wMgjbEaouA9d2YJSPE7qhqKRDLEbCE7DowTEu1meuDYtMWoHEPQly7UflMidUPD458tWa6/LTgeZVg8Ifx6zWn1NVvMms1GA2OcrViuvVvRuUjcg8nncstYz42Nxyax2QOTzhGXaWZOAgMDnq7yrjXQjQ7vXocudWNCW+xm9GjVg2bqlVEvRX+NsfdbbN3rLOjTB3ypezNRE7MUFxAyjY7OeX+fIqXtR9OA6dLyAnB1Bd+c0VWwqp1k5cDm/wTFmrLNCf1yHriha0OpDh+UYIEpO2pROyie5m1AS+d3EaOl6dCV/y372E8J7/Z3mR1SUL0Uz7iTjzfibXjGj+U/63ASWx/rl6nASv0mQOGchc/5uofm0/0JG+uKF5MLBUsYvT8V+CY/8v2VZInuRqynLGb9cScsICJCeOkEywudfv807mJeLptCh9ejqoh3THFHMlaQNT7aSHamp63LMUX2HkLmDqS0PQwdeSlsC9Ut4y/kuGCcTFcDWv8exmHwgiN67Hr2h+LiMuTroWMj1fUKqA0yuwwyuJQcs4AecAEkP+dHj69E1xQeCakElXOx+mpDqUibXGQbXRx3g+oecKcTc0A79bj16Y9GOkGnVTjm6Zzgi5Vwucm1A1/JnRe3awAsX6Eec9qCTizZvQNfZvvvAGYmeJSS6k24L6osPYS/g80k/5oxIMH+A0hvQW4o3DhaVJ9Pmj+cIJj7FckbFicqFDVDgT5yFbaIheOTwU6cww8PgnxWGxtMnfJrxec4WAEOV6KzT0U38XW+mEAuqvFrLZmPbeoEQ6pcs5/Z7W53bi7xuTxMShU9HNxfzsS3mV4Id6R5+zplTwTddoTtOR1O8RZGa7K9lkWxcEvkFAa5sEXPbmlL5cIo+8wTQ8i+t1l6drT2TtHFB5FccC8vVhl44Hd3GU0m1OxgM9IvkRBZcL78m0C2kmcnfPaFCEHu22Hd2ay52d4ByB7mJG9Lr3Wr7SvNLVqWPrVjEOJS4iBzdt1C/hPeGv+HFsvn2gjZvRLdbsCLGpieAFf2WwHdWISvynSAr8jlhRb+zKn1sO8OKLqCsqNsBK/o9ZzYm7/LRNRvRu7i9g8pkh9d2K/oDgS90slqRI77oj1aljw0wrOgAZUVDDljRnzjDQezOR/TMRvRu7vbT3I/N+nqAFb1Mzhix+vo8Wrq7B6jxz5wNO8ZbMdF/NqI7ivycCedqGAB1f7GgWiVaWboJvYfrIjqdCldeIRDewHQRrk4n4hXeeAmr0X7v8FergsemGN7hHZR3uMMB7/A3ztjU0ODRoU3oTitGZH+08ncC470FjcjejsaKETkSqPzDquCxzzCM6D7KiB5wwIhe5RiR4bIx9OwmdFfRqxms4bmFQMCp5Y5/8k534FeXIVcren/RkvPv9eTZp1OC/4stuKk60LZW9AGu/Ba0yJnhInNHM5KdXyv5NyHurxlBSuyPi+yc7fof6yxnBUbXtKIP8ldHEuFRachk7iv3PS0igHZk5us1zhRLbmYOPdWK7uH1NyaSwLua/xDIKhaz9kWGU5ERm88l/i9n1kAXFv29FX2Ee2IzPSZFouG4zdS8TqCby6KmTuj3hDpFvxsxvoEEoOi/VkFUsKsHdHQzytkj8rxBoK2b0Se4m9iTgzElrrJXPzMJbC1M/RwJxw/JnsNe4y2zWr06dWHvzcvllitPJIdMKwesL1VYrlw5uGlWOWBtqZJjkfnq0Ds2o/v4CyK9e3s8rG+km3haeB9QRQD30qxpsa1vMeNuWNPzsPCou5pDad580Fc2o8/xKfUHukpLaQ0HeL7RoRc2o8/zgXu6dpYWeC0bOO6s0Gub0Rf40U2/2yd4WB+ScgZ8HQc85ujR0i3oi3zwgY4LPZ29JQXv4plMYnxUhX7+FnR/AZPx96GSAq9nA3eFB6PxaEYLI/u3oAf4u1zcHV6ft3dvSeE3cODj4Ru6bAt6iLtE5PV7TUwGHk7MIhC+h9Wr1fcEQr0iFwbAGTdahVEdDATYCACxRZNVBDWhvh4z3wOPMGZbJiHk8XUzEQDCjDmWEezyBE06D/h5ubnsFmMMBND8rehx7kSlHOuISrxje5uZR2B8nMmSAsHt32t7c5lvFUGWBEcu1FgwLQhdXtatEoD2snBaegh57L9VY5FVBLVZY+zr8dn/kejF01KEzxti0AA4ZrpkWjRwLjgBnDZdOi1jcOKqjVOmxULH3l4P42vxgJsWT7WKoS7bJHqDXv9OcxCAixKXESDeV8EA0STFpVEpkRGPRDMj4lAyYuM8yXKrIKo1EDZOkqwoXHcL/UZNqV1i56m2lQAkjTQSgLNuJpD0V7JW91jfE3AmRF9lFZfhjZqycon5ctwqmjmANZ1GILyPyZwrOjqWTGWMqyLH2WsqcPZWW8VmeKOmbF5Cpmyl+ISzt4ZAeHcViz3u16kd+8rYWqv4DG/UlB0M+3Pban8tBMInmQxyj247Y4DrrIIzvFFT/JQB9jhggOsJhA3VzJvnpNFBKSWmM6NUZwRgaEPh+lvoN2rKflsN6XQCyQdrWIZUm52UMhDhqBVttIrM8EZNiVJWdMgBK9pEIPySi8mdeonv4TB5Ftsh7lqtIjO8UVOOUtxd5gB3mwmElQ3Me58y4YxpMAjgZ0vh2lvoN2rKdba2v60EkodmsQYH0tGINJYRh2xduTyjcPUt9Bs15RZbiTiTQPIyi4im0XAmMiJGwmlJHIwnsY/qwuk4qzCIFvqNmvJeW+k4m0CyqpHlW6rHwpmMlKL69o5+kbrNBe5ZzrGKy/BGTfko5Vk+7oBnOZdAeBuTOc6epjnZKxfU63VIfuEknmcVouGNmvIAI758yFbzayM7kKJIzN5P4hSJ51uFaHijpnyDQeI3bSWxnUAYb2K24ewewjB5dahD0cE2q7gMb9SUZ6k2/JwDbXg7GfsxmWNuqnOIux1WkRneqCm/obj7nQPcXUAgfGB2MUNDesMvnDu3VWSGN2rKqxR3/3KAuw4C4aVzmceqwqloZmRUykQjBHPkbk44b51WURneaPHrUjKleqmdPq6LwJZk3uM5bH5/O4AXj9W6q3iT6gDhuwsDaKHfqCnzaDUA5pR3ApAsWWr/9yd2EXhuZF5tm70du8froe7pgduH1yqI2iyIDk+IvBkRbiIXFsYAuW2Tf8cRwKAEq7gNb9SU0x0wKB8Az1YWHsAqMwLgOZfCo6a3Ub66nYUcsDbtJ5DfwWoV+YvvnWmdAas4HGydPYUxnJSt8yKruA1v1JTdDrTOIADPgAOtMwTAM8honUNU6xx2oHX2EshfZLUKw92/9sVUfYXrb6HfqClX2RpZ7iaQ7GRea8W459ShEWC/VVyGN2rKJGVDb8vZ0K2+Gep/9g1nxjf9HwSyhGI='
)
MEMO = pickle.loads(zlib.decompress(base64.b64decode(MEMO)))
Shift = 0
Reduce = 1
def Lark_StandAlone(**kwargs):
  return Lark._load_from_dict(DATA, MEMO, **kwargs)
