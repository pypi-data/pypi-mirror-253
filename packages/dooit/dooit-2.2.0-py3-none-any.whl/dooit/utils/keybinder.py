from collections import defaultdict
from typing import DefaultDict, Dict, List, Optional, Union
from dooit.utils.conf_reader import config_man
from copy import deepcopy

customed_keys = config_man.get("keybindings")


class Bind:
    exclude_cursor_check = [
        "add_sibling",
        "change_status",
        "move_down",
        "move_up",
        "switch_pane",
        "spawn_help",
        "switch_pane_workspace",
        "start_search",
        "stop_search",
    ]

    def __init__(self, func_name: str, params: List[str]) -> None:
        self.func_name = func_name
        self.params = params
        self.check_for_cursor = func_name not in self.exclude_cursor_check


KeyList = Dict[str, Union[str, List]]
PRINTABLE = (
    "0123456789"
    + "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    + "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ "
)
DEFAULTS = {
    "switch pane": "<tab>",
    "move up": ["k", "<up>"],
    "shift up": ["K", "<shift+up>"],
    "move down": ["j", "<down>"],
    "shift down": ["J", "<shift+down>"],
    "edit description": "i",
    "toggle expand": "z",
    "toggle expand recursive": "<ctrl+z>",
    "toggle expand parent": "Z",
    "add child": "A",
    "add sibling": "a",
    "remove item": "x",
    "move to top": ["g", "<home>"],
    "move to bottom": ["G", "<end>"],
    "sort menu toggle": "s",
    "start search": "/",
    "spawn help": "?",
    "copy text": "Y",
    "yank": "y",
    "paste": "p",
    "toggle complete": "c",
    "edit due": "d",
    "switch date style": "D",
    "edit recurrence": "r",
    "increase urgency": ["+", "="],
    "decrease urgency": ["-", "_"],
    "switch pane workspace": ["h"],
    "switch pane todo": ["l"],
}

configured_keys = deepcopy(DEFAULTS)
configured_keys.update(customed_keys)


class KeyBinder:
    # KEYBIND MANAGER FOR NORMAL MODE

    def __init__(self) -> None:
        self.pressed = ""
        self.methods: Dict[str, Bind] = {}
        self.raw: DefaultDict[str, List[str]] = defaultdict(list)
        self.add_keys(configured_keys)

    def convert_to_bind(self, cmd: str) -> Bind:
        func_split = cmd.split()
        if func_split[0] == "edit":
            return Bind("start_edit", [func_split[1]])
        else:
            return Bind("_".join(func_split), [])

    def add_keys(self, keys: KeyList) -> None:
        for cmd, key in keys.items():
            if isinstance(key, str):
                key = [key]

            for k in key:
                if k not in self.raw[cmd]:
                    self.raw[cmd].append(k)

                self.methods[k] = self.convert_to_bind(cmd)

    def attach_key(self, key: str) -> None:
        if key == "escape" and self.pressed:
            return self.clear()

        if len(key) > 1:
            key = f"<{key}>"

        self.pressed += key

    def clear(self) -> None:
        self.pressed = ""

    def find_keys(self) -> List[str]:
        possible_bindings = filter(
            lambda keybind: keybind.startswith(self.pressed),
            self.methods.keys(),
        )
        return list(possible_bindings)

    def get_method(self) -> Optional[Bind]:
        possible_keys = self.find_keys()
        if self.pressed and possible_keys:
            if len(possible_keys) == 1 and possible_keys[0] == self.pressed:
                method = self.methods.get(possible_keys[0])
                self.clear()
                return method
            else:
                return Bind("change_status", ["K PENDING"])
        else:
            self.clear()
            return Bind("change_status", ["NORMAL"])
