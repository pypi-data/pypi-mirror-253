"""Fluent solver TUI commands"""
#
# This is an auto-generated file.  DO NOT EDIT!
#
# pylint: disable=line-too-long

from ansys.fluent.core.services.datamodel_tui import PyMenu, TUIMenu



class main_menu(TUIMenu):
    """
    Fluent solver main menu.
    """
    def __init__(self, service, version, mode, path):
        self._service = service
        self._version = version
        self._mode = mode
        self._path = path
        self.server = self.__class__.server(service, version, mode, path + ["server"])
        self.turbo_workflow = self.__class__.turbo_workflow(service, version, mode, path + ["turbo_workflow"])
        self.icing = self.__class__.icing(service, version, mode, path + ["icing"])
        self.define = self.__class__.define(service, version, mode, path + ["define"])
        self.turbo_post = self.__class__.turbo_post(service, version, mode, path + ["turbo_post"])
        self.display = self.__class__.display(service, version, mode, path + ["display"])
        self.results = self.__class__.results(service, version, mode, path + ["results"])
        self.adjoint = self.__class__.adjoint(service, version, mode, path + ["adjoint"])
        self.solution = self.__class__.solution(service, version, mode, path + ["solution"])
        self.setup = self.__class__.setup(service, version, mode, path + ["setup"])
        self.preferences = self.__class__.preferences(service, version, mode, path + ["preferences"])
        self.parametric_study = self.__class__.parametric_study(service, version, mode, path + ["parametric_study"])
        self.views = self.__class__.views(service, version, mode, path + ["views"])
        self.mesh = self.__class__.mesh(service, version, mode, path + ["mesh"])
        self.file = self.__class__.file(service, version, mode, path + ["file"])
        self.report = self.__class__.report(service, version, mode, path + ["report"])
        self.parallel = self.__class__.parallel(service, version, mode, path + ["parallel"])
        self.solve = self.__class__.solve(service, version, mode, path + ["solve"])
        self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
        self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
        super().__init__(service, version, mode, path)
    def close_fluent(self, *args, **kwargs):
        """
        Exit program.
        """
        return PyMenu(self._service, self._version, self._mode, "/close_fluent").execute(*args, **kwargs)
    def exit(self, *args, **kwargs):
        """
        Exit program.
        """
        return PyMenu(self._service, self._version, self._mode, "/exit").execute(*args, **kwargs)
    def print_license_usage(self, *args, **kwargs):
        """
        Print license usage information.
        """
        return PyMenu(self._service, self._version, self._mode, "/print_license_usage").execute(*args, **kwargs)
    def switch_to_meshing_mode(self, *args, **kwargs):
        """
        Switches from the solution mode to the meshing mode. This text command is only available if you have not yet read a mesh or a case file.
        """
        return PyMenu(self._service, self._version, self._mode, "/switch_to_meshing_mode").execute(*args, **kwargs)

    class server(TUIMenu):
        """
        Enter the server menu.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            super().__init__(service, version, mode, path)
        def start_client(self, *args, **kwargs):
            """
            Start the ANSYS Fluent remote visualization client.
            """
            return PyMenu(self._service, self._version, self._mode, "/server/start_client").execute(*args, **kwargs)
        def print_connected_clients(self, *args, **kwargs):
            """
            Prints the name of the connected client and its IP address to the console.
            """
            return PyMenu(self._service, self._version, self._mode, "/server/print_connected_clients").execute(*args, **kwargs)
        def print_server_address(self, *args, **kwargs):
            """
            Prints the host address and port number of the server to the console.
            """
            return PyMenu(self._service, self._version, self._mode, "/server/print_server_address").execute(*args, **kwargs)
        def start_server(self, *args, **kwargs):
            """
            Starts the server for the ANSYS Fluent remote visualization client.
            """
            return PyMenu(self._service, self._version, self._mode, "/server/start_server").execute(*args, **kwargs)
        def print_web_server_info(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/server/print_web_server_info").execute(*args, **kwargs)
        def start_web_server(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/server/start_web_server").execute(*args, **kwargs)
        def shutdown_server(self, *args, **kwargs):
            """
            Shuts-down the server and disconnects the connected client.
            """
            return PyMenu(self._service, self._version, self._mode, "/server/shutdown_server").execute(*args, **kwargs)
        def write_or_reset_server_info(self, *args, **kwargs):
            """
            Allows you to create a new server_info.txt file (with any name you specify), which resets the password for connecting to this server session. It does not restart the server.
            """
            return PyMenu(self._service, self._version, self._mode, "/server/write_or_reset_server_info").execute(*args, **kwargs)
        def stop_web_server(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/server/stop_web_server").execute(*args, **kwargs)

    class turbo_workflow(TUIMenu):
        """
        Enter the turbo workflow menu.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            self.workflow = self.__class__.workflow(service, version, mode, path + ["workflow"])
            super().__init__(service, version, mode, path)

        class workflow(TUIMenu):
            """
            Enter the workflow menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def disable(self, *args, **kwargs):
                """
                Disable the workflow.
                """
                return PyMenu(self._service, self._version, self._mode, "/turbo_workflow/workflow/disable").execute(*args, **kwargs)
            def enable(self, *args, **kwargs):
                """
                Enable the workflow.
                """
                return PyMenu(self._service, self._version, self._mode, "/turbo_workflow/workflow/enable").execute(*args, **kwargs)
            def reset(self, *args, **kwargs):
                """
                Reset the workflow.
                """
                return PyMenu(self._service, self._version, self._mode, "/turbo_workflow/workflow/reset").execute(*args, **kwargs)

    class icing(TUIMenu):
        """
        FENSAP-ICE options.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            super().__init__(service, version, mode, path)
        def drop(self, *args, **kwargs):
            """
            Droplet impingement menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/icing/drop").execute(*args, **kwargs)
        def settings(self, *args, **kwargs):
            """
            Global settings menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/icing/settings").execute(*args, **kwargs)
        def file(self, *args, **kwargs):
            """
            File menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/icing/file").execute(*args, **kwargs)
        def ice(self, *args, **kwargs):
            """
            Ice accretion menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/icing/ice").execute(*args, **kwargs)
        def flow(self, *args, **kwargs):
            """
            Flow solver menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/icing/flow").execute(*args, **kwargs)
        def multishot(self, *args, **kwargs):
            """
            Multi-shot accretion menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/icing/multishot").execute(*args, **kwargs)

    class define(TUIMenu):
        """
        Enter the define menu.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            self.reference_frames = self.__class__.reference_frames(service, version, mode, path + ["reference_frames"])
            self.spectral = self.__class__.spectral(service, version, mode, path + ["spectral"])
            self.custom_field_functions = self.__class__.custom_field_functions(service, version, mode, path + ["custom_field_functions"])
            self.user_defined = self.__class__.user_defined(service, version, mode, path + ["user_defined"])
            self.operating_conditions = self.__class__.operating_conditions(service, version, mode, path + ["operating_conditions"])
            self.phases = self.__class__.phases(service, version, mode, path + ["phases"])
            self.dynamic_mesh = self.__class__.dynamic_mesh(service, version, mode, path + ["dynamic_mesh"])
            self.named_expressions = self.__class__.named_expressions(service, version, mode, path + ["named_expressions"])
            self.virtual_boundary = self.__class__.virtual_boundary(service, version, mode, path + ["virtual_boundary"])
            self.periodic_conditions = self.__class__.periodic_conditions(service, version, mode, path + ["periodic_conditions"])
            self.turbo_model = self.__class__.turbo_model(service, version, mode, path + ["turbo_model"])
            self.mesh_interfaces = self.__class__.mesh_interfaces(service, version, mode, path + ["mesh_interfaces"])
            self.profiles = self.__class__.profiles(service, version, mode, path + ["profiles"])
            self.models = self.__class__.models(service, version, mode, path + ["models"])
            self.curvilinear_coordinate_system = self.__class__.curvilinear_coordinate_system(service, version, mode, path + ["curvilinear_coordinate_system"])
            self.parameters = self.__class__.parameters(service, version, mode, path + ["parameters"])
            self.overset_interfaces = self.__class__.overset_interfaces(service, version, mode, path + ["overset_interfaces"])
            self.materials = self.__class__.materials(service, version, mode, path + ["materials"])
            self.mixing_planes = self.__class__.mixing_planes(service, version, mode, path + ["mixing_planes"])
            self.gap_model = self.__class__.gap_model(service, version, mode, path + ["gap_model"])
            self.solution_strategy = self.__class__.solution_strategy(service, version, mode, path + ["solution_strategy"])
            super().__init__(service, version, mode, path)
        def boundary_conditions(self, *args, **kwargs):
            """
            Enter the boundary conditions menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/define/boundary_conditions").execute(*args, **kwargs)
        def units(self, *args, **kwargs):
            """
            Sets unit conversion factors.
            """
            return PyMenu(self._service, self._version, self._mode, "/define/units").execute(*args, **kwargs)
        def geometry(self, *args, **kwargs):
            """
            Enter Geometry menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/define/geometry").execute(*args, **kwargs)
        def physics(self, *args, **kwargs):
            """
            Manage Physics-regions.
            """
            return PyMenu(self._service, self._version, self._mode, "/define/physics").execute(*args, **kwargs)
        def injections(self, *args, **kwargs):
            """
            Enters the injections menu.  For a description of the items in this menu, see define/models/dpm/injections.
            """
            return PyMenu(self._service, self._version, self._mode, "/define/injections").execute(*args, **kwargs)
        def set_unit_system(self, *args, **kwargs):
            """
            Applies a standard set of units to all quantities. The options include default,si, british, andcgs.
            """
            return PyMenu(self._service, self._version, self._mode, "/define/set_unit_system").execute(*args, **kwargs)
        def enable_mesh_morpher_optimizer(self, *args, **kwargs):
            """
            Enables the mesh morpher/optimizer. When the mesh morpher/optimizer is enabled, the define/mesh-morpher-optimizer text command becomes available.
            """
            return PyMenu(self._service, self._version, self._mode, "/define/enable_mesh_morpher_optimizer").execute(*args, **kwargs)
        def enable_expressions(self, *args, **kwargs):
            """
            Enable the expressions feature.
            """
            return PyMenu(self._service, self._version, self._mode, "/define/enable_expressions").execute(*args, **kwargs)
        def beta_feature_access(self, *args, **kwargs):
            """
            Enable access to beta features in the interface.
            """
            return PyMenu(self._service, self._version, self._mode, "/define/beta_feature_access").execute(*args, **kwargs)

        class reference_frames(TUIMenu):
            """
            Enters the reference frames menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def delete(self, *args, **kwargs):
                """
                Deletes the reference frame you specify.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/reference_frames/delete").execute(*args, **kwargs)
            def add(self, *args, **kwargs):
                """
                Creates a new reference frame.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/reference_frames/add").execute(*args, **kwargs)
            def hide(self, *args, **kwargs):
                """
                Removes the specified reference frame from the graphics window.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/reference_frames/hide").execute(*args, **kwargs)
            def display_edit(self, *args, **kwargs):
                """
                Display and edit reference frame from graphics.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/reference_frames/display_edit").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                Lists all of the reference frames.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/reference_frames/list").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Displays the reference frame you specify.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/reference_frames/display").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Allows you to edit a reference frame.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/reference_frames/edit").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                Lists the properties of the reference frame you specify.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/reference_frames/list_properties").execute(*args, **kwargs)

        class spectral(TUIMenu):
            """
            Enter the Spectral menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def calculate_fourier_coefficients(self, *args, **kwargs):
                """
                Calculates Fourier coefficient data.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/spectral/calculate_fourier_coefficients").execute(*args, **kwargs)
            def delete_harmonic_exports(self, *args, **kwargs):
                """
                Deletes Harmonic Export data.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/spectral/delete_harmonic_exports").execute(*args, **kwargs)
            def delete_fourier_coefficients(self, *args, **kwargs):
                """
                Deletes Fourier coefficient data.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/spectral/delete_fourier_coefficients").execute(*args, **kwargs)
            def calculate_harmonic_exports(self, *args, **kwargs):
                """
                Calculates Harmonic Export data.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/spectral/calculate_harmonic_exports").execute(*args, **kwargs)

        class custom_field_functions(TUIMenu):
            """
            Enters the custom field functions menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def save(self, *args, **kwargs):
                """
                Saves a custom field function.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/custom_field_functions/save").execute(*args, **kwargs)
            def list_valid_cell_function_names(self, *args, **kwargs):
                """
                Lists the names of cell functions that can be used in a custom field function.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/custom_field_functions/list_valid_cell_function_names").execute(*args, **kwargs)
            def example_cff_definitions(self, *args, **kwargs):
                """
                Lists example custom field functions.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/custom_field_functions/example_cff_definitions").execute(*args, **kwargs)
            def define(self, *args, **kwargs):
                """
                Defines a custom field function.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/custom_field_functions/define").execute(*args, **kwargs)
            def load(self, *args, **kwargs):
                """
                Loads a custom field function.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/custom_field_functions/load").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Deletes a custom field function.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/custom_field_functions/delete").execute(*args, **kwargs)

        class user_defined(TUIMenu):
            """
            Enters the user-defined functions and scalars menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.real_gas_models = self.__class__.real_gas_models(service, version, mode, path + ["real_gas_models"])
                super().__init__(service, version, mode, path)
            def auto_compile_compiled_udfs(self, *args, **kwargs):
                """
                For this Fluent session, specify whether to allow auto-compilation of compiled UDF when a case file (or settings file) is read.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/user_defined/auto_compile_compiled_udfs").execute(*args, **kwargs)
            def function_hooks(self, *args, **kwargs):
                """
                Hooks up user-defined functions.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/user_defined/function_hooks").execute(*args, **kwargs)
            def compiled_functions(self, *args, **kwargs):
                """
                Opens user-defined function library.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/user_defined/compiled_functions").execute(*args, **kwargs)
            def use_contributed_cpp(self, *args, **kwargs):
                """
                Enable/disable use of cpp from the Fluent.Inc/contrib directory.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/user_defined/use_contributed_cpp").execute(*args, **kwargs)
            def use_zone_based_udm(self, *args, **kwargs):
                """
                Zone based user-defined memory.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/user_defined/use_zone_based_udm").execute(*args, **kwargs)
            def enable_udf_on_gpu(self, *args, **kwargs):
                """
                Compile UDFs with OpenCL support.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/user_defined/enable_udf_on_gpu").execute(*args, **kwargs)
            def user_defined_node_memory(self, *args, **kwargs):
                """
                Allocate user-defined node memory.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/user_defined/user_defined_node_memory").execute(*args, **kwargs)
            def execute_on_demand(self, *args, **kwargs):
                """
                Executes UDFs on demand.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/user_defined/execute_on_demand").execute(*args, **kwargs)
            def use_built_in_compiler(self, *args, **kwargs):
                """
                Enables/disables the use of a built-in compiler (Clang) when the define/user-defined/compiled-functions text command is used. This text command / compiler is available for Windows only, and is provided as part of the ANSYS Fluent installation. It is recommended that you enable this text command when the compiler you installed on your machine is an older version that is no longer supported. Note that the built-in compiler is used automatically if Fluent determines that you have not installed Microsoft Visual Studio or Clang on your computer, whether this text command is enabled or not.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/user_defined/use_built_in_compiler").execute(*args, **kwargs)
            def fan_model(self, *args, **kwargs):
                """
                Configures user-defined fan model.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/user_defined/fan_model").execute(*args, **kwargs)
            def one_D_coupling(self, *args, **kwargs):
                """
                Load 1D library.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/user_defined/one_D_coupling").execute(*args, **kwargs)
            def user_defined_memory(self, *args, **kwargs):
                """
                Allocates user-defined memory.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/user_defined/user_defined_memory").execute(*args, **kwargs)
            def compile_customized_addon_module(self, *args, **kwargs):
                """
                Compile customized addon module?.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/user_defined/compile_customized_addon_module").execute(*args, **kwargs)
            def user_defined_scalars(self, *args, **kwargs):
                """
                Defines user-defined scalars.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/user_defined/user_defined_scalars").execute(*args, **kwargs)
            def interpreted_functions(self, *args, **kwargs):
                """
                Loads interpreted user-defined functions.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/user_defined/interpreted_functions").execute(*args, **kwargs)

            class real_gas_models(TUIMenu):
                """
                Enters the real-gas menu to enable/configure real gas model.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def nist_settings(self, *args, **kwargs):
                    """
                    Specifies the name and the location for the REFPROP library and fluid files.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/user_defined/real_gas_models/nist_settings").execute(*args, **kwargs)
                def set_state(self, *args, **kwargs):
                    """
                    Selects the state for NIST real gas model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/user_defined/real_gas_models/set_state").execute(*args, **kwargs)
                def nist_real_gas_model(self, *args, **kwargs):
                    """
                    Loads the NIST real-gas library.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/user_defined/real_gas_models/nist_real_gas_model").execute(*args, **kwargs)
                def user_defined_real_gas_model(self, *args, **kwargs):
                    """
                    Loads the user-defined real-gas library.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/user_defined/real_gas_models/user_defined_real_gas_model").execute(*args, **kwargs)
                def user_defined_multispecies_real_gas_model(self, *args, **kwargs):
                    """
                    Loads a user-defined multispecies real-gas library.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/user_defined/real_gas_models/user_defined_multispecies_real_gas_model").execute(*args, **kwargs)
                def nist_multispecies_real_gas_model(self, *args, **kwargs):
                    """
                    Loads the NIST real-gas library.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/user_defined/real_gas_models/nist_multispecies_real_gas_model").execute(*args, **kwargs)

        class operating_conditions(TUIMenu):
            """
            Enters the define operating conditions menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def operating_density(self, *args, **kwargs):
                """
                Multiphase flow Operating Density menu.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/operating_conditions/operating_density").execute(*args, **kwargs)
            def use_inlet_temperature_for_operating_density(self, *args, **kwargs):
                """
                Uses inlet temperature to calculate operating density.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/operating_conditions/use_inlet_temperature_for_operating_density").execute(*args, **kwargs)
            def set_state(self, *args, **kwargs):
                """
                Selects state for real gas EOS subcritical condition.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/operating_conditions/set_state").execute(*args, **kwargs)
            def used_ref_pressure_location(self, *args, **kwargs):
                """
                Prints the coordinates of the reference pressure cell or cells (depending on the selected reference pressure method). The pressure value in such cells can be used to adjust the gauge pressure field after each iteration to keep it from floating.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/operating_conditions/used_ref_pressure_location").execute(*args, **kwargs)
            def operating_pressure(self, *args, **kwargs):
                """
                Sets the operating pressure.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/operating_conditions/operating_pressure").execute(*args, **kwargs)
            def operating_temperature(self, *args, **kwargs):
                """
                Sets the operating temperature for Boussinesq.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/operating_conditions/operating_temperature").execute(*args, **kwargs)
            def gravity(self, *args, **kwargs):
                """
                Sets gravitational acceleration.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/operating_conditions/gravity").execute(*args, **kwargs)
            def gravity_mrf_behavior(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/define/operating_conditions/gravity_mrf_behavior").execute(*args, **kwargs)
            def reference_pressure_method(self, *args, **kwargs):
                """
                Specifies the method used for adjusting the gauge pressure field after each iteration to keep it from floating: the method can assume that all of the cell zones are connected by internal boundary zones (such as interior zones), or can account for connected and disconnected cell zones. Such adjustment is only allowed for incompressible flows, and will be limited partially or entirely by the presence of a pressure boundary.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/operating_conditions/reference_pressure_method").execute(*args, **kwargs)
            def reference_pressure_location(self, *args, **kwargs):
                """
                Sets a location that determines the reference pressure cell or cells (depending on the selected reference pressure method). The pressure value in such cells can be used to adjust the gauge pressure field after each iteration to keep it from floating.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/operating_conditions/reference_pressure_location").execute(*args, **kwargs)

        class phases(TUIMenu):
            """
            Enters the phases menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.set_domain_properties = self.__class__.set_domain_properties(service, version, mode, path + ["set_domain_properties"])
                self.iac_expert = self.__class__.iac_expert(service, version, mode, path + ["iac_expert"])
                super().__init__(service, version, mode, path)
            def interaction_domain(self, *args, **kwargs):
                """
                Enter the menu to set interaction domain properties.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/phases/interaction_domain").execute(*args, **kwargs)
            def phase_domain(self, *args, **kwargs):
                """
                Enter the menu to set phase domain properties.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/phases/phase_domain").execute(*args, **kwargs)

            class set_domain_properties(TUIMenu):
                """
                Enters the menu to set phase domain properties.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.interaction_domain = self.__class__.interaction_domain(service, version, mode, path + ["interaction_domain"])
                    super().__init__(service, version, mode, path)
                def phase_domains(self, *args, **kwargs):
                    """
                    Enters the menu to select a specific phase.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/phase_domains").execute(*args, **kwargs)
                def change_phases_names(self, *args, **kwargs):
                    """
                    Allows you to change the names of all the phases in your simulation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/change_phases_names").execute(*args, **kwargs)

                class interaction_domain(TUIMenu):
                    """
                    Enters the menu to set the interaction domain 	properties.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.numerics = self.__class__.numerics(service, version, mode, path + ["numerics"])
                        self.forces = self.__class__.forces(service, version, mode, path + ["forces"])
                        self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                        self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                        self.heat_mass_reactions = self.__class__.heat_mass_reactions(service, version, mode, path + ["heat_mass_reactions"])
                        super().__init__(service, version, mode, path)

                    class numerics(TUIMenu):
                        """
                        Enters the menu to set numerics models. This menu is available for multiphase models with the sharp-dispersed and phase localized discretization interface modeling options (set in define/models/multiphase/interface-modeling-options).
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                            self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                            self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                            self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                            self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                            super().__init__(service, version, mode, path)
                        def restitution(self, *args, **kwargs):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/restitution").execute(*args, **kwargs)
                        def turbulent_dispersion(self, *args, **kwargs):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/turbulent_dispersion").execute(*args, **kwargs)
                        def interfacial_area(self, *args, **kwargs):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interfacial_area").execute(*args, **kwargs)
                        def turbulence_interaction(self, *args, **kwargs):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/turbulence_interaction").execute(*args, **kwargs)
                        def heat_coeff(self, *args, **kwargs):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/heat_coeff").execute(*args, **kwargs)
                        def slip_velocity(self, *args, **kwargs):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/slip_velocity").execute(*args, **kwargs)
                        def reactions(self, *args, **kwargs):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/reactions").execute(*args, **kwargs)
                        def model_transition(self, *args, **kwargs):
                            """
                            Set the model transition mechanism.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/model_transition").execute(*args, **kwargs)
                        def mass_transfer(self, *args, **kwargs):
                            """
                            Specify the mass transfer mechanisms.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/mass_transfer").execute(*args, **kwargs)
                        def wall_lubrication(self, *args, **kwargs):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/wall_lubrication").execute(*args, **kwargs)
                        def drag(self, *args, **kwargs):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/drag").execute(*args, **kwargs)

                        class interphase_discretization(TUIMenu):
                            """
                            Enters the menu to set interphase discretization models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/cavitation").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/lift").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specifies the slope limiter to set a specific discretization scheme for each phase pair. A value of 0 corresponds to first order upwind, a value of 1 corresponds to second order upwind, a value of 2 applies the compressive scheme, and a value between 0 and 2 corresponds to a blended scheme. This option is available only wheninterphase-discr? is enabled.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/wall_adhesion").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enables/disables phase localized compressive scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/vmass_implicit").execute(*args, **kwargs)

                        class interphase_viscous_dissipation(TUIMenu):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)

                        class cavitation(TUIMenu):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/vmass_implicit").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/lift").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/sfc_modeling").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/interphase_discr").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/slope_limiter").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/lift_montoya").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/virtual_mass").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/wall_adhesion").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/visc_disp_factor").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/cavitation").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/jump_adhesion").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/interphase_visc_disp").execute(*args, **kwargs)

                        class virtual_mass(TUIMenu):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/lift_montoya").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/slope_limiter").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/cavitation").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/lift").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/virtual_mass").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/wall_adhesion").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/interphase_discr").execute(*args, **kwargs)

                        class lift(TUIMenu):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/vmass_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/slope_limiter").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/interphase_discr").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/vmass_implicit_options").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/lift").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/virtual_mass").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/lift_shaver_podowski").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/vmass_implicit").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/lift_montoya").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/sfc_tension_coeff").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/jump_adhesion").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/sfc_modeling").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/sfc_model_type").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/interphase_visc_disp").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/visc_disp_factor").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/wall_adhesion").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/cavitation").execute(*args, **kwargs)

                        class surface_tension(TUIMenu):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/sfc_model_type").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/jump_adhesion").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/cavitation").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/vmass_implicit").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/interphase_discr").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/slope_limiter").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/wall_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/lift").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/sfc_modeling").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/lift_montoya").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/vmass_coeff").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/virtual_mass").execute(*args, **kwargs)

                    class forces(TUIMenu):
                        """
                        Enters the menu to set interfacial forces models.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                            self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                            self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                            self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                            self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                            super().__init__(service, version, mode, path)
                        def turbulence_interaction(self, *args, **kwargs):
                            """
                            Specifies the turbulence interaction model for each primary-secondary phase pair. This command is available only with the Eulerian multiphase model.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/turbulence_interaction").execute(*args, **kwargs)
                        def reactions(self, *args, **kwargs):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/reactions").execute(*args, **kwargs)
                        def model_transition(self, *args, **kwargs):
                            """
                            Set the model transition mechanism.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/model_transition").execute(*args, **kwargs)
                        def mass_transfer(self, *args, **kwargs):
                            """
                            Specify the mass transfer mechanisms.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/mass_transfer").execute(*args, **kwargs)
                        def heat_coeff(self, *args, **kwargs):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/heat_coeff").execute(*args, **kwargs)
                        def wall_lubrication(self, *args, **kwargs):
                            """
                            Specifies the wall lubrication model for each primary-secondary phase pair. This command is available only with the Eulerian multiphase model.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/wall_lubrication").execute(*args, **kwargs)
                        def restitution(self, *args, **kwargs):
                            """
                            Specifies the restitution coefficient for collisions between each pair of granular phases, and for collisions between particles of the same granular phase. This command is available only for multiphase flows with two or more granular phases.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/restitution").execute(*args, **kwargs)
                        def slip_velocity(self, *args, **kwargs):
                            """
                            Specifies the slip velocity function for each secondary phase with respect to the primary phase. This command is available only for the Mixture multiphase model.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/slip_velocity").execute(*args, **kwargs)
                        def drag(self, *args, **kwargs):
                            """
                            Specifies the drag function, drag modification, and drag factor for each pair of phases. This command is available only with the Eulerian and Mixture multiphase models.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/drag").execute(*args, **kwargs)
                        def interfacial_area(self, *args, **kwargs):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interfacial_area").execute(*args, **kwargs)
                        def turbulent_dispersion(self, *args, **kwargs):
                            """
                            Specifies the turbulent dispersion model for each primary-secondary phase pair. This command is available only with the Eulerian multiphase model.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/turbulent_dispersion").execute(*args, **kwargs)

                        class virtual_mass(TUIMenu):
                            """
                            Enters the menu to set virtual mass models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enables/disables the implicit method for the virtual mass force. This option can improve convergence in some cases. This option is available only if virtual-mass? is enabled.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/cavitation").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/slope_limiter").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/interphase_discr").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Allows you to include the virtual mass force effect that occurs when a secondary phase accelerates relative to the primary phase. This command is available only with the Eulerian multiphase model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/virtual_mass").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/lift").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/wall_adhesion").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Specifies what form of the implicit method to use (default, option-2, or option-3). default models the entire virtual mass force while option-2 and option-3 model truncated expressions which may further improve convergence. This option is available only if vmass-implicit? is enabled.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/lift_montoya").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specifies the virtual mass coefficient for each pair of phases. This option is available only ifvirtual-mass? is enabled.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/jump_adhesion").execute(*args, **kwargs)

                        class cavitation(TUIMenu):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/jump_adhesion").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/sfc_modeling").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/wall_adhesion").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/vmass_coeff").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/visc_disp_factor").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/interphase_discr").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/lift").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/virtual_mass").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/lift_montoya").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/vmass_implicit").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/cavitation").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/slope_limiter").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/sfc_model_type").execute(*args, **kwargs)

                        class interphase_viscous_dissipation(TUIMenu):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)

                        class surface_tension(TUIMenu):
                            """
                            Enters the menu to set surface tension models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/interphase_discr").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/cavitation").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/slope_limiter").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specifies the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enables/disables the treatment of the contact angle specification at the porous jump boundary. This command is available only for the VOF multiphase model with the continuum surface stress model option and when sfc-modeling? is enabled.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/jump_adhesion").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/lift").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/virtual_mass").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enables/disables the specification for a wall adhesion angle. This item is available only whensfc-modeling? is enabled.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/wall_adhesion").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Selects the surface tension model. You can choose between the continuum surface force and continuum surface stress methods. This item is available only when sfc-modeling? is enabled.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Allows you to include the effects of surface tension along the fluid-fluid interface. This option is only available for the VOF and Eulerian multiphase models.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/sfc_modeling").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/vmass_implicit").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/lift_montoya").execute(*args, **kwargs)

                        class interphase_discretization(TUIMenu):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/wall_adhesion").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/lift").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/cavitation").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)

                        class lift(TUIMenu):
                            """
                            Enters the menu to set the lift force. This item is available only with the Eulerian multiphase model.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/sfc_tension_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/vmass_implicit_options").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/visc_disp_factor").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/interphase_visc_disp").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/sfc_model_type").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/lift_montoya").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/sfc_modeling").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/vmass_implicit").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/vmass_coeff").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/jump_adhesion").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/wall_adhesion").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/cavitation").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                Specifies the lift function for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/lift").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Enables/disables the Shaver-Podowski lift correction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/forces/lift/lift_shaver_podowski").execute(*args, **kwargs)

                    class interfacial_area(TUIMenu):
                        """
                        Enters the menu to set interfacial area models. This menu is available only for the Mixture and Eulerian multiphase models.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                            self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                            self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                            self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                            self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                            super().__init__(service, version, mode, path)
                        def mass_transfer(self, *args, **kwargs):
                            """
                            Specify the mass transfer mechanisms.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/mass_transfer").execute(*args, **kwargs)
                        def restitution(self, *args, **kwargs):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/restitution").execute(*args, **kwargs)
                        def wall_lubrication(self, *args, **kwargs):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/wall_lubrication").execute(*args, **kwargs)
                        def reactions(self, *args, **kwargs):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/reactions").execute(*args, **kwargs)
                        def turbulence_interaction(self, *args, **kwargs):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/turbulence_interaction").execute(*args, **kwargs)
                        def heat_coeff(self, *args, **kwargs):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/heat_coeff").execute(*args, **kwargs)
                        def turbulent_dispersion(self, *args, **kwargs):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/turbulent_dispersion").execute(*args, **kwargs)
                        def slip_velocity(self, *args, **kwargs):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/slip_velocity").execute(*args, **kwargs)
                        def interfacial_area(self, *args, **kwargs):
                            """
                            Specifies the interfacial area model for each pair of phases.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interfacial_area").execute(*args, **kwargs)
                        def drag(self, *args, **kwargs):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/drag").execute(*args, **kwargs)
                        def model_transition(self, *args, **kwargs):
                            """
                            Set the model transition mechanism.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/model_transition").execute(*args, **kwargs)

                        class surface_tension(TUIMenu):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/lift").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/cavitation").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/sfc_modeling").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/jump_adhesion").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/sfc_model_type").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/wall_adhesion").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/vmass_implicit").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/lift_montoya").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/vmass_coeff").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/interphase_discr").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/slope_limiter").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/interphase_visc_disp").execute(*args, **kwargs)

                        class virtual_mass(TUIMenu):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/lift").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/interphase_discr").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/lift_montoya").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/virtual_mass").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/cavitation").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/wall_adhesion").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/slope_limiter").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)

                        class lift(TUIMenu):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/sfc_modeling").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/vmass_implicit_options").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/virtual_mass").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/cavitation").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/wall_adhesion").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/jump_adhesion").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/visc_disp_factor").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/slope_limiter").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/vmass_coeff").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/sfc_tension_coeff").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/interphase_discr").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/sfc_model_type").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/lift").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/lift_shaver_podowski").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/interphase_visc_disp").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/lift_montoya").execute(*args, **kwargs)

                        class interphase_viscous_dissipation(TUIMenu):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)

                        class interphase_discretization(TUIMenu):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/wall_adhesion").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/cavitation").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/lift").execute(*args, **kwargs)

                        class cavitation(TUIMenu):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/interphase_discr").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/lift_montoya").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/wall_adhesion").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/slope_limiter").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/lift").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/sfc_model_type").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/cavitation").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/virtual_mass").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/jump_adhesion").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/vmass_implicit").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/lift_shaver_podowski").execute(*args, **kwargs)

                    class model_transition(TUIMenu):
                        """
                        Enters the menu to set model transition mechanisms.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                            self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                            self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                            self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                            self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                            super().__init__(service, version, mode, path)
                        def drag(self, *args, **kwargs):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/drag").execute(*args, **kwargs)
                        def heat_coeff(self, *args, **kwargs):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/heat_coeff").execute(*args, **kwargs)
                        def wall_lubrication(self, *args, **kwargs):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/wall_lubrication").execute(*args, **kwargs)
                        def reactions(self, *args, **kwargs):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/reactions").execute(*args, **kwargs)
                        def turbulence_interaction(self, *args, **kwargs):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/turbulence_interaction").execute(*args, **kwargs)
                        def model_transition(self, *args, **kwargs):
                            """
                            Sets the VOF-to-DPM model transition mechanism.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/model_transition").execute(*args, **kwargs)
                        def restitution(self, *args, **kwargs):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/restitution").execute(*args, **kwargs)
                        def mass_transfer(self, *args, **kwargs):
                            """
                            Specify the mass transfer mechanisms.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/mass_transfer").execute(*args, **kwargs)
                        def interfacial_area(self, *args, **kwargs):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interfacial_area").execute(*args, **kwargs)
                        def slip_velocity(self, *args, **kwargs):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/slip_velocity").execute(*args, **kwargs)
                        def turbulent_dispersion(self, *args, **kwargs):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/turbulent_dispersion").execute(*args, **kwargs)

                        class interphase_discretization(TUIMenu):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/lift").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/cavitation").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/wall_adhesion").execute(*args, **kwargs)

                        class surface_tension(TUIMenu):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/cavitation").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/sfc_model_type").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/slope_limiter").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/sfc_modeling").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/virtual_mass").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/wall_adhesion").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/jump_adhesion").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/vmass_implicit").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/interphase_discr").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/lift_montoya").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/vmass_coeff").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/lift").execute(*args, **kwargs)

                        class interphase_viscous_dissipation(TUIMenu):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)

                        class virtual_mass(TUIMenu):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/wall_adhesion").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/cavitation").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/interphase_discr").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/slope_limiter").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/virtual_mass").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/lift_montoya").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/lift").execute(*args, **kwargs)

                        class lift(TUIMenu):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/visc_disp_factor").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/interphase_discr").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/lift_montoya").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/cavitation").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/vmass_coeff").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/lift_shaver_podowski").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/lift").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/virtual_mass").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/vmass_implicit").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/sfc_tension_coeff").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/interphase_visc_disp").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/sfc_modeling").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/wall_adhesion").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/vmass_implicit_options").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/sfc_model_type").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/slope_limiter").execute(*args, **kwargs)

                        class cavitation(TUIMenu):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/vmass_coeff").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/lift_montoya").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/jump_adhesion").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/sfc_modeling").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/lift").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/cavitation").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/slope_limiter").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/wall_adhesion").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/sfc_model_type").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/vmass_implicit").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/interphase_discr").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/visc_disp_factor").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/virtual_mass").execute(*args, **kwargs)

                    class heat_mass_reactions(TUIMenu):
                        """
                        Enters the menu to set heat, mass-transfer, and reaction models.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                            self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                            self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                            self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                            self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                            self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                            super().__init__(service, version, mode, path)
                        def model_transition(self, *args, **kwargs):
                            """
                            Set the model transition mechanism.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/model_transition").execute(*args, **kwargs)
                        def turbulent_dispersion(self, *args, **kwargs):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/turbulent_dispersion").execute(*args, **kwargs)
                        def restitution(self, *args, **kwargs):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/restitution").execute(*args, **kwargs)
                        def wall_lubrication(self, *args, **kwargs):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/wall_lubrication").execute(*args, **kwargs)
                        def heat_coeff(self, *args, **kwargs):
                            """
                            Species the heat transfer coefficient function between each pair of phases (constant-htc, nusselt-number, ranz-marshall, hughmark, tomiyama, fixed-to-sat-temp, two-resistance, or user-defined). This command is enable only with the Eulerian multiphase model.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/heat_coeff").execute(*args, **kwargs)
                        def drag(self, *args, **kwargs):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/drag").execute(*args, **kwargs)
                        def turbulence_interaction(self, *args, **kwargs):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/turbulence_interaction").execute(*args, **kwargs)
                        def reactions(self, *args, **kwargs):
                            """
                            Allows you to define multiple heterogeneous reactions and stoichiometry. This option is available only with the species model.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/reactions").execute(*args, **kwargs)
                        def mass_transfer(self, *args, **kwargs):
                            """
                            Specify the mass transfer mechanisms.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/mass_transfer").execute(*args, **kwargs)
                        def interfacial_area(self, *args, **kwargs):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interfacial_area").execute(*args, **kwargs)
                        def slip_velocity(self, *args, **kwargs):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/slip_velocity").execute(*args, **kwargs)

                        class interphase_viscous_dissipation(TUIMenu):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)

                        class cavitation(TUIMenu):
                            """
                            Enters the menu to set cavitation models. This option is available only for the Mixture multiphase model with the Singhal-et-al cavitation model enabled via solve/set/advanced/singhal-et-al-cavitation-model.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/wall_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/lift").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/interphase_discr").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Sets the vaporization pressure, surface tension coefficient, and non-condensable gas mass fraction. This command is available only when cavitation? is enabled.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/cavitation").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/lift_montoya").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/virtual_mass").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/slope_limiter").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/vmass_implicit").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/visc_disp_factor").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/sfc_modeling").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/jump_adhesion").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/vmass_coeff").execute(*args, **kwargs)

                        class interphase_discretization(TUIMenu):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/cavitation").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/wall_adhesion").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/lift").execute(*args, **kwargs)

                        class lift(TUIMenu):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/lift").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/wall_adhesion").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/sfc_model_type").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/interphase_discr").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/vmass_implicit").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/interphase_visc_disp").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/visc_disp_factor").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/slope_limiter").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/sfc_tension_coeff").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/lift_montoya").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/jump_adhesion").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/lift_shaver_podowski").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/cavitation").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/vmass_coeff").execute(*args, **kwargs)

                        class virtual_mass(TUIMenu):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/lift_montoya").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/interphase_discr").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/lift").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/virtual_mass").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/slope_limiter").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/cavitation").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/wall_adhesion").execute(*args, **kwargs)

                        class surface_tension(TUIMenu):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/slope_limiter").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/lift_montoya").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/vmass_implicit").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/interphase_discr").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/sfc_modeling").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/lift").execute(*args, **kwargs)
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/cavitation").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/wall_adhesion").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/vmass_coeff").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/virtual_mass").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/jump_adhesion").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/sfc_model_type").execute(*args, **kwargs)

            class iac_expert(TUIMenu):
                """
                Enters the IAC expert setting menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def iac_pseudo_time_step(self, *args, **kwargs):
                    """
                    Set iac pseudo-time.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/phases/iac_expert/iac_pseudo_time_step").execute(*args, **kwargs)
                def ishii_kim_model(self, *args, **kwargs):
                    """
                    Sets Ishii-Kim model coefficients.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/phases/iac_expert/ishii_kim_model").execute(*args, **kwargs)
                def hibiki_ishii_model(self, *args, **kwargs):
                    """
                    Sets Hibiki-Ishii model coefficients.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/phases/iac_expert/hibiki_ishii_model").execute(*args, **kwargs)
                def yao_morel_model(self, *args, **kwargs):
                    """
                    Sets Yao-Morel model coefficients.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/phases/iac_expert/yao_morel_model").execute(*args, **kwargs)

        class dynamic_mesh(TUIMenu):
            """
            Enters the dynamic mesh menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.actions = self.__class__.actions(service, version, mode, path + ["actions"])
                self.controls = self.__class__.controls(service, version, mode, path + ["controls"])
                self.zones = self.__class__.zones(service, version, mode, path + ["zones"])
                self.transient_settings = self.__class__.transient_settings(service, version, mode, path + ["transient_settings"])
                self.events = self.__class__.events(service, version, mode, path + ["events"])
                super().__init__(service, version, mode, path)
            def dynamic_mesh(self, *args, **kwargs):
                """
                Enables/disables the dynamic mesh solver.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/dynamic_mesh").execute(*args, **kwargs)

            class actions(TUIMenu):
                """
                Enters the dynamic mesh action menu, where you can initiate manual remeshing (that is, remeshing without running a calculation).
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def remesh_cell_zone(self, *args, **kwargs):
                    """
                    Manually remeshes a cell zone with option to remesh adjacent dynamic face 	zones.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/actions/remesh_cell_zone").execute(*args, **kwargs)

            class controls(TUIMenu):
                """
                Enters the dynamic mesh controls menu. This text command is only available when the define/dynamic-mesh/dynamic-mesh? text command is enabled.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.layering_parameters = self.__class__.layering_parameters(service, version, mode, path + ["layering_parameters"])
                    self.six_dof_parameters = self.__class__.six_dof_parameters(service, version, mode, path + ["six_dof_parameters"])
                    self.implicit_update_parameters = self.__class__.implicit_update_parameters(service, version, mode, path + ["implicit_update_parameters"])
                    self.contact_parameters = self.__class__.contact_parameters(service, version, mode, path + ["contact_parameters"])
                    self.smoothing_parameters = self.__class__.smoothing_parameters(service, version, mode, path + ["smoothing_parameters"])
                    self.remeshing_parameters = self.__class__.remeshing_parameters(service, version, mode, path + ["remeshing_parameters"])
                    self.periodic_displacement_parameters = self.__class__.periodic_displacement_parameters(service, version, mode, path + ["periodic_displacement_parameters"])
                    self.in_cylinder_parameters = self.__class__.in_cylinder_parameters(service, version, mode, path + ["in_cylinder_parameters"])
                    super().__init__(service, version, mode, path)
                def smoothing(self, *args, **kwargs):
                    """
                    Enables/disables smoothing in cell zones.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing").execute(*args, **kwargs)
                def remeshing(self, *args, **kwargs):
                    """
                    Enables/disables local remeshing in tri/tet and mixed cell zones.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing").execute(*args, **kwargs)
                def in_cylinder_output(self, *args, **kwargs):
                    """
                    Enables/disables in-cylinder output.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/in_cylinder_output").execute(*args, **kwargs)
                def steady_pseudo_time_control(self, *args, **kwargs):
                    """
                    Enables/disables the pseudo time step control in the 	graphical user interface.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/steady_pseudo_time_control").execute(*args, **kwargs)
                def layering(self, *args, **kwargs):
                    """
                    Enables/disables dynamic-layering in quad/hex cell zones.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/layering").execute(*args, **kwargs)

                class layering_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh layering menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def collapse_factor(self, *args, **kwargs):
                        """
                        Sets the factor determining when to collapse dynamic layers.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/layering_parameters/collapse_factor").execute(*args, **kwargs)
                    def constant_height(self, *args, **kwargs):
                        """
                        Enables/disables layering based on constant height, else layering based on constant ratio.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/layering_parameters/constant_height").execute(*args, **kwargs)
                    def split_factor(self, *args, **kwargs):
                        """
                        Sets the factor determining when to split dynamic layers.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/layering_parameters/split_factor").execute(*args, **kwargs)

                class six_dof_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh six degrees of freedom (DOF) solver menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def x_component_of_gravity(self, *args, **kwargs):
                        """
                        Specifies x-component of gravity.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/six_dof_parameters/x_component_of_gravity").execute(*args, **kwargs)
                    def y_component_of_gravity(self, *args, **kwargs):
                        """
                        Specifies y-component of gravity.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/six_dof_parameters/y_component_of_gravity").execute(*args, **kwargs)
                    def create_properties(self, *args, **kwargs):
                        """
                        Creates/edits a set of six DOF properties for rigid body motion.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/six_dof_parameters/create_properties").execute(*args, **kwargs)
                    def list_properties(self, *args, **kwargs):
                        """
                        Prints summaries of the existing sets of six DOF properties for rigid body motion.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/six_dof_parameters/list_properties").execute(*args, **kwargs)
                    def motion_history(self, *args, **kwargs):
                        """
                        Enables/disables writing position/orientation of six DOF zones to file.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/six_dof_parameters/motion_history").execute(*args, **kwargs)
                    def delete_properties(self, *args, **kwargs):
                        """
                        Deletes a set of six DOF properties for rigid body motion.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/six_dof_parameters/delete_properties").execute(*args, **kwargs)
                    def motion_history_file_name(self, *args, **kwargs):
                        """
                        Specifies the name and location of the six DOF motion history file.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/six_dof_parameters/motion_history_file_name").execute(*args, **kwargs)
                    def second_order(self, *args, **kwargs):
                        """
                        Enables/disables the second order six degrees of freedom solver.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/six_dof_parameters/second_order").execute(*args, **kwargs)
                    def z_component_of_gravity(self, *args, **kwargs):
                        """
                        Specifies z-component of gravity.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/six_dof_parameters/z_component_of_gravity").execute(*args, **kwargs)

                class implicit_update_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh implicit update menu. This text command is only available 	when you enable implicit mesh updating using the prompts 	of the define/dynamic-mesh/dynamic-mesh? 	text command.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def update_interval(self, *args, **kwargs):
                        """
                        Specifies the update interval (that is, the frequency in iterations) at which the mesh is updated within a time step.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/implicit_update_parameters/update_interval").execute(*args, **kwargs)
                    def motion_relaxation(self, *args, **kwargs):
                        """
                        Specifies a value (within the range of 0 to 1) for the motion relaxation, which is applied during the implicit mesh update.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/implicit_update_parameters/motion_relaxation").execute(*args, **kwargs)
                    def residual_criteria(self, *args, **kwargs):
                        """
                        Specifies the relative residual threshold that is used to check the motion convergence during the implicit mesh update.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/implicit_update_parameters/residual_criteria").execute(*args, **kwargs)

                class contact_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh contact-parameters menu. This text command is only available 	when you enable contact detection using the prompts of 	the define/dynamic-mesh/dynamic-mesh? 	text command.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.flow_control_parameters = self.__class__.flow_control_parameters(service, version, mode, path + ["flow_control_parameters"])
                        super().__init__(service, version, mode, path)
                    def contact_udf(self, *args, **kwargs):
                        """
                        Selects the UDF to be invoked when contact is detected.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/contact_parameters/contact_udf").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        Sets the level of detail printed in the console regarding contact detection.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/contact_parameters/verbosity").execute(*args, **kwargs)
                    def contact_threshold(self, *args, **kwargs):
                        """
                        Specifies threshold distance for contact detection.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/contact_parameters/contact_threshold").execute(*args, **kwargs)
                    def contact_face_zones(self, *args, **kwargs):
                        """
                        Selects face zones involved in contact detection.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/contact_parameters/contact_face_zones").execute(*args, **kwargs)
                    def contact_method(self, *args, **kwargs):
                        """
                        Selects the method used for flow control in the contact region. Enter 0 for the contact zones method (which restricts the flow using additional cell zones with porous zone properties) or 1 for the contact marks method (which blocks the flow using zero-mass-flux boundaries).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/contact_parameters/contact_method").execute(*args, **kwargs)
                    def update_contact_marks(self, *args, **kwargs):
                        """
                        Updates which cells are marked in order to block flow in the contact region as part of the contact marks method.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/contact_parameters/update_contact_marks").execute(*args, **kwargs)
                    def flow_control(self, *args, **kwargs):
                        """
                        Enables/disables flow control in the contact region.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/contact_parameters/flow_control").execute(*args, **kwargs)
                    def render_contact_cells(self, *args, **kwargs):
                        """
                        Enables/disables the availability of a field variable (contact-cell-mark) that can be used to display contours of cells marked for flow blocking as part of the contact marks method, and allows you to postprocess other field variables on those cells.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/contact_parameters/render_contact_cells").execute(*args, **kwargs)

                    class flow_control_parameters(TUIMenu):
                        """
                        Enters the flow control parameters menu, which provides settings related to controlling the flow in the contact region.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def delete_flow_control_zone(self, *args, **kwargs):
                            """
                            Deletes a flow control zone as part of the contact zones method.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/contact_parameters/flow_control_parameters/delete_flow_control_zone").execute(*args, **kwargs)
                        def create_flow_control_zone(self, *args, **kwargs):
                            """
                            Creates a flow control zone as part of the contact zones method.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/contact_parameters/flow_control_parameters/create_flow_control_zone").execute(*args, **kwargs)
                        def solution_stabilization(self, *args, **kwargs):
                            """
                            Enables/disables the performance of additional iterations per time step and the application of solution controls to improve the stability of the solver as part of the contact marks method.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/contact_parameters/flow_control_parameters/solution_stabilization").execute(*args, **kwargs)

                class smoothing_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh smoothing-parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def spring_on_all_elements(self, *args, **kwargs):
                        """
                        Enables/disables spring-based smoothing for all cell shapes; if disabled, the spring-based smoothing is applied based on the setting of the define/dynamic-mesh/controls/smoothing-parameters/spring-on-simplex-shapes? text command.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/spring_on_all_elements").execute(*args, **kwargs)
                    def diffusion_fvm(self, *args, **kwargs):
                        """
                        Answering yes at the prompt changes the diffusion-based smoothing method to the cell-based finite volume approach that was the default in releases prior to Fluent 15.0. Answering no at the prompt changes the diffusion-based smoothing method to the default node-based finite element method.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/diffusion_fvm").execute(*args, **kwargs)
                    def convergence_tolerance(self, *args, **kwargs):
                        """
                        Sets the convergence tolerance for spring-based solver.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/convergence_tolerance").execute(*args, **kwargs)
                    def max_iter(self, *args, **kwargs):
                        """
                        Set the maximum number of iterations for spring-based solver.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/max_iter").execute(*args, **kwargs)
                    def smooth_boundary_layers_with_adjacent_zone(self, *args, **kwargs):
                        """
                        Enable smoothing of boundary layers solely on adjacent zone motion (Radial Basis Function).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/smooth_boundary_layers_with_adjacent_zone").execute(*args, **kwargs)
                    def skew_smooth_face_skew_max(self, *args, **kwargs):
                        """
                        Sets the skewness threshold, above which faces will be smoothed using the skewness method.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/skew_smooth_face_skew_max").execute(*args, **kwargs)
                    def skew_smooth_all_deforming_boundaries(self, *args, **kwargs):
                        """
                        Enables/disables skewness smoothing for all deforming dynamic boundary zones. This is enabled by default. If disabled, skewness smoothing is only applied to the deforming dynamic boundary zones that have smoothing explicitly enabled or use local face remeshing.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/skew_smooth_all_deforming_boundaries").execute(*args, **kwargs)
                    def spring_on_simplex_elements(self, *args, **kwargs):
                        """
                        Enable/disable spring-based smoothing for tri/tet elements in mixed element zones.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/spring_on_simplex_elements").execute(*args, **kwargs)
                    def laplace_node_relaxation(self, *args, **kwargs):
                        """
                        Set the Laplace boundary node relaxation factor.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/laplace_node_relaxation").execute(*args, **kwargs)
                    def bnd_stiffness_factor(self, *args, **kwargs):
                        """
                        Sets the stiffness factor for springs connected to boundary nodes.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/bnd_stiffness_factor").execute(*args, **kwargs)
                    def poisson_ratio(self, *args, **kwargs):
                        """
                        Sets the Poissons ratio used for smoothing based on the linearly elastic solid model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/poisson_ratio").execute(*args, **kwargs)
                    def boundary_distance_method(self, *args, **kwargs):
                        """
                        Sets the method used to evaluate the boundary distance for the diffusion coefficient calculation, when diffusion-based smoothing is enabled.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/boundary_distance_method").execute(*args, **kwargs)
                    def diffusion_coeff_parameter(self, *args, **kwargs):
                        """
                        Sets the diffusion coefficient parameter used for diffusion-based smoothing.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/diffusion_coeff_parameter").execute(*args, **kwargs)
                    def smoothing_method(self, *args, **kwargs):
                        """
                        Specify the smoothing method used by the dynamic mesh model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/smoothing_method").execute(*args, **kwargs)
                    def amg_stabilization(self, *args, **kwargs):
                        """
                        Set the AMG stabilization method for mesh smoothing (FEM).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/amg_stabilization").execute(*args, **kwargs)
                    def bnd_node_relaxation(self, *args, **kwargs):
                        """
                        The boundary node relaxation is used by spring smoothing. The boundary node relaxation allows you to relax the update of the node positions at deforming boundaries. A value of 0 prevents deforming boundary nodes from moving and a value of 1 indicates no under-relaxation.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/bnd_node_relaxation").execute(*args, **kwargs)
                    def constant_factor(self, *args, **kwargs):
                        """
                        Sets the spring constant relaxation factor.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/constant_factor").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        Set the verbosity for spring smoothing.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/verbosity").execute(*args, **kwargs)
                    def diffusion_coeff_function(self, *args, **kwargs):
                        """
                        Specifies whether the diffusion coefficient for diffusion-based smoothing is based on the boundary distance or the cell volume.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/diffusion_coeff_function").execute(*args, **kwargs)
                    def skew_smooth_cell_skew_max(self, *args, **kwargs):
                        """
                        Sets the skewness threshold, above which cells will be smoothed using the skewness method.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/skew_smooth_cell_skew_max").execute(*args, **kwargs)
                    def skew_smooth_niter(self, *args, **kwargs):
                        """
                        Sets the number of skewness-based smoothing cycles.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/skew_smooth_niter").execute(*args, **kwargs)
                    def smooth_from_reference_position(self, *args, **kwargs):
                        """
                        Enables/disables smoothing from a reference position. Such smoothing may produce greater mesh quality consistency for stationary or moving meshes with periodic or quasi-periodic motion, and is only available when the smoothing method is based on diffusion or the linearly elastic solid model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/smooth_from_reference_position").execute(*args, **kwargs)
                    def relative_convergence_tolerance(self, *args, **kwargs):
                        """
                        Sets the relative residual convergence tolerance for smoothing based on diffusion or the linearly elastic solid model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/smoothing_parameters/relative_convergence_tolerance").execute(*args, **kwargs)

                class remeshing_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh remeshing menu to set 	parameters for all remeshing methods.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.sizing_controls = self.__class__.sizing_controls(service, version, mode, path + ["sizing_controls"])
                        self.prism_layer_parameters = self.__class__.prism_layer_parameters(service, version, mode, path + ["prism_layer_parameters"])
                        self.prism_controls = self.__class__.prism_controls(service, version, mode, path + ["prism_controls"])
                        super().__init__(service, version, mode, path)
                    def length_min(self, *args, **kwargs):
                        """
                        Sets the length threshold below which cells will be remeshed.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/length_min").execute(*args, **kwargs)
                    def sizing_function(self, *args, **kwargs):
                        """
                        Enables/disables the sizing function as part of methods-based remeshing.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_function").execute(*args, **kwargs)
                    def unified_remeshing(self, *args, **kwargs):
                        """
                        Enables/disables unified remeshing, which specifies that an algorithm is used that combines aspects of a variety of remeshing methods. It is applied to triangular or tetrahedral cells and can produce wedge cells in 3D boundary layer meshes. Unified remeshing simplifies the remeshing setup and can provide increased robustness compared to methods-based remeshing, especially for parallel simulations.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/unified_remeshing").execute(*args, **kwargs)
                    def remeshing_methods(self, *args, **kwargs):
                        """
                        Enables/disables individual remeshing options as part of methods-based remeshing.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/remeshing_methods").execute(*args, **kwargs)
                    def remeshing_after_moving(self, *args, **kwargs):
                        """
                        Enables a second round of remeshing based on the skewness parameters after the boundary has moved as part of methods-based remeshing.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/remeshing_after_moving").execute(*args, **kwargs)
                    def poly_remeshing(self, *args, **kwargs):
                        """
                        Enable/disable poly remeshing.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/poly_remeshing").execute(*args, **kwargs)
                    def face_skew_max(self, *args, **kwargs):
                        """
                        Sets the face skewness threshold above which faces will be remeshed.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/face_skew_max").execute(*args, **kwargs)
                    def cell_skew_max(self, *args, **kwargs):
                        """
                        Sets the cell skewness threshold above which cells will be remeshed.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/cell_skew_max").execute(*args, **kwargs)
                    def sizing_funct_resolution(self, *args, **kwargs):
                        """
                        Sets the sizing function resolution with respect to shortest boundary.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_funct_resolution").execute(*args, **kwargs)
                    def retain_size_distribution(self, *args, **kwargs):
                        """
                        Enables/disables the use of local size criteria when marking cells for unified remeshing (in an attempt to maintain the initial mesh size distribution even as the mesh moves), rather than marking cells based on the minimum and maximum length scale values of the cell zone in the initial mesh. Either marking can be overridden if more restrictive values are specified using the define/dynamic-mesh/controls/remeshing-parameters/length-min and define/dynamic-mesh/controls/remeshing-parameters/length-max text commands.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/retain_size_distribution").execute(*args, **kwargs)
                    def size_remesh_interval(self, *args, **kwargs):
                        """
                        Sets the interval (in time steps) when remeshing based on size is done for methods-based remeshing.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/size_remesh_interval").execute(*args, **kwargs)
                    def sizing_funct_defaults(self, *args, **kwargs):
                        """
                        Sets sizing function defaults.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_funct_defaults").execute(*args, **kwargs)
                    def parallel_remeshing(self, *args, **kwargs):
                        """
                        Disables/enables parallel remeshing as part of methods-based remeshing..
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/parallel_remeshing").execute(*args, **kwargs)
                    def length_max(self, *args, **kwargs):
                        """
                        Sets the length threshold above which cells will be remeshed.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/length_max").execute(*args, **kwargs)
                    def zone_remeshing(self, *args, **kwargs):
                        """
                        Enables/disables the cell zone remeshing method as part of methods-based remeshing.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/zone_remeshing").execute(*args, **kwargs)
                    def sizing_funct_variation(self, *args, **kwargs):
                        """
                        Sets the maximum sizing function increase/decrease in the interior.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_funct_variation").execute(*args, **kwargs)
                    def sizing_funct_rate(self, *args, **kwargs):
                        """
                        Determines how far from the boundary the increase/decrease happens.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_funct_rate").execute(*args, **kwargs)

                    class sizing_controls(TUIMenu):
                        """
                        Enters the dynamic mesh sizing controls menu, which provides text commands that can be useful when you want to modify the algorithm that attempts to retain the size distribution during unified remeshing. Each sizing control definition is applied to one or more boundary zones, and then affects the size of the cells throughout the mesh based on their distance from those boundary zone(s) and your settings in the definition.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def edit(self, *args, **kwargs):
                            """
                            Edits an existing sizing controls definition. You can revise the fields listed previously for the define/dynamic-mesh/controls/remeshing-parameters/sizing-controls/add text command.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_controls/edit").execute(*args, **kwargs)
                        def list_properties(self, *args, **kwargs):
                            """
                            Prints the properties of an existing sizing controls definition of your choice in the console.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_controls/list_properties").execute(*args, **kwargs)
                        def delete(self, *args, **kwargs):
                            """
                            Deletes an existing sizing controls definition.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_controls/delete").execute(*args, **kwargs)
                        def add(self, *args, **kwargs):
                            """
                            Adds a new sizing controls definition.   After being prompted for a name, you can enter the following to complete the definition:
                            growth-rate  Sets the growth rate of the sizing controls definition.
                            max-length  Sets a maximum length threshold that is used when the type is set to auto or soft.
                            min-length  Sets a maximum length threshold that is used when the type is set to auto.
                            motion  Determines whether the size control definition affects the remeshing based on whether the mesh undergoes motion: auto specifies that it is applied whether or not there is motion; and static specifies that it is only applied if there is no motion.
                            name  Specifies the name of the sizing controls definition.
                            type  Specifies how the sizing is affected by the selected boundary zones: auto specifies that the default size distribution (rather than the initial size distribution in your selected boundary zones) is used, along with your specified max-length and min-length values; soft specifies that the maximum length scale of your selected boundary zones is used, along with your specified min-length value; and meshed specifies that the maximum and minimum length scales of your selected boundary zones are used, in order to respect their initial size distribution. This setting is only relevant if you have more than one sizing controls definition.
                            zones  Specifies all of the boundary zones on which the sizing controls definition is applied.
                            Enter q when the definition is complete to return to the text command menu.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_controls/add").execute(*args, **kwargs)
                        def list(self, *args, **kwargs):
                            """
                            Prints a list of the existing sizing controls definitions in the console.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_controls/list").execute(*args, **kwargs)

                    class prism_layer_parameters(TUIMenu):
                        """
                        Enters the dynamic mesh prism layer parameters menu, where you can define the parameters of the prism layers as part of methods-based remeshing.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def first_height(self, *args, **kwargs):
                            """
                            Sets the first cell height in the prism layer.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/prism_layer_parameters/first_height").execute(*args, **kwargs)
                        def growth_rate(self, *args, **kwargs):
                            """
                            Sets the geometric growth rate of the prism layer.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/prism_layer_parameters/growth_rate").execute(*args, **kwargs)
                        def number_of_layers(self, *args, **kwargs):
                            """
                            Sets the number of elements in the prism layer.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/prism_layer_parameters/number_of_layers").execute(*args, **kwargs)

                    class prism_controls(TUIMenu):
                        """
                        Enters the dynamic mesh prism controls menu, which provides text commands that can be useful when you want to modify the algorithm that attempts to retain the size distribution during unified remeshing. Each prism control definition is applied to one or more boundary zones, and then affects the height distribution and number of layers of the wedge cells in the adjacent boundary layers.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def delete(self, *args, **kwargs):
                            """
                            Deletes an existing prism controls definition.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/prism_controls/delete").execute(*args, **kwargs)
                        def edit(self, *args, **kwargs):
                            """
                            Edits an existing prism controls definition. You can revise the fields listed previously for the define/dynamic-mesh/controls/remeshing-parameters/prism-controls/add text command.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/prism_controls/edit").execute(*args, **kwargs)
                        def list(self, *args, **kwargs):
                            """
                            Prints a list of the existing prism controls definitions in the console.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/prism_controls/list").execute(*args, **kwargs)
                        def list_properties(self, *args, **kwargs):
                            """
                            Prints the properties of an existing prism controls definition of your choice in the console.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/prism_controls/list_properties").execute(*args, **kwargs)
                        def add(self, *args, **kwargs):
                            """
                            Adds a new prism controls definition.   After being prompted for a name, you can enter the following to complete the definition:
                            first-height  Sets the height of the first layer of wedge cells in the boundary layer adjacent to the specified zones.
                            growth-method  Specifies the method used to determine the increase in height of the wedge cell layers beyond the first layer. The only available option is geometric, so that the height of each layer is the height of the previous layer multiplied by the rate.
                            name  Specifies the name of the prism controls definition.
                            nlayers  Sets the number of layers of wedge cells in the boundary layer adjacent to the specified zones.
                            rate  Sets the coefficient for the growth-method used to determine the increase in height of the wedge cell layers beyond the first layer.
                            zones  Specifies all of the boundary zones on which this prism controls definition is applied.
                            Enter q when the definition is complete to return to the text command menu.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/remeshing_parameters/prism_controls/add").execute(*args, **kwargs)

                class periodic_displacement_parameters(TUIMenu):
                    """
                    Enters the periodic displacement parameters 	menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def delete_all_groups(self, *args, **kwargs):
                        """
                        Delete All Periodic Displacement Groups.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/periodic_displacement_parameters/delete_all_groups").execute(*args, **kwargs)
                    def edit_group(self, *args, **kwargs):
                        """
                        Edit Periodic Displacement Group.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/periodic_displacement_parameters/edit_group").execute(*args, **kwargs)
                    def edit_displacement(self, *args, **kwargs):
                        """
                        Edit Periodic Displacement.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/periodic_displacement_parameters/edit_displacement").execute(*args, **kwargs)
                    def create_displacement(self, *args, **kwargs):
                        """
                        Create Periodic Displacement.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/periodic_displacement_parameters/create_displacement").execute(*args, **kwargs)
                    def copy_displacement(self, *args, **kwargs):
                        """
                        Copy Periodic Displacement.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/periodic_displacement_parameters/copy_displacement").execute(*args, **kwargs)
                    def create_group(self, *args, **kwargs):
                        """
                        Create Periodic Displacement Group.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/periodic_displacement_parameters/create_group").execute(*args, **kwargs)
                    def list_displacements(self, *args, **kwargs):
                        """
                        List Periodic Displacements.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/periodic_displacement_parameters/list_displacements").execute(*args, **kwargs)
                    def delete_all_displacements(self, *args, **kwargs):
                        """
                        Delete All Periodic Displacements.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/periodic_displacement_parameters/delete_all_displacements").execute(*args, **kwargs)
                    def delete_group(self, *args, **kwargs):
                        """
                        Delete Periodic Displacement Group.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/periodic_displacement_parameters/delete_group").execute(*args, **kwargs)
                    def set_active_displacement(self, *args, **kwargs):
                        """
                        Set Active Periodic Displacement in Group.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/periodic_displacement_parameters/set_active_displacement").execute(*args, **kwargs)
                    def delete_displacement(self, *args, **kwargs):
                        """
                        Delete Periodic Displacement.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/periodic_displacement_parameters/delete_displacement").execute(*args, **kwargs)
                    def list_groups(self, *args, **kwargs):
                        """
                        List Periodic Displacement Groups.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/periodic_displacement_parameters/list_groups").execute(*args, **kwargs)

                class in_cylinder_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh in-cylinder menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def piston_data(self, *args, **kwargs):
                        """
                        Specifies the crank radius and connecting rod length.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/in_cylinder_parameters/piston_data").execute(*args, **kwargs)
                    def print_plot_lift(self, *args, **kwargs):
                        """
                        Prints or plot valve lift curve.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/in_cylinder_parameters/print_plot_lift").execute(*args, **kwargs)
                    def crank_period(self, *args, **kwargs):
                        """
                        Specifies the crank period.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/in_cylinder_parameters/crank_period").execute(*args, **kwargs)
                    def modify_lift(self, *args, **kwargs):
                        """
                        Modifies lift curve (shift or scale).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/in_cylinder_parameters/modify_lift").execute(*args, **kwargs)
                    def minimum_lift(self, *args, **kwargs):
                        """
                        Specifies minimum lift for in-cylinder valves.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/in_cylinder_parameters/minimum_lift").execute(*args, **kwargs)
                    def max_crank_angle_step(self, *args, **kwargs):
                        """
                        Specifies maximum crank angle step size.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/in_cylinder_parameters/max_crank_angle_step").execute(*args, **kwargs)
                    def position_starting_mesh(self, *args, **kwargs):
                        """
                        Moves mesh from top dead center to starting crank angle.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/in_cylinder_parameters/position_starting_mesh").execute(*args, **kwargs)
                    def starting_crank_angle(self, *args, **kwargs):
                        """
                        Specifies the initial value for the crank angle.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/in_cylinder_parameters/starting_crank_angle").execute(*args, **kwargs)
                    def crank_angle_step(self, *args, **kwargs):
                        """
                        Specifies crank angle step size.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/in_cylinder_parameters/crank_angle_step").execute(*args, **kwargs)
                    def piston_stroke_cutoff(self, *args, **kwargs):
                        """
                        Specifies the cut off point for in-cylinder piston.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/controls/in_cylinder_parameters/piston_stroke_cutoff").execute(*args, **kwargs)

            class zones(TUIMenu):
                """
                Enters the dynamic mesh zones menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def list(self, *args, **kwargs):
                    """
                    Lists the dynamic zones.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/zones/list").execute(*args, **kwargs)
                def insert_boundary_layer(self, *args, **kwargs):
                    """
                    Inserts a new cell zone.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/zones/insert_boundary_layer").execute(*args, **kwargs)
                def remove_boundary_layer(self, *args, **kwargs):
                    """
                    Removes a cell zone.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/zones/remove_boundary_layer").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Deletes a dynamic zone.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/zones/delete").execute(*args, **kwargs)
                def insert_interior_layer(self, *args, **kwargs):
                    """
                    Inserts a new layer cell zone at a specified location.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/zones/insert_interior_layer").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create dynamic zone.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/zones/create").execute(*args, **kwargs)
                def remove_interior_layer(self, *args, **kwargs):
                    """
                    Removes an interior layer cell zone.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/zones/remove_interior_layer").execute(*args, **kwargs)

            class transient_settings(TUIMenu):
                """
                Enters the transient dynamic mesh settings menu. This text command is only available when you enable dynamic mesh using the prompts of the define/dynamic-mesh/dynamic-mesh? text command. Solver time must also be set to Transient.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def verbosity(self, *args, **kwargs):
                    """
                    Enables/disables transient scheme verbosity for dynamic mesh cases.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/transient_settings/verbosity").execute(*args, **kwargs)
                def allow_second_order(self, *args, **kwargs):
                    """
                    Enables/disables second order transient scheme for dynamic mesh cases.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/transient_settings/allow_second_order").execute(*args, **kwargs)

            class events(TUIMenu):
                """
                Enters the dynamic mesh events menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def import_event_file(self, *args, **kwargs):
                    """
                    Imports dynamic mesh event file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/events/import_event_file").execute(*args, **kwargs)
                def export_event_file(self, *args, **kwargs):
                    """
                    Exports dynamic mesh events to file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/dynamic_mesh/events/export_event_file").execute(*args, **kwargs)

        class named_expressions(TUIMenu):
            """
            Enters the named expressions menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def edit(self, *args, **kwargs):
                """
                Allows you to edit the definition of a named expression.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/named_expressions/edit").execute(*args, **kwargs)
            def import_from_tsv(self, *args, **kwargs):
                """
                Import one or more named expressions saved in TSV format.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/named_expressions/import_from_tsv").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                Lists the definition of a named expression.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/named_expressions/list_properties").execute(*args, **kwargs)
            def add(self, *args, **kwargs):
                """
                Creates a new named expression.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/named_expressions/add").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                Lists all of the currently defined named expressions.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/named_expressions/list").execute(*args, **kwargs)
            def copy(self, *args, **kwargs):
                """
                Allows you to copy an existing named expression.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/named_expressions/copy").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Allows you to delete a named expression, as long as it is not in use.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/named_expressions/delete").execute(*args, **kwargs)
            def compute(self, *args, **kwargs):
                """
                Computes and prints the value of an expression. This is only available for expressions that evaluate to a single value.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/named_expressions/compute").execute(*args, **kwargs)
            def export_to_tsv(self, *args, **kwargs):
                """
                Export one or more named expressions to a file in TSV format.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/named_expressions/export_to_tsv").execute(*args, **kwargs)

        class virtual_boundary(TUIMenu):
            """
            Manage Virtual Boundaries.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def hole_geometry(self, *args, **kwargs):
                """
                Create a Hole Geometry template.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/virtual_boundary/hole_geometry").execute(*args, **kwargs)
            def boundary_interface(self, *args, **kwargs):
                """
                Create a Boundary Interface.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/virtual_boundary/boundary_interface").execute(*args, **kwargs)

        class periodic_conditions(TUIMenu):
            """
            Enters the periodic conditions menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def massflow_rate_specification(self, *args, **kwargs):
                """
                Enables/disables specification of mass flow rate at the periodic boundary.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/periodic_conditions/massflow_rate_specification").execute(*args, **kwargs)
            def pressure_gradient_specification(self, *args, **kwargs):
                """
                Enables/disables specification of pressure gradient at the periodic boundary.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/periodic_conditions/pressure_gradient_specification").execute(*args, **kwargs)

        class turbo_model(TUIMenu):
            """
            Enters the turbo menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.general_turbo_interface_settings = self.__class__.general_turbo_interface_settings(service, version, mode, path + ["general_turbo_interface_settings"])
                self.blade_flutter_harmonics = self.__class__.blade_flutter_harmonics(service, version, mode, path + ["blade_flutter_harmonics"])
                self.legacy_models = self.__class__.legacy_models(service, version, mode, path + ["legacy_models"])
                self.turbo_topology = self.__class__.turbo_topology(service, version, mode, path + ["turbo_topology"])
                super().__init__(service, version, mode, path)
            def list_turbomachine_description(self, *args, **kwargs):
                """
                List turbomachine description.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/list_turbomachine_description").execute(*args, **kwargs)
            def create_phaselag_spectral_content(self, *args, **kwargs):
                """
                Define phaselag related spectral content.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/create_phaselag_spectral_content").execute(*args, **kwargs)
            def turbo_interface_check(self, *args, **kwargs):
                """
                Check General Turbo Interface and Phase-lag.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/turbo_interface_check").execute(*args, **kwargs)
            def graphics_extra_settings(self, *args, **kwargs):
                """
                Define phaselag related extra settings.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/graphics_extra_settings").execute(*args, **kwargs)
            def delete_phaselag_spectral_content(self, *args, **kwargs):
                """
                Delete phaselag related spectral content.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/delete_phaselag_spectral_content").execute(*args, **kwargs)
            def create_turbomachine_description(self, *args, **kwargs):
                """
                Define turbomachine description.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/create_turbomachine_description").execute(*args, **kwargs)
            def make_phaselag_from_periodic(self, *args, **kwargs):
                """
                Convert periodic interface to phase lagged.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/make_phaselag_from_periodic").execute(*args, **kwargs)
            def turbo_create(self, *args, **kwargs):
                """
                Creates a general turbo interface.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/turbo_create").execute(*args, **kwargs)
            def separate_nonoverlapping_interface_boundary(self, *args, **kwargs):
                """
                Split a general turbo interface non-overlapping zone.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/separate_nonoverlapping_interface_boundary").execute(*args, **kwargs)
            def enable_turbo_model(self, *args, **kwargs):
                """
                Enables/disables turbo model menu.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/enable_turbo_model").execute(*args, **kwargs)
            def delete_turbomachine_description(self, *args, **kwargs):
                """
                Delete turbomachine description.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/delete_turbomachine_description").execute(*args, **kwargs)
            def make_phaselag_from_boundaries(self, *args, **kwargs):
                """
                Make interface zones phase lagged.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/make_phaselag_from_boundaries").execute(*args, **kwargs)
            def list_phaselag_state(self, *args, **kwargs):
                """
                List all phaselag related case settings.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/list_phaselag_state").execute(*args, **kwargs)
            def create_graphics_spectral_content(self, *args, **kwargs):
                """
                Define post-processing related spectral content.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/create_graphics_spectral_content").execute(*args, **kwargs)
            def list_graphics_spectral_content(self, *args, **kwargs):
                """
                List post-processing related spectral content.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/list_graphics_spectral_content").execute(*args, **kwargs)
            def delete_graphics_spectral_content(self, *args, **kwargs):
                """
                Delete post-processing related spectral content.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/delete_graphics_spectral_content").execute(*args, **kwargs)
            def phaselag_extra_settings(self, *args, **kwargs):
                """
                Define phaselag related extra settings.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/phaselag_extra_settings").execute(*args, **kwargs)
            def append_phaselag_spectral_content(self, *args, **kwargs):
                """
                Define phaselag related spectral content.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/append_phaselag_spectral_content").execute(*args, **kwargs)
            def append_graphics_spectral_content(self, *args, **kwargs):
                """
                Define post-processing related spectral content.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/append_graphics_spectral_content").execute(*args, **kwargs)
            def blade_flutter_row(self, *args, **kwargs):
                """
                Define the periodic displacement row.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/blade_flutter_row").execute(*args, **kwargs)

            class general_turbo_interface_settings(TUIMenu):
                """
                Enters the General Turbo Interface options menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.mixing_plane_model_settings = self.__class__.mixing_plane_model_settings(service, version, mode, path + ["mixing_plane_model_settings"])
                    super().__init__(service, version, mode, path)
                def expert(self, *args, **kwargs):
                    """
                    Set the expert parameters for turbo interfaces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/general_turbo_interface_settings/expert").execute(*args, **kwargs)

                class mixing_plane_model_settings(TUIMenu):
                    """
                    Defines settings for the mixing plane model.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.number_of_bands = self.__class__.number_of_bands(service, version, mode, path + ["number_of_bands"])
                        super().__init__(service, version, mode, path)
                    def bands_type(self, *args, **kwargs):
                        """
                        Specifies the averaging bands for mixing as fixed or variable width.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/bands_type").execute(*args, **kwargs)
                    def averaging_method(self, *args, **kwargs):
                        """
                        Set the averaging method for the mixing.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/averaging_method").execute(*args, **kwargs)
                    def mixing_set_constraint(self, *args, **kwargs):
                        """
                        To set the mixing of primitive or total variable approach.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/mixing_set_constraint").execute(*args, **kwargs)
                    def list_mixing_planes(self, *args, **kwargs):
                        """
                        List the settings of mixing planes in the case.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/list_mixing_planes").execute(*args, **kwargs)

                    class number_of_bands(TUIMenu):
                        """
                        Sets the number of bands to be used for mixing.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def set_all_interfaces(self, *args, **kwargs):
                            """
                            Set number of band to be used for mixing.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/number_of_bands/set_all_interfaces").execute(*args, **kwargs)
                        def set_specific_interface(self, *args, **kwargs):
                            """
                            Set number of band to be used for mixing.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/number_of_bands/set_specific_interface").execute(*args, **kwargs)

            class blade_flutter_harmonics(TUIMenu):
                """
                Enters the blade flutter harmonics options menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def write_harmonic_exports(self, *args, **kwargs):
                    """
                    Writes harmonic export data.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/blade_flutter_harmonics/write_harmonic_exports").execute(*args, **kwargs)
                def enable_harmonic_exports(self, *args, **kwargs):
                    """
                    Calculates/Deletes flutter harmonic export data.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/blade_flutter_harmonics/enable_harmonic_exports").execute(*args, **kwargs)
                def write_aerodamping_vs_nodal_diameter(self, *args, **kwargs):
                    """
                    Reads report definition file and Writes influence coefficient aerodynamic damping values vs nodal diameter.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/blade_flutter_harmonics/write_aerodamping_vs_nodal_diameter").execute(*args, **kwargs)

            class legacy_models(TUIMenu):
                """
                Enter Legacy Turbo Model Menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.legacy_mixing_plane = self.__class__.legacy_mixing_plane(service, version, mode, path + ["legacy_mixing_plane"])
                    super().__init__(service, version, mode, path)

                class legacy_mixing_plane(TUIMenu):
                    """
                    Enter the legacy mixing planes menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.set = self.__class__.set(service, version, mode, path + ["set"])
                        super().__init__(service, version, mode, path)
                    def delete(self, *args, **kwargs):
                        """
                        Delete a mixing plane.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/legacy_models/legacy_mixing_plane/delete").execute(*args, **kwargs)
                    def mixing_plane_gui(self, *args, **kwargs):
                        """
                        GUI for setting up legacy mixing plane model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/legacy_models/legacy_mixing_plane/mixing_plane_gui").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        List defined mixing plane(s).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/legacy_models/legacy_mixing_plane/list").execute(*args, **kwargs)
                    def create(self, *args, **kwargs):
                        """
                        Create a mixing plane.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/legacy_models/legacy_mixing_plane/create").execute(*args, **kwargs)

                    class set(TUIMenu):
                        """
                        Enter the mixing plane set menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.conserve_swirl = self.__class__.conserve_swirl(service, version, mode, path + ["conserve_swirl"])
                            self.conserve_total_enthalpy = self.__class__.conserve_total_enthalpy(service, version, mode, path + ["conserve_total_enthalpy"])
                            super().__init__(service, version, mode, path)
                        def under_relaxation(self, *args, **kwargs):
                            """
                            Set mixing plane under-relaxation factor.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/legacy_models/legacy_mixing_plane/set/under_relaxation").execute(*args, **kwargs)
                        def averaging_method(self, *args, **kwargs):
                            """
                            Set mixing plane profile averaging method.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/legacy_models/legacy_mixing_plane/set/averaging_method").execute(*args, **kwargs)
                        def fix_pressure_level(self, *args, **kwargs):
                            """
                            Set fix pressure level using define/reference-pressure-location.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/legacy_models/legacy_mixing_plane/set/fix_pressure_level").execute(*args, **kwargs)

                        class conserve_swirl(TUIMenu):
                            """
                            Enter the mixing plane conserve-swirl menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def enable(self, *args, **kwargs):
                                """
                                Enable/disable swirl conservation in mixing plane.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/legacy_models/legacy_mixing_plane/set/conserve_swirl/enable").execute(*args, **kwargs)
                            def report_swirl_integration(self, *args, **kwargs):
                                """
                                Report swirl integration (torque) on inflow and outflow zones.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/legacy_models/legacy_mixing_plane/set/conserve_swirl/report_swirl_integration").execute(*args, **kwargs)
                            def verbosity(self, *args, **kwargs):
                                """
                                Enable/disable verbosity in swirl conservation calculations.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/legacy_models/legacy_mixing_plane/set/conserve_swirl/verbosity").execute(*args, **kwargs)

                        class conserve_total_enthalpy(TUIMenu):
                            """
                            Enter the menu to set total enthalpy conservation in mixing plane menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def enable(self, *args, **kwargs):
                                """
                                Enable/disable total enthalpy conservation in mixing plane.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/legacy_models/legacy_mixing_plane/set/conserve_total_enthalpy/enable").execute(*args, **kwargs)
                            def verbosity(self, *args, **kwargs):
                                """
                                Enable/disable verbosity in total-enthalpy conservation calculations.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/legacy_models/legacy_mixing_plane/set/conserve_total_enthalpy/verbosity").execute(*args, **kwargs)

            class turbo_topology(TUIMenu):
                """
                Enters the turbo topology menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def mesh_method(self, *args, **kwargs):
                    """
                    Sets turbo structured mesh generation method.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/turbo_topology/mesh_method").execute(*args, **kwargs)
                def define_topology(self, *args, **kwargs):
                    """
                    Defines a turbo topology.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/turbo_topology/define_topology").execute(*args, **kwargs)
                def search_method(self, *args, **kwargs):
                    """
                    Sets search method for a topology.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/turbo_topology/search_method").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Deletes a previously created turbo topology.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/turbo_topology/delete").execute(*args, **kwargs)
                def projection_method(self, *args, **kwargs):
                    """
                    Sets 2D projection method.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/turbo_model/turbo_topology/projection_method").execute(*args, **kwargs)

        class mesh_interfaces(TUIMenu):
            """
            Enters the mesh-interfaces menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.mapped_interface_options = self.__class__.mapped_interface_options(service, version, mode, path + ["mapped_interface_options"])
                self.auto_options = self.__class__.auto_options(service, version, mode, path + ["auto_options"])
                self.non_conformal_interface_numerics = self.__class__.non_conformal_interface_numerics(service, version, mode, path + ["non_conformal_interface_numerics"])
                super().__init__(service, version, mode, path)
            def non_overlapping_zone_name(self, *args, **kwargs):
                """
                Get non-overlapping zone name from the associated interface zone.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/non_overlapping_zone_name").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edits attributes of existing mesh interfaces. For one-to-one interfaces, you can edit the name; for many-to-many interfaces, you can edit the interface options and (for a single interface) the name and the list of interface zones assigned to the interface.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/edit").execute(*args, **kwargs)
            def make_phaselag_from_periodic(self, *args, **kwargs):
                """
                Convert periodic interface to phase lagged.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/make_phaselag_from_periodic").execute(*args, **kwargs)
            def make_phaselag_from_boundaries(self, *args, **kwargs):
                """
                Make interface zones phase lagged.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/make_phaselag_from_boundaries").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Deletes a mesh interface.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/delete").execute(*args, **kwargs)
            def one_to_one_pairing(self, *args, **kwargs):
                """
                Use the default one-to-one interface creation method?.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/one_to_one_pairing").execute(*args, **kwargs)
            def remove_left_handed_interface_faces(self, *args, **kwargs):
                """
                Removes left-handed faces (which can cause the mesh to be invalid) during mesh interface creation.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/remove_left_handed_interface_faces").execute(*args, **kwargs)
            def auto_pairing(self, *args, **kwargs):
                """
                Automatically "pairs" some or all of the interface zones, in order to create mesh interfaces. This text command is only available when the define/mesh-interfaces/one-to-one-pairing? text command is disabled.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/auto_pairing").execute(*args, **kwargs)
            def enforce_continuity_after_bc(self, *args, **kwargs):
                """
                Enables/disables continuity across the boundary condition interface for contour plots in postprocessing.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/enforce_continuity_after_bc").execute(*args, **kwargs)
            def turbo_create(self, *args, **kwargs):
                """
                Creates a general turbo interface. This text command is only available if the define/turbo-model/enable-turbo-model? text command is enabled.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/turbo_create").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                Lists all mesh interfaces.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/list").execute(*args, **kwargs)
            def make_periodic(self, *args, **kwargs):
                """
                Make interface zones periodic.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/make_periodic").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Deletes all mesh interfaces.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/delete_all").execute(*args, **kwargs)
            def enable_visualization_of_interfaces(self, *args, **kwargs):
                """
                Enables/disables the filling of node coordinates on the zones of mesh interfaces, so that they can be displayed in the graphics window.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/enable_visualization_of_interfaces").execute(*args, **kwargs)
            def create(self, *args, **kwargs):
                """
                Creates mesh interfaces.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/create").execute(*args, **kwargs)
            def verbosity(self, *args, **kwargs):
                """
                Sets the mesh interface verbosity.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/verbosity").execute(*args, **kwargs)
            def transfer_motion_across_interfaces(self, *args, **kwargs):
                """
                Enables/disables the automatic transfer of motion across a mesh interface when only one side is moving as a result of user-defined or system coupling motion. You can specify the method by which the motion is transferred: transfer-displacements (the default) interpolates nodal displacement from the active side of the interface to the passive side, and is recommended when there are gaps and/or penetrations in the mesh interface that must be maintained; project-nodes projects the passive nodes onto the faces of active side, and is recommended when the active side includes significant tangential motion (as only the normal displacement is effectively transferred in this method).
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/transfer_motion_across_interfaces").execute(*args, **kwargs)
            def improve_quality(self, *args, **kwargs):
                """
                Checks the quality of all mapped interfaces. If Fluent finds any mapped interfaces that require improvement it will list them and ask you if you would like to increase the tolerance to improve the interfaces.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/improve_quality").execute(*args, **kwargs)
            def enforce_coupled_wall_between_solids(self, *args, **kwargs):
                """
                Enables/disables automatic definition of solid-solid interfaces as coupled walls. By default this option is disabled and ANSYS Fluent creates interior boundaries at solid-solid interfaces.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/enforce_coupled_wall_between_solids").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Displays the specified mesh interface zone.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/display").execute(*args, **kwargs)
            def enable_si_with_nodes(self, *args, **kwargs):
                """
                Enable sliding interfaces with nodes.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/enable_si_with_nodes").execute(*args, **kwargs)

            class mapped_interface_options(TUIMenu):
                """
                Enter the mapped-interface-options menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def solution_controls(self, *args, **kwargs):
                    """
                    Specification of mapped frequency and under-relaxation factor for mapped interfaces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/mapped_interface_options/solution_controls").execute(*args, **kwargs)
                def tolerance(self, *args, **kwargs):
                    """
                    Specification of mapped interface tolerance.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/mapped_interface_options/tolerance").execute(*args, **kwargs)
                def convert_to_mapped_interface(self, *args, **kwargs):
                    """
                    Convert non-conformal mesh interface to mapped mesh interfaces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/mapped_interface_options/convert_to_mapped_interface").execute(*args, **kwargs)

            class auto_options(TUIMenu):
                """
                Enters the auto-options menu. This menu is only available when the define/mesh-interfaces/one-to-one-pairing? text command is enabled.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def keep_empty_interface(self, *args, **kwargs):
                    """
                    Keep empty interfaces during one-to-one mesh interface creation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/auto_options/keep_empty_interface").execute(*args, **kwargs)
                def pairing_between_different_cell_zones_only(self, *args, **kwargs):
                    """
                    Specifies whether the 	one-to-one mesh interfaces are only created between 	different cell zones.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/auto_options/pairing_between_different_cell_zones_only").execute(*args, **kwargs)
                def proximity_tolerance(self, *args, **kwargs):
                    """
                    Sets the tolerance used as part 	of the automatic grouping of zones to create mesh 	interfaces when the define/mesh-interfaces/one-to-one-pairing? 	text command is disabled. The proximity tolerance is 	defined relative to the edge lengths in the interface 	zones, and can range from 0 to 1 (representing the minimum 	and maximum edge lengths, respectively).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/auto_options/proximity_tolerance").execute(*args, **kwargs)
                def pairing_between_interface_zones_only(self, *args, **kwargs):
                    """
                    Pairing between interface zones only.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/auto_options/pairing_between_interface_zones_only").execute(*args, **kwargs)
                def naming_option(self, *args, **kwargs):
                    """
                    Specifies whether the name of each new one-to-one mesh 	interface (as well as existing mesh interfaces, if you 	so desire) has no additional suffix, or a suffix that 	includes the names of the associated boundary zones, the 	IDs of the associated boundary zones, or the names of 	the adjacent cell zones.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/auto_options/naming_option").execute(*args, **kwargs)
                def set_one_to_one_pairing_tolerance(self, *args, **kwargs):
                    """
                    Enables/disables the use of adjustable tolerances to 	determine which of the selected boundary zones can be 	paired up to make the mesh interfaces, in order to 	account for gaps, thin layers, and/or complex 	geometries.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/auto_options/set_one_to_one_pairing_tolerance").execute(*args, **kwargs)
                def set_default_name_prefix(self, *args, **kwargs):
                    """
                    Specifies the default interface 	name prefix used for one-to-one mesh interfaces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/auto_options/set_default_name_prefix").execute(*args, **kwargs)

            class non_conformal_interface_numerics(TUIMenu):
                """
                Setting non-conformal numerics options.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def change_numerics(self, *args, **kwargs):
                    """
                    Enable modified non-conformal interface numerics.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/mesh_interfaces/non_conformal_interface_numerics/change_numerics").execute(*args, **kwargs)

        class profiles(TUIMenu):
            """
            Enters the boundary profiles menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def replicate_profile(self, *args, **kwargs):
                """
                Replicate Profile.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/profiles/replicate_profile").execute(*args, **kwargs)
            def set_preference_profile_point_cloud_data(self, *args, **kwargs):
                """
                Set Preference Profile Point Cloud Data e.g., Point marker symbol,size,color.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/profiles/set_preference_profile_point_cloud_data").execute(*args, **kwargs)
            def list_profile_parameters(self, *args, **kwargs):
                """
                List the parameters of a particular profile.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/profiles/list_profile_parameters").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Deletes all boundary-profiles.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/profiles/delete_all").execute(*args, **kwargs)
            def overlay_profile_surface(self, *args, **kwargs):
                """
                Overlay Profile Surface.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/profiles/overlay_profile_surface").execute(*args, **kwargs)
            def morphing(self, *args, **kwargs):
                """
                Enables/disables profile morphing options in Orient Profile panel.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/profiles/morphing").execute(*args, **kwargs)
            def orient_profile(self, *args, **kwargs):
                """
                Re-orient an existing profile.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/profiles/orient_profile").execute(*args, **kwargs)
            def overlay_profile_point_cloud_data(self, *args, **kwargs):
                """
                Overlay Profile Point Cloud Data.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/profiles/overlay_profile_point_cloud_data").execute(*args, **kwargs)
            def update_interval(self, *args, **kwargs):
                """
                Sets interval between updates of dynamic profiles.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/profiles/update_interval").execute(*args, **kwargs)
            def display_profile_point_cloud_data(self, *args, **kwargs):
                """
                Display Profile Point Cloud Data.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/profiles/display_profile_point_cloud_data").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Deletes a profile.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/profiles/delete").execute(*args, **kwargs)
            def list_profiles(self, *args, **kwargs):
                """
                Lists all profiles.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/profiles/list_profiles").execute(*args, **kwargs)
            def display_profile_surface(self, *args, **kwargs):
                """
                Display the profile as a surface (this option is only available if the specified profile contains node-connectivity data).
                """
                return PyMenu(self._service, self._version, self._mode, "/define/profiles/display_profile_surface").execute(*args, **kwargs)
            def interpolation_method(self, *args, **kwargs):
                """
                Chooses the method for interpolation of profiles.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/profiles/interpolation_method").execute(*args, **kwargs)
            def list_profile_fields(self, *args, **kwargs):
                """
                Lists the fields of a particular profile.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/profiles/list_profile_fields").execute(*args, **kwargs)
            def link_profile_to_reference_frame(self, *args, **kwargs):
                """
                Attaches a profile to a reference frame so that the profile will rotate according to the reference frame.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/profiles/link_profile_to_reference_frame").execute(*args, **kwargs)

        class models(TUIMenu):
            """
            Enters the models menu to configure the solver.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.optics = self.__class__.optics(service, version, mode, path + ["optics"])
                self.heat_exchanger = self.__class__.heat_exchanger(service, version, mode, path + ["heat_exchanger"])
                self.shell_conduction = self.__class__.shell_conduction(service, version, mode, path + ["shell_conduction"])
                self.soot_parameters = self.__class__.soot_parameters(service, version, mode, path + ["soot_parameters"])
                self.multiphase = self.__class__.multiphase(service, version, mode, path + ["multiphase"])
                self.viscous = self.__class__.viscous(service, version, mode, path + ["viscous"])
                self.system_coupling_settings = self.__class__.system_coupling_settings(service, version, mode, path + ["system_coupling_settings"])
                self.acoustics = self.__class__.acoustics(service, version, mode, path + ["acoustics"])
                self.virtual_blade_model = self.__class__.virtual_blade_model(service, version, mode, path + ["virtual_blade_model"])
                self.structure = self.__class__.structure(service, version, mode, path + ["structure"])
                self.nox_parameters = self.__class__.nox_parameters(service, version, mode, path + ["nox_parameters"])
                self.dpm = self.__class__.dpm(service, version, mode, path + ["dpm"])
                self.electrolysis_setup = self.__class__.electrolysis_setup(service, version, mode, path + ["electrolysis_setup"])
                self.eulerian_wallfilm = self.__class__.eulerian_wallfilm(service, version, mode, path + ["eulerian_wallfilm"])
                self.radiation = self.__class__.radiation(service, version, mode, path + ["radiation"])
                self.solver = self.__class__.solver(service, version, mode, path + ["solver"])
                self.species = self.__class__.species(service, version, mode, path + ["species"])
                self.two_temperature = self.__class__.two_temperature(service, version, mode, path + ["two_temperature"])
                self.cht = self.__class__.cht(service, version, mode, path + ["cht"])
                super().__init__(service, version, mode, path)
            def battery_model(self, *args, **kwargs):
                """
                Enables the dual potential MSMD battery model. For text commands that become available when the battery model is enabled, refer to Battery Model Text Commands.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/battery_model").execute(*args, **kwargs)
            def crevice_model(self, *args, **kwargs):
                """
                Enables/disables the crevice model.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/crevice_model").execute(*args, **kwargs)
            def crevice_model_controls(self, *args, **kwargs):
                """
                Enters the crevice model controls menu.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/crevice_model_controls").execute(*args, **kwargs)
            def frozen_flux(self, *args, **kwargs):
                """
                Enables/disables frozen flux formulation for transient flows.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/frozen_flux").execute(*args, **kwargs)
            def unsteady_2nd_order_bounded(self, *args, **kwargs):
                """
                Selects the bounded second-order implicit formulation for transient simulations.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/unsteady_2nd_order_bounded").execute(*args, **kwargs)
            def noniterative_time_advance(self, *args, **kwargs):
                """
                Enables/disables noniterative time advancement scheme.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/noniterative_time_advance").execute(*args, **kwargs)
            def unsteady_2nd_order(self, *args, **kwargs):
                """
                Selects the second-order implicit formulation for transient simulations.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/unsteady_2nd_order").execute(*args, **kwargs)
            def ablation(self, *args, **kwargs):
                """
                Enables/disables the ablation model.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/ablation").execute(*args, **kwargs)
            def unsteady_global_time(self, *args, **kwargs):
                """
                Selects the explicit transient formulation. This text command is only available for unsteady cases that use the density-based solver with the explicit formulation.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/unsteady_global_time").execute(*args, **kwargs)
            def swirl(self, *args, **kwargs):
                """
                Enables/disables axisymmetric swirl velocity.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/swirl").execute(*args, **kwargs)
            def axisymmetric(self, *args, **kwargs):
                """
                Specifies whether or not the domain is axisymmetric.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/axisymmetric").execute(*args, **kwargs)
            def soot(self, *args, **kwargs):
                """
                Enables/disables the soot model.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/soot").execute(*args, **kwargs)
            def addon_module(self, *args, **kwargs):
                """
                Loads addon module.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/addon_module").execute(*args, **kwargs)
            def unsteady_1st_order(self, *args, **kwargs):
                """
                Selects the first-order implicit formulation for transient simulations.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/unsteady_1st_order").execute(*args, **kwargs)
            def solidification_melting(self, *args, **kwargs):
                """
                Enables/disables the solidification and melting model.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/solidification_melting").execute(*args, **kwargs)
            def steady(self, *args, **kwargs):
                """
                Enables/disables the steady solution model.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/steady").execute(*args, **kwargs)
            def energy(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/energy").execute(*args, **kwargs)
            def nox(self, *args, **kwargs):
                """
                Enables/disables the NOx model.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/nox").execute(*args, **kwargs)
            def unsteady_structure_newmark(self, *args, **kwargs):
                """
                Selects the Newmark method for the direct time integration of the finite element semi-discrete equation of motion. This text command is only available for transient simulations that use the structural model.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/unsteady_structure_newmark").execute(*args, **kwargs)
            def unsteady_structure_euler(self, *args, **kwargs):
                """
                Selects the backward Euler method for the direct time integration of the finite element semi-discrete equation of motion. This text command is only available for transient simulations that use the structural model.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/unsteady_structure_euler").execute(*args, **kwargs)
            def potential_and_li_ion_battery(self, *args, **kwargs):
                """
                Enables/disables the electric-potential model.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/models/potential_and_li_ion_battery").execute(*args, **kwargs)

            class optics(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.beams = self.__class__.beams(service, version, mode, path + ["beams"])
                    self.statistics = self.__class__.statistics(service, version, mode, path + ["statistics"])
                    super().__init__(service, version, mode, path)
                def enable(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/optics/enable").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/optics/verbosity").execute(*args, **kwargs)
                def index_of_refraction(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/optics/index_of_refraction").execute(*args, **kwargs)
                def report(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/optics/report").execute(*args, **kwargs)
                def sampling_iterations(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/optics/sampling_iterations").execute(*args, **kwargs)

                class beams(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def edit(self, *args, **kwargs):
                        """
                        Edit beams object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/optics/beams/edit").execute(*args, **kwargs)
                    def rename(self, *args, **kwargs):
                        """
                        Rename beams object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/optics/beams/rename").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete beams object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/optics/beams/delete").execute(*args, **kwargs)
                    def duplicate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/optics/beams/duplicate").execute(*args, **kwargs)
                    def copy(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/optics/beams/copy").execute(*args, **kwargs)
                    def list_properties(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/optics/beams/list_properties").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/optics/beams/list").execute(*args, **kwargs)
                    def add(self, *args, **kwargs):
                        """
                        Create a new beams object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/optics/beams/add").execute(*args, **kwargs)

                class statistics(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def reset_statistics(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/optics/statistics/reset_statistics").execute(*args, **kwargs)
                    def statistics_controls(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/optics/statistics/statistics_controls").execute(*args, **kwargs)

            class heat_exchanger(TUIMenu):
                """
                Enters the heat exchanger menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.macro_model = self.__class__.macro_model(service, version, mode, path + ["macro_model"])
                    self.dual_cell_model = self.__class__.dual_cell_model(service, version, mode, path + ["dual_cell_model"])
                    super().__init__(service, version, mode, path)

                class macro_model(TUIMenu):
                    """
                    Enters the heat macro-model menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def heat_exchanger_group(self, *args, **kwargs):
                        """
                        Defines heat-exchanger group.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/heat_exchanger/macro_model/heat_exchanger_group").execute(*args, **kwargs)
                    def delete_heat_exchanger_group(self, *args, **kwargs):
                        """
                        Deletes heat-exchanger group.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/heat_exchanger/macro_model/delete_heat_exchanger_group").execute(*args, **kwargs)
                    def write_NTU(self, *args, **kwargs):
                        """
                        Writes NTU vs. primary mass flow rate for each auxiliary mass flow rate.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/heat_exchanger/macro_model/write_NTU").execute(*args, **kwargs)
                    def heat_exchanger_report(self, *args, **kwargs):
                        """
                        Reports the computed values of total heat rejection, outlet temperature, and inlet temperature for a specified heat-exchanger core.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/heat_exchanger/macro_model/heat_exchanger_report").execute(*args, **kwargs)
                    def plot_NTU(self, *args, **kwargs):
                        """
                        Plots NTU vs. primary mass flow rate for each auxiliary mass flow rate.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/heat_exchanger/macro_model/plot_NTU").execute(*args, **kwargs)
                    def heat_exchanger_macro_report(self, *args, **kwargs):
                        """
                        Reports the computed values of heat rejection, outlet temperature, and inlet temperature for the macroscopic cells (macros) in a heat exchanger.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/heat_exchanger/macro_model/heat_exchanger_macro_report").execute(*args, **kwargs)
                    def heat_exchanger(self, *args, **kwargs):
                        """
                        Enables/disables heat-exchanger model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/heat_exchanger/macro_model/heat_exchanger").execute(*args, **kwargs)
                    def heat_exchanger_model(self, *args, **kwargs):
                        """
                        Defines heat-exchanger core model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/heat_exchanger/macro_model/heat_exchanger_model").execute(*args, **kwargs)
                    def heat_exchanger_zone(self, *args, **kwargs):
                        """
                        Specifies the zone that represents the heat exchanger, the dimensions of the heat exchanger, the macro grid, and the coolant direction and properties.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/heat_exchanger/macro_model/heat_exchanger_zone").execute(*args, **kwargs)

                class dual_cell_model(TUIMenu):
                    """
                    Enters the dual cell model menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def add_heat_exchanger(self, *args, **kwargs):
                        """
                        Adds heat-exchanger.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/heat_exchanger/dual_cell_model/add_heat_exchanger").execute(*args, **kwargs)
                    def alternative_formulation(self, *args, **kwargs):
                        """
                        Enables/disables alternative formulation for heat transfer calculations.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/heat_exchanger/dual_cell_model/alternative_formulation").execute(*args, **kwargs)
                    def plot_NTU(self, *args, **kwargs):
                        """
                        Plots NTU vs. primary mass flow rate for each auxiliary mass flow rate.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/heat_exchanger/dual_cell_model/plot_NTU").execute(*args, **kwargs)
                    def write_NTU(self, *args, **kwargs):
                        """
                        Writes NTU vs. primary mass flow rate for each auxiliary mass flow rate.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/heat_exchanger/dual_cell_model/write_NTU").execute(*args, **kwargs)
                    def modify_heat_exchanger(self, *args, **kwargs):
                        """
                        Modifies heat-exchanger.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/heat_exchanger/dual_cell_model/modify_heat_exchanger").execute(*args, **kwargs)
                    def delete_heat_exchanger(self, *args, **kwargs):
                        """
                        Deletes heat-exchanger.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/heat_exchanger/dual_cell_model/delete_heat_exchanger").execute(*args, **kwargs)
                    def heat_exchanger(self, *args, **kwargs):
                        """
                        Enables/disables the dual cell heat-exchanger model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/heat_exchanger/dual_cell_model/heat_exchanger").execute(*args, **kwargs)

            class shell_conduction(TUIMenu):
                """
                Enters the shell conduction models menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def enhanced_encapsulation(self, *args, **kwargs):
                    """
                    Enables/disables an enhanced routine for the encapsulation of coupled walls during 	mesh partitioning that is enabled by default when shell 	conduction and/or the surface to surface (S2S) radiation 	model is used.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/shell_conduction/enhanced_encapsulation").execute(*args, **kwargs)
                def save_shell_zones(self, *args, **kwargs):
                    """
                    Enables the saving of shell zones to case 	files.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/shell_conduction/save_shell_zones").execute(*args, **kwargs)
                def read_csv(self, *args, **kwargs):
                    """
                    Defines the shell conduction settings by reading a CSV file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/shell_conduction/read_csv").execute(*args, **kwargs)
                def write_csv(self, *args, **kwargs):
                    """
                    Writes your saved shell conduction settings to a CSV file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/shell_conduction/write_csv").execute(*args, **kwargs)
                def multi_layer_shell(self, *args, **kwargs):
                    """
                    Enables/disables the ability to define multi-layer 	shell conduction for walls. Note that the warped-face 	gradient correction (WFGC) is not supported when 	multi-layer shells are disabled.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/shell_conduction/multi_layer_shell").execute(*args, **kwargs)
                def settings(self, *args, **kwargs):
                    """
                    Enables shell conduction and defines the settings for any wall or group of walls by 	manually entering the number and properties of the 	layers.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/shell_conduction/settings").execute(*args, **kwargs)

            class soot_parameters(TUIMenu):
                """
                Enters the soot parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def inlet_diffusion(self, *args, **kwargs):
                    """
                    Enables/disables inclusion of diffusion at inlets.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/soot_parameters/inlet_diffusion").execute(*args, **kwargs)
                def modify_schmidt_number(self, *args, **kwargs):
                    """
                    Changes the turbulent Schmidt number for soot/nuclei equations.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/soot_parameters/modify_schmidt_number").execute(*args, **kwargs)
                def soot_radiation_interaction(self, *args, **kwargs):
                    """
                    Enables/disables the soot-radiation interaction model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/soot_parameters/soot_radiation_interaction").execute(*args, **kwargs)
                def soot_model_parameters(self, *args, **kwargs):
                    """
                    Selects soot model parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/soot_parameters/soot_model_parameters").execute(*args, **kwargs)
                def soot_process_parameters(self, *args, **kwargs):
                    """
                    Selects soot process parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/soot_parameters/soot_process_parameters").execute(*args, **kwargs)
                def soot_turbulence_interaction(self, *args, **kwargs):
                    """
                    Sets soot-turbulence interaction model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/soot_parameters/soot_turbulence_interaction").execute(*args, **kwargs)
                def soot_model_udfs(self, *args, **kwargs):
                    """
                    User defined functions for soot model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/soot_parameters/soot_model_udfs").execute(*args, **kwargs)

            class multiphase(TUIMenu):
                """
                Enters the multiphase model menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.hybrid_models = self.__class__.hybrid_models(service, version, mode, path + ["hybrid_models"])
                    self.sub_models = self.__class__.sub_models(service, version, mode, path + ["sub_models"])
                    self.flow_regime_modeling = self.__class__.flow_regime_modeling(service, version, mode, path + ["flow_regime_modeling"])
                    self.population_balance = self.__class__.population_balance(service, version, mode, path + ["population_balance"])
                    self.explicit_expert_options = self.__class__.explicit_expert_options(service, version, mode, path + ["explicit_expert_options"])
                    self.wet_steam = self.__class__.wet_steam(service, version, mode, path + ["wet_steam"])
                    super().__init__(service, version, mode, path)
                def volume_fraction_parameters(self, *args, **kwargs):
                    """
                    Volume fraction parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/volume_fraction_parameters").execute(*args, **kwargs)
                def vof_sub_models(self, *args, **kwargs):
                    """
                    Enables the Open Channel sub-model and/or the Open Channel Wave Boundary Condition 	sub-model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/vof_sub_models").execute(*args, **kwargs)
                def number_of_phases(self, *args, **kwargs):
                    """
                    Specifies the number of phases.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/number_of_phases").execute(*args, **kwargs)
                def interface_modeling_options(self, *args, **kwargs):
                    """
                    Specifies interface modeling options.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/interface_modeling_options").execute(*args, **kwargs)
                def coupled_level_set(self, *args, **kwargs):
                    """
                    Enables coupled level set interface tracking method.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/coupled_level_set").execute(*args, **kwargs)
                def eulerian_parameters(self, *args, **kwargs):
                    """
                    Specifies Eulerian parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/eulerian_parameters").execute(*args, **kwargs)
                def body_force_formulation(self, *args, **kwargs):
                    """
                    Specifies body force formulation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/body_force_formulation").execute(*args, **kwargs)
                def mixture_parameters(self, *args, **kwargs):
                    """
                    Specifies mixture parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/mixture_parameters").execute(*args, **kwargs)
                def boiling_model_options(self, *args, **kwargs):
                    """
                    Specifies the boiling model options. You can choose theRPI boiling model,Non-equilibrium boiling, orCritical heat flux.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/boiling_model_options").execute(*args, **kwargs)
                def expert_options(self, *args, **kwargs):
                    """
                    Expert Options.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/expert_options").execute(*args, **kwargs)
                def model(self, *args, **kwargs):
                    """
                    Specifies multiphase model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/model").execute(*args, **kwargs)
                def regime_transition_modeling(self, *args, **kwargs):
                    """
                    Enables the Algebraic Interfacial Area Density (AIAD) 	model and sets the AIAD secondary continuous phase and 	the secondary entrained phase. Entering 0 as a phase ID cancels any 	previous phase selection. Note that you must define the 	phases in your simulation using the define/phases/ text command 	prior to using the regime-transition-modeling 	text command. This option is available only with the 	Eulerian multiphase model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/regime_transition_modeling").execute(*args, **kwargs)

                class hybrid_models(TUIMenu):
                    """
                    Enter the menu to select hybrid models.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def ddpm(self, *args, **kwargs):
                        """
                        Enable the dense discrete phase model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/hybrid_models/ddpm").execute(*args, **kwargs)
                    def multi_fluid_vof(self, *args, **kwargs):
                        """
                        Enable the multi-fluid VOF model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/hybrid_models/multi_fluid_vof").execute(*args, **kwargs)

                class sub_models(TUIMenu):
                    """
                    Enter the menu to select sub-models.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.boiling_options = self.__class__.boiling_options(service, version, mode, path + ["boiling_options"])
                        super().__init__(service, version, mode, path)
                    def boiling(self, *args, **kwargs):
                        """
                        Activate boiling model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/sub_models/boiling").execute(*args, **kwargs)

                    class boiling_options(TUIMenu):
                        """
                        Set boiling options.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def options(self, *args, **kwargs):
                            """
                            Choose the type of boiling model.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/sub_models/boiling_options/options").execute(*args, **kwargs)
                        def nlbf_model(self, *args, **kwargs):
                            """
                            Set the non-local boundary field correction.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/sub_models/boiling_options/nlbf_model").execute(*args, **kwargs)

                class flow_regime_modeling(TUIMenu):
                    """
                    Flow Regime Modeling.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.aiad_parameters = self.__class__.aiad_parameters(service, version, mode, path + ["aiad_parameters"])
                        super().__init__(service, version, mode, path)
                    def enable(self, *args, **kwargs):
                        """
                        Enable flow regime modeling framework including phase state and morphology.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/flow_regime_modeling/enable").execute(*args, **kwargs)

                    class aiad_parameters(TUIMenu):
                        """
                        AIAD parameters.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def ncells_fs(self, *args, **kwargs):
                            """
                            Parameter for determining interfacial width.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/flow_regime_modeling/aiad_parameters/ncells_fs").execute(*args, **kwargs)
                        def critical_vf(self, *args, **kwargs):
                            """
                            Critical volume fraction for bubbly and droplet flow blending factors.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/flow_regime_modeling/aiad_parameters/critical_vf").execute(*args, **kwargs)
                        def delta_grad(self, *args, **kwargs):
                            """
                            Parameter for determining transition width for free surface blending factor.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/flow_regime_modeling/aiad_parameters/delta_grad").execute(*args, **kwargs)
                        def delta_vf(self, *args, **kwargs):
                            """
                            Parameter for transition width for bubbly and droplet flow blending factors.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/flow_regime_modeling/aiad_parameters/delta_vf").execute(*args, **kwargs)

                class population_balance(TUIMenu):
                    """
                    Enters the population balance models menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.phenomena = self.__class__.phenomena(service, version, mode, path + ["phenomena"])
                        self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                        super().__init__(service, version, mode, path)
                    def include_expansion(self, *args, **kwargs):
                        """
                        Set expansion.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/population_balance/include_expansion").execute(*args, **kwargs)
                    def size_calculator(self, *args, **kwargs):
                        """
                        Gives you recommendations for appropriate bubble sizes and/or droplet size limits.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/population_balance/size_calculator").execute(*args, **kwargs)
                    def model(self, *args, **kwargs):
                        """
                        Allows you to select the population balance model and set its parameters.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/population_balance/model").execute(*args, **kwargs)

                    class phenomena(TUIMenu):
                        """
                        Enters the phenomena menu for population balance.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def breakage_aggregation_vof_cutoff(self, *args, **kwargs):
                            """
                            Specifies a cutoff limit for the volume fraction values for the breakage and aggregation kernels.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/population_balance/phenomena/breakage_aggregation_vof_cutoff").execute(*args, **kwargs)
                        def nucleation(self, *args, **kwargs):
                            """
                            Specifies the nucleation rate.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/population_balance/phenomena/nucleation").execute(*args, **kwargs)
                        def growth(self, *args, **kwargs):
                            """
                            Specifies the growth rate.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/population_balance/phenomena/growth").execute(*args, **kwargs)
                        def breakage(self, *args, **kwargs):
                            """
                            Set the breakage kernel.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/population_balance/phenomena/breakage").execute(*args, **kwargs)
                        def aggregation(self, *args, **kwargs):
                            """
                            Sets the aggregation kernel.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/population_balance/phenomena/aggregation").execute(*args, **kwargs)
                        def aggregation_factor(self, *args, **kwargs):
                            """
                            Specifies a factor that controls the intensity of the selected aggregation kernel.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/population_balance/phenomena/aggregation_factor").execute(*args, **kwargs)
                        def breakage_factor(self, *args, **kwargs):
                            """
                            Specifies a factor that controls the intensity of the selected breakage kernel.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/population_balance/phenomena/breakage_factor").execute(*args, **kwargs)

                    class expert(TUIMenu):
                        """
                        Enter the expert menu for quadrature-based population balance method.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.qmom = self.__class__.qmom(service, version, mode, path + ["qmom"])
                            super().__init__(service, version, mode, path)

                        class qmom(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def realizable_moments(self, *args, **kwargs):
                                """
                                Set the population balance model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/population_balance/expert/qmom/realizable_moments").execute(*args, **kwargs)
                            def retain_qmom_sources_for_low_vof(self, *args, **kwargs):
                                """
                                Retain qmom source calculation for low secondary phase vof.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/population_balance/expert/qmom/retain_qmom_sources_for_low_vof").execute(*args, **kwargs)
                            def inversion_algorithm(self, *args, **kwargs):
                                """
                                Select the inversion algorithm for quadrature-based population balance method.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/population_balance/expert/qmom/inversion_algorithm").execute(*args, **kwargs)
                            def print_realizable_moment_warning(self, *args, **kwargs):
                                """
                                Print the information for realizable moments in the population balance model.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/population_balance/expert/qmom/print_realizable_moment_warning").execute(*args, **kwargs)

                class explicit_expert_options(TUIMenu):
                    """
                    Enters the menu to set explicit VOF expert 	options.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.volume_fraction_filtering = self.__class__.volume_fraction_filtering(service, version, mode, path + ["volume_fraction_filtering"])
                        super().__init__(service, version, mode, path)
                    def sub_time_step_method(self, *args, **kwargs):
                        """
                        Selects the sub-time step method.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/explicit_expert_options/sub_time_step_method").execute(*args, **kwargs)
                    def solve_vof_every_iter(self, *args, **kwargs):
                        """
                        If you enter yes, the volume fraction equations will be solved every iteration. By default, the volume fraction equations will be solved only once per time step.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/explicit_expert_options/solve_vof_every_iter").execute(*args, **kwargs)

                    class volume_fraction_filtering(TUIMenu):
                        """
                        Enters the volume fraction filtering menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def filtering_options(self, *args, **kwargs):
                            """
                            Selects the volume fraction filtering method. This command becomes available once the define/models/multiphase/explicit-expert-options/volume-fraction-filtering/enable? text option has been set to yes.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/explicit_expert_options/volume_fraction_filtering/filtering_options").execute(*args, **kwargs)
                        def vol_frac_cutoff(self, *args, **kwargs):
                            """
                            Specifies a cut-off value for the volume fraction filtering. This command becomes available after you select the node averaged cutoff method using the define/models/multiphase/explicit-expert-options/volume-fraction-filtering/filtering-options text command.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/explicit_expert_options/volume_fraction_filtering/vol_frac_cutoff").execute(*args, **kwargs)
                        def enable(self, *args, **kwargs):
                            """
                            Enables/disables the volume fraction filtering treatment.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/explicit_expert_options/volume_fraction_filtering/enable").execute(*args, **kwargs)

                class wet_steam(TUIMenu):
                    """
                    Enters the wet steam model menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.set = self.__class__.set(service, version, mode, path + ["set"])
                        super().__init__(service, version, mode, path)
                    def enable(self, *args, **kwargs):
                        """
                        Enables/disables the wet steam model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/wet_steam/enable").execute(*args, **kwargs)
                    def load_unload_user_defined_wetsteam_library(self, *args, **kwargs):
                        """
                        Loads or unloads user-defined wet steam library.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/wet_steam/load_unload_user_defined_wetsteam_library").execute(*args, **kwargs)
                    def compile_user_defined_wetsteam_functions(self, *args, **kwargs):
                        """
                        Compiles user-defined wet steam library.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/wet_steam/compile_user_defined_wetsteam_functions").execute(*args, **kwargs)

                    class set(TUIMenu):
                        """
                        Enters the set menu for setting wet steam model options.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def zonal_phase_change(self, *args, **kwargs):
                            """
                            Select cell zones where phase change process is active.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/wet_steam/set/zonal_phase_change").execute(*args, **kwargs)
                        def virial_equation(self, *args, **kwargs):
                            """
                            Sets the equation of state for steam to either Vukalovich formulation (default) or Young formulation.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/wet_steam/set/virial_equation").execute(*args, **kwargs)
                        def rgp_tables(self, *args, **kwargs):
                            """
                            Sets the RGP (real gas property) table to be used with the Wet Steam model.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/wet_steam/set/rgp_tables").execute(*args, **kwargs)
                        def stagnation_conditions(self, *args, **kwargs):
                            """
                            Computes stagnation conditions using either gas phase only, or mixture. For details, see .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/wet_steam/set/stagnation_conditions").execute(*args, **kwargs)
                        def max_liquid_mass_fraction(self, *args, **kwargs):
                            """
                            Sets the maximum limit on the condensed liquid-phase mass-fraction to prevent divergence.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/wet_steam/set/max_liquid_mass_fraction").execute(*args, **kwargs)
                        def droplet_growth_rate(self, *args, **kwargs):
                            """
                            S formulation (default) or Hill.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/multiphase/wet_steam/set/droplet_growth_rate").execute(*args, **kwargs)

            class viscous(TUIMenu):
                """
                Enters the viscous model menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.transition_model_options = self.__class__.transition_model_options(service, version, mode, path + ["transition_model_options"])
                    self.geko_options = self.__class__.geko_options(service, version, mode, path + ["geko_options"])
                    self.near_wall_treatment = self.__class__.near_wall_treatment(service, version, mode, path + ["near_wall_treatment"])
                    self.multiphase_turbulence = self.__class__.multiphase_turbulence(service, version, mode, path + ["multiphase_turbulence"])
                    self.turbulence_expert = self.__class__.turbulence_expert(service, version, mode, path + ["turbulence_expert"])
                    self.les_model_options = self.__class__.les_model_options(service, version, mode, path + ["les_model_options"])
                    super().__init__(service, version, mode, path)
                def buoyancy_effects(self, *args, **kwargs):
                    """
                    Enable/disable effects of buoyancy on turbulence.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/buoyancy_effects").execute(*args, **kwargs)
                def ke_easm(self, *args, **kwargs):
                    """
                    Enables/disables the EASM -  turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/ke_easm").execute(*args, **kwargs)
                def low_pressure_boundary_slip(self, *args, **kwargs):
                    """
                    Enables/disables the slip boundary formulation for 	low-pressure gas systems.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/low_pressure_boundary_slip").execute(*args, **kwargs)
                def les_subgrid_vreman(self, *args, **kwargs):
                    """
                    Enable/disable the Vreman subgrid-scale model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/les_subgrid_vreman").execute(*args, **kwargs)
                def add_intermittency_transition_model(self, *args, **kwargs):
                    """
                    Enable/disable the intermittency transition model to account for transitional effects.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/add_intermittency_transition_model").execute(*args, **kwargs)
                def user_defined(self, *args, **kwargs):
                    """
                    Selects user-defined functions to define the turbulent viscosity and the turbulent 	Prandtl and Schmidt numbers.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/user_defined").execute(*args, **kwargs)
                def les_subgrid_rng(self, *args, **kwargs):
                    """
                    Enable/disable the RNG subgrid-scale model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/les_subgrid_rng").execute(*args, **kwargs)
                def kw_buoyancy_effects(self, *args, **kwargs):
                    """
                    Enable/disable effects of buoyancy on k-omega turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/kw_buoyancy_effects").execute(*args, **kwargs)
                def v2f(self, *args, **kwargs):
                    """
                    Enables/disables V2F turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/v2f").execute(*args, **kwargs)
                def kw_geko(self, *args, **kwargs):
                    """
                    Enables/disables the generalized -  (GEKO) turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/kw_geko").execute(*args, **kwargs)
                def k_kl_w(self, *args, **kwargs):
                    """
                    Enables/disables the k-kl-  turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/k_kl_w").execute(*args, **kwargs)
                def geko(self, *args, **kwargs):
                    """
                    Enable/disable the GEKO model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/geko").execute(*args, **kwargs)
                def trans_sst_roughness_correlation(self, *args, **kwargs):
                    """
                    Enables/disables the Transition-SST roughness correlation option.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/trans_sst_roughness_correlation").execute(*args, **kwargs)
                def rsm_or_earsm_geko_option(self, *args, **kwargs):
                    """
                    Enables/disables the RSM version of the GEKO model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/rsm_or_earsm_geko_option").execute(*args, **kwargs)
                def ke1e(self, *args, **kwargs):
                    """
                    Enable/disable the KE1E turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/ke1e").execute(*args, **kwargs)
                def detached_eddy_simulation(self, *args, **kwargs):
                    """
                    Enables/disables detached eddy simulation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/detached_eddy_simulation").execute(*args, **kwargs)
                def rng_swirl_model(self, *args, **kwargs):
                    """
                    Enables/disables swirl corrections for rng-model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/rng_swirl_model").execute(*args, **kwargs)
                def kw_easm(self, *args, **kwargs):
                    """
                    Enables/disables the EASM -  turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/kw_easm").execute(*args, **kwargs)
                def turb_buoyancy_effects(self, *args, **kwargs):
                    """
                    Enables/disables effects of buoyancy on 	turbulence.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turb_buoyancy_effects").execute(*args, **kwargs)
                def rng_differential_visc(self, *args, **kwargs):
                    """
                    Enables/disables the differential-viscosity model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/rng_differential_visc").execute(*args, **kwargs)
                def les_subgrid_smagorinsky(self, *args, **kwargs):
                    """
                    Enables/disables the Smagorinsky-Lilly subgrid-scale model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/les_subgrid_smagorinsky").execute(*args, **kwargs)
                def reynolds_stress_model(self, *args, **kwargs):
                    """
                    Enables/disables the Reynolds-stress turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/reynolds_stress_model").execute(*args, **kwargs)
                def sa_enhanced_wall_treatment(self, *args, **kwargs):
                    """
                    Enables/disables the enhanced wall treatment for the Spalart-Allmaras model. If 	disabled, no smooth blending between the viscous 	sublayer and the log-law formulation is employed, as was 	done in versions previous to Fluent 14.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/sa_enhanced_wall_treatment").execute(*args, **kwargs)
                def user_defined_transition(self, *args, **kwargs):
                    """
                    Sets user-defined transition correlations.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/user_defined_transition").execute(*args, **kwargs)
                def rsm_ssg_pressure_strain(self, *args, **kwargs):
                    """
                    Enables/disables quadratic pressure-strain model in RSM.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/rsm_ssg_pressure_strain").execute(*args, **kwargs)
                def rsm_linear_pressure_strain(self, *args, **kwargs):
                    """
                    Enables/disables the linear pressure-strain model in RSM.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/rsm_linear_pressure_strain").execute(*args, **kwargs)
                def les_subgrid_sigma(self, *args, **kwargs):
                    """
                    Enable/disable the Sigma subgrid-scale model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/les_subgrid_sigma").execute(*args, **kwargs)
                def kw_low_re_correction(self, *args, **kwargs):
                    """
                    Enables/disables the -  low Re option.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/kw_low_re_correction").execute(*args, **kwargs)
                def large_eddy_simulation(self, *args, **kwargs):
                    """
                    Enables/disables large eddy simulation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/large_eddy_simulation").execute(*args, **kwargs)
                def sa_alternate_prod(self, *args, **kwargs):
                    """
                    Enables/disables strain/vorticity production in Spalart-Allmaras model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/sa_alternate_prod").execute(*args, **kwargs)
                def des_limiter_option(self, *args, **kwargs):
                    """
                    Selects the DES limiter option (none, F1, F2, Delayed DES, or Improved Delayed 	DES).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/des_limiter_option").execute(*args, **kwargs)
                def sa_damping(self, *args, **kwargs):
                    """
                    Enables/disables full low-Reynolds number form of Spalart-Allmaras model. This option is only available if your response wasno to sa-enhanced-wall-treatment?.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/sa_damping").execute(*args, **kwargs)
                def mixing_length(self, *args, **kwargs):
                    """
                    Enables/disables mixing-length (algebraic) turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/mixing_length").execute(*args, **kwargs)
                def curvature_correction(self, *args, **kwargs):
                    """
                    Enables/disables the curvature correction.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/curvature_correction").execute(*args, **kwargs)
                def zero_equation_hvac(self, *args, **kwargs):
                    """
                    Enables/disables zero-equation HVAC turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/zero_equation_hvac").execute(*args, **kwargs)
                def sas(self, *args, **kwargs):
                    """
                    Enables/disables Scale-Adaptive Simulation (SAS) in combination with the SST  -  turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/sas").execute(*args, **kwargs)
                def inviscid(self, *args, **kwargs):
                    """
                    Enables/disables inviscid flow model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/inviscid").execute(*args, **kwargs)
                def kw_standard(self, *args, **kwargs):
                    """
                    Enables/disables the standard -  turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/kw_standard").execute(*args, **kwargs)
                def corner_flow_correction_ccorner(self, *args, **kwargs):
                    """
                    Sets the strength of the quadratic term of the corner flow correction. The default 	value is 1. This is available after the corner-flow-correction? 	option is enabled.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/corner_flow_correction_ccorner").execute(*args, **kwargs)
                def add_transition_model(self, *args, **kwargs):
                    """
                    Sets Transition model to account for transitional effects. The default is none, however you can 	select gamma-algebraic or gamma-transport-eqn.  After a transition model has been enabled, you have additional options in the 	submenu transition-model-options.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/add_transition_model").execute(*args, **kwargs)
                def transition_sst(self, *args, **kwargs):
                    """
                    Enables/disables the transition SST turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/transition_sst").execute(*args, **kwargs)
                def laminar(self, *args, **kwargs):
                    """
                    Enables/disables laminar flow model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/laminar").execute(*args, **kwargs)
                def les_dynamic_energy_flux(self, *args, **kwargs):
                    """
                    Enables/disables the dynamic sub-grid scale turbulent Prandtl Number.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/les_dynamic_energy_flux").execute(*args, **kwargs)
                def turb_compressibility(self, *args, **kwargs):
                    """
                    Enables/disables the compressibility correction option.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turb_compressibility").execute(*args, **kwargs)
                def curvature_correction_ccurv(self, *args, **kwargs):
                    """
                    Sets the strength of the curvature correction term. 	The default value is 1. This is available after the curvature-correction? 	option is enabled.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/curvature_correction_ccurv").execute(*args, **kwargs)
                def les_subgrid_dynamic_fvar(self, *args, **kwargs):
                    """
                    Enables/disables the dynamic subgrid-scale mixture fraction variance model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/les_subgrid_dynamic_fvar").execute(*args, **kwargs)
                def les_dynamic_scalar_flux(self, *args, **kwargs):
                    """
                    Enables/disables the dynamic sub-grid scale turbulent Schmidt Number.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/les_dynamic_scalar_flux").execute(*args, **kwargs)
                def kw_shear_correction(self, *args, **kwargs):
                    """
                    Enables/disables the -  shear-flow correction option. This 	text command is only available for the standard  -  model and the stress-omega RSM 	model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/kw_shear_correction").execute(*args, **kwargs)
                def les_subgrid_wmles(self, *args, **kwargs):
                    """
                    Enables/disables the WMLES subgrid-scale model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/les_subgrid_wmles").execute(*args, **kwargs)
                def corner_flow_correction(self, *args, **kwargs):
                    """
                    Enables/disables the corner flow correction.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/corner_flow_correction").execute(*args, **kwargs)
                def kw_bsl(self, *args, **kwargs):
                    """
                    Enables/disables the baseline (BSL) -  turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/kw_bsl").execute(*args, **kwargs)
                def rsm_bsl_based(self, *args, **kwargs):
                    """
                    Enables/disables the stress-BSL Reynolds stress model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/rsm_bsl_based").execute(*args, **kwargs)
                def ke_standard(self, *args, **kwargs):
                    """
                    Enables/disables the standard -  turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/ke_standard").execute(*args, **kwargs)
                def rsm_wall_echo(self, *args, **kwargs):
                    """
                    Enables/disables wall-echo effects in RSM model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/rsm_wall_echo").execute(*args, **kwargs)
                def rsm_omega_based(self, *args, **kwargs):
                    """
                    Enables/disables the stress-omega Reynolds stress model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/rsm_omega_based").execute(*args, **kwargs)
                def les_subgrid_tke(self, *args, **kwargs):
                    """
                    Enables/disables kinetic energy transport subgrid-scale model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/les_subgrid_tke").execute(*args, **kwargs)
                def les_subgrid_wale(self, *args, **kwargs):
                    """
                    Enables/disables WALE subgrid-scale model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/les_subgrid_wale").execute(*args, **kwargs)
                def les_subgrid_wmles_s_minus_omega(self, *args, **kwargs):
                    """
                    Enables/disables the WMLES -  subgrid-scale model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/les_subgrid_wmles_s_minus_omega").execute(*args, **kwargs)
                def ke_rng(self, *args, **kwargs):
                    """
                    Enables/disables the RNG -  turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/ke_rng").execute(*args, **kwargs)
                def ke_realizable(self, *args, **kwargs):
                    """
                    Enables/disables the realizable -  turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/ke_realizable").execute(*args, **kwargs)
                def rsm_solve_tke(self, *args, **kwargs):
                    """
                    Enables/disables the solution of T.K.E. in RSM model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/rsm_solve_tke").execute(*args, **kwargs)
                def kw_wj_bsl_earsm(self, *args, **kwargs):
                    """
                    Enable/disable the EASM k-omega turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/kw_wj_bsl_earsm").execute(*args, **kwargs)
                def spalart_allmaras(self, *args, **kwargs):
                    """
                    Enables/disables Spalart-Allmaras turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/spalart_allmaras").execute(*args, **kwargs)
                def kw_sst(self, *args, **kwargs):
                    """
                    Enables/disables the SST -  turbulence model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/kw_sst").execute(*args, **kwargs)

                class transition_model_options(TUIMenu):
                    """
                    Enters the transition model options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def cbubble_c1(self, *args, **kwargs):
                        """
                        Sets the algebraic transition model coefficient CBUBBLE_C1.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/transition_model_options/cbubble_c1").execute(*args, **kwargs)
                    def rec_max(self, *args, **kwargs):
                        """
                        Sets the algebraic transition model coefficient REC_MAX.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/transition_model_options/rec_max").execute(*args, **kwargs)
                    def critical_reynolds_number_correlation(self, *args, **kwargs):
                        """
                        Sets the critical Reynolds number correlation.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/transition_model_options/critical_reynolds_number_correlation").execute(*args, **kwargs)
                    def ctu_hightu(self, *args, **kwargs):
                        """
                        Sets the algebraic transition model coefficient CTU_HIGHTU.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/transition_model_options/ctu_hightu").execute(*args, **kwargs)
                    def cfpg_hightu(self, *args, **kwargs):
                        """
                        Sets the algebraic transition model coefficient CFPG_HIGHTU.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/transition_model_options/cfpg_hightu").execute(*args, **kwargs)
                    def ctu_lowtu(self, *args, **kwargs):
                        """
                        Sets the algebraic transition model coefficient CTU_LOWTU.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/transition_model_options/ctu_lowtu").execute(*args, **kwargs)
                    def crossflow_transition(self, *args, **kwargs):
                        """
                        Enables/disables the effects of crossflow instability.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/transition_model_options/crossflow_transition").execute(*args, **kwargs)
                    def capg_lowtu(self, *args, **kwargs):
                        """
                        Sets the algebraic transition model coefficient CAPG_LOWTU.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/transition_model_options/capg_lowtu").execute(*args, **kwargs)
                    def cfpg_lowtu(self, *args, **kwargs):
                        """
                        Sets the algebraic transition model coefficient CFPG_LOWTU.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/transition_model_options/cfpg_lowtu").execute(*args, **kwargs)
                    def rec_c2(self, *args, **kwargs):
                        """
                        Sets the algebraic transition model coefficient REC_C2.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/transition_model_options/rec_c2").execute(*args, **kwargs)
                    def cbubble_c2(self, *args, **kwargs):
                        """
                        Sets the algebraic transition model coefficient CBUBBLE_C2.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/transition_model_options/cbubble_c2").execute(*args, **kwargs)
                    def clambda_scale(self, *args, **kwargs):
                        """
                        Sets the algebraic transition model coefficient CLAMBDA_SCALE.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/transition_model_options/clambda_scale").execute(*args, **kwargs)
                    def rec_c1(self, *args, **kwargs):
                        """
                        Sets the algebraic transition model coefficient REC_C1.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/transition_model_options/rec_c1").execute(*args, **kwargs)
                    def rv1_switch(self, *args, **kwargs):
                        """
                        Sets the algebraic transition model coefficient RV1_SWITCH.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/transition_model_options/rv1_switch").execute(*args, **kwargs)
                    def capg_hightu(self, *args, **kwargs):
                        """
                        Sets the algebraic transition model coefficient CAPG_HIGHTU.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/transition_model_options/capg_hightu").execute(*args, **kwargs)

                class geko_options(TUIMenu):
                    """
                    Enters the GEKO model menu..
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def cbf_lam(self, *args, **kwargs):
                        """
                        Setscbf_lam, a part of the blending function and shields the laminar boundary layer.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/geko_options/cbf_lam").execute(*args, **kwargs)
                    def cjet_aux(self, *args, **kwargs):
                        """
                        Setscjet_aux, which allows fine-tuning of the parameter to optimize free jets.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/geko_options/cjet_aux").execute(*args, **kwargs)
                    def csep(self, *args, **kwargs):
                        """
                        Setscsep, the parameter to optimize flow separation from smooth surfaces.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/geko_options/csep").execute(*args, **kwargs)
                    def cmix(self, *args, **kwargs):
                        """
                        Setscmix, the parameter to optimize strength of mixing in free shear flows.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/geko_options/cmix").execute(*args, **kwargs)
                    def wall_distance_free(self, *args, **kwargs):
                        """
                        Enables/disables the wall distance free version of the GEKO model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/geko_options/wall_distance_free").execute(*args, **kwargs)
                    def cnw_sub(self, *args, **kwargs):
                        """
                        Setscnw_sub, which allows the adjustment of log-layer and cf.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/geko_options/cnw_sub").execute(*args, **kwargs)
                    def cbf_tur(self, *args, **kwargs):
                        """
                        Setscbf_tur, a factor for the main blending factor, controlling the thickness of the layer near walls.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/geko_options/cbf_tur").execute(*args, **kwargs)
                    def cnw(self, *args, **kwargs):
                        """
                        Setscnw, the parameter to optimize flow in non-equilibrium near wall regions.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/geko_options/cnw").execute(*args, **kwargs)
                    def geko_defaults(self, *args, **kwargs):
                        """
                        Restores the defaults of all GEKO parameters.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/geko_options/geko_defaults").execute(*args, **kwargs)
                    def cjet(self, *args, **kwargs):
                        """
                        Setscjet, the parameter to optimize free shear layer mixing (optimize free jets independent of mixing layer).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/geko_options/cjet").execute(*args, **kwargs)
                    def blending_function(self, *args, **kwargs):
                        """
                        Sets the blending function, which deactivatescmix and cjet inside boundary layers.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/geko_options/blending_function").execute(*args, **kwargs)
                    def creal(self, *args, **kwargs):
                        """
                        Setscreal, a realizability limiter that ensures positive normal stresses in the entire domain.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/geko_options/creal").execute(*args, **kwargs)

                class near_wall_treatment(TUIMenu):
                    """
                    Enters the near wall treatment menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def werner_wengle_wall_fn(self, *args, **kwargs):
                        """
                        Enables/disables Werner-Wengle wall functions.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/near_wall_treatment/werner_wengle_wall_fn").execute(*args, **kwargs)
                    def wf_thermal_effects(self, *args, **kwargs):
                        """
                        Enables/disables wall function thermal effects.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/near_wall_treatment/wf_thermal_effects").execute(*args, **kwargs)
                    def wf_pressure_gradient_effects(self, *args, **kwargs):
                        """
                        Enables/disables wall function pressure- gradient effects.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/near_wall_treatment/wf_pressure_gradient_effects").execute(*args, **kwargs)
                    def menter_lechner(self, *args, **kwargs):
                        """
                        Enables/disables the Menter-Lechner near-wall treatment.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/near_wall_treatment/menter_lechner").execute(*args, **kwargs)
                    def wall_omega_treatment(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/near_wall_treatment/wall_omega_treatment").execute(*args, **kwargs)
                    def enhanced_wall_treatment(self, *args, **kwargs):
                        """
                        Enables/disables enhanced wall functions.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/near_wall_treatment/enhanced_wall_treatment").execute(*args, **kwargs)
                    def scalable_wall_functions(self, *args, **kwargs):
                        """
                        Enables/disables scalable wall functions.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/near_wall_treatment/scalable_wall_functions").execute(*args, **kwargs)
                    def non_equilibrium_wall_fn(self, *args, **kwargs):
                        """
                        Enables/disables non-equilibrium wall functions.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/near_wall_treatment/non_equilibrium_wall_fn").execute(*args, **kwargs)
                    def user_defined_wall_functions(self, *args, **kwargs):
                        """
                        Enables/disables user-defined wall functions.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/near_wall_treatment/user_defined_wall_functions").execute(*args, **kwargs)

                class multiphase_turbulence(TUIMenu):
                    """
                    Enters the multiphase turbulence menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def multiphase_options(self, *args, **kwargs):
                        """
                        Enables/disables multiphase options.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/multiphase_turbulence/multiphase_options").execute(*args, **kwargs)
                    def subgrid_turbulence_contribution_aiad(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/multiphase_turbulence/subgrid_turbulence_contribution_aiad").execute(*args, **kwargs)
                    def rsm_multiphase_models(self, *args, **kwargs):
                        """
                        Selects Reynolds Stress multiphase model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/multiphase_turbulence/rsm_multiphase_models").execute(*args, **kwargs)
                    def turbulence_multiphase_models(self, *args, **kwargs):
                        """
                        Selects -  multiphase model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/multiphase_turbulence/turbulence_multiphase_models").execute(*args, **kwargs)

                class turbulence_expert(TUIMenu):
                    """
                    Enters the turbulence expert menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def thermal_p_function(self, *args, **kwargs):
                        """
                        Enables/disables Jayatilleke P function.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/thermal_p_function").execute(*args, **kwargs)
                    def sbes_update_interval_k_omega(self, *args, **kwargs):
                        """
                        Sets the number of time steps between updates of the k- part of the SBES model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/sbes_update_interval_k_omega").execute(*args, **kwargs)
                    def turb_pk_compressible(self, *args, **kwargs):
                        """
                        Enables/disables turbulent production due to compressible divergence.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/turb_pk_compressible").execute(*args, **kwargs)
                    def low_re_ke_index(self, *args, **kwargs):
                        """
                        Specifies which low-Reynolds-number -  model is to be used. Six models are available:
                        Index
                        Model
                        0
                        Abid
                        1
                        Lam-Bremhorst
                        2
                        Launder-Sharma
                        3
                        Yang-Shih
                        4
                        Abe-Kondoh-Nagano
                        5
                        Chang-Hsieh-Chen
                        Contact your Ansys, Inc. technical support engineer for more details.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/low_re_ke_index").execute(*args, **kwargs)
                    def curvature_correction_coefficient(self, *args, **kwargs):
                        """
                        Set the strength of the curvature correction term. The default value is 1.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/curvature_correction_coefficient").execute(*args, **kwargs)
                    def kw_add_des(self, *args, **kwargs):
                        """
                        Enables/disables Detached Eddy Simulation (DES) in combination with the currently selected BSL -  model or transition SST model. This text command is only available for transient cases.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/kw_add_des").execute(*args, **kwargs)
                    def turb_non_newtonian(self, *args, **kwargs):
                        """
                        Enables/disables turbulence for non-Newtonian fluids.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/turb_non_newtonian").execute(*args, **kwargs)
                    def sbes_les_subgrid_dynamic_fvar(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/sbes_les_subgrid_dynamic_fvar").execute(*args, **kwargs)
                    def kato_launder_model(self, *args, **kwargs):
                        """
                        Enables/disables Kato-Launder modification.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/kato_launder_model").execute(*args, **kwargs)
                    def restore_sst_v61(self, *args, **kwargs):
                        """
                        Enables/disables SST formulation of v6.1.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/restore_sst_v61").execute(*args, **kwargs)
                    def kw_add_sas(self, *args, **kwargs):
                        """
                        Enables/disables Scale-Adaptive Simulation (SAS) in combination with the currently selected -based URANS turbulence model. This text command is only available for transient cases.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/kw_add_sas").execute(*args, **kwargs)
                    def turbulence_damping(self, *args, **kwargs):
                        """
                        Enables/disables turbulence damping and sets turbulence damping parameters.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/turbulence_damping").execute(*args, **kwargs)
                    def low_re_ke(self, *args, **kwargs):
                        """
                        Enables/disables the low-Re -  turbulence model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/low_re_ke").execute(*args, **kwargs)
                    def sbes_sdes_hybrid_model(self, *args, **kwargs):
                        """
                        Selects the hybrid model, to specify whether you want to apply the Shielded Detached Eddy Simulation (SDES) model, Stress-Blended Eddy Simulation (SBES), or SBES with a user-defined function.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/sbes_sdes_hybrid_model").execute(*args, **kwargs)
                    def production_limiter(self, *args, **kwargs):
                        """
                        Enables/disables Production Limiter modification.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/production_limiter").execute(*args, **kwargs)
                    def kw_vorticity_based_production(self, *args, **kwargs):
                        """
                        Enables/disables vorticity-based production.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/kw_vorticity_based_production").execute(*args, **kwargs)
                    def turb_add_sbes_sdes(self, *args, **kwargs):
                        """
                        Enables/disables the Stress-Blended Eddy Simulation (SBES) model or Shielded Detached Eddy Simulation (SDES) model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/turb_add_sbes_sdes").execute(*args, **kwargs)
                    def non_newtonian_modification(self, *args, **kwargs):
                        """
                        Enables/disables non-Newtonian modification for Lam-Bremhorst model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/non_newtonian_modification").execute(*args, **kwargs)
                    def rke_cmu_rotation_term(self, *args, **kwargs):
                        """
                        Modifies the  definition for the realizable  -  model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/rke_cmu_rotation_term").execute(*args, **kwargs)
                    def sbes_sgs_option(self, *args, **kwargs):
                        """
                        Selects the subgrid-scale model for the LES portion of your Stress-Blended Eddy Simulation (SBES).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/turbulence_expert/sbes_sgs_option").execute(*args, **kwargs)

                class les_model_options(TUIMenu):
                    """
                    Enter the LES model options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def cw2(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/les_model_options/cw2").execute(*args, **kwargs)
                    def cw1(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/les_model_options/cw1").execute(*args, **kwargs)
                    def csigma(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/les_model_options/csigma").execute(*args, **kwargs)
                    def cvreman(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/les_model_options/cvreman").execute(*args, **kwargs)
                    def wall_model(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/viscous/les_model_options/wall_model").execute(*args, **kwargs)

            class system_coupling_settings(TUIMenu):
                """
                Enters the system coupling menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.htc = self.__class__.htc(service, version, mode, path + ["htc"])
                    super().__init__(service, version, mode, path)
                def user_defined_coupling_variables_via_udm(self, *args, **kwargs):
                    """
                    User defined coupling variables via UDM.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/system_coupling_settings/user_defined_coupling_variables_via_udm").execute(*args, **kwargs)
                def use_face_or_element_based_data_transfer(self, *args, **kwargs):
                    """
                    Answering yes at the prompt 	enables Fluent to use element data for mapping surface 	conservative quantities such as surface forces and heat 	flows.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/system_coupling_settings/use_face_or_element_based_data_transfer").execute(*args, **kwargs)
                def update_rigid_body_mesh_motion_before_mesh_transfer(self, *args, **kwargs):
                    """
                    SC Enable/disable mesh motion.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/system_coupling_settings/update_rigid_body_mesh_motion_before_mesh_transfer").execute(*args, **kwargs)
                def specify_system_coupling_volumetric_cell_zones(self, *args, **kwargs):
                    """
                    Enable/disable volumetric cell zones.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/system_coupling_settings/specify_system_coupling_volumetric_cell_zones").execute(*args, **kwargs)

                class htc(TUIMenu):
                    """
                    Enter the heat transfer coeficient menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.unsteady_statistics = self.__class__.unsteady_statistics(service, version, mode, path + ["unsteady_statistics"])
                        self.htc_calculation_method = self.__class__.htc_calculation_method(service, version, mode, path + ["htc_calculation_method"])
                        super().__init__(service, version, mode, path)

                    class unsteady_statistics(TUIMenu):
                        """
                        Enter the unsteady statistics menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def sc_enable_sub_stepping_option_per_coupling_step(self, *args, **kwargs):
                            """
                            Enable/disable sub stepping option per coupling step.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/system_coupling_settings/htc/unsteady_statistics/sc_enable_sub_stepping_option_per_coupling_step").execute(*args, **kwargs)

                    class htc_calculation_method(TUIMenu):
                        """
                        Enter the htc calculation menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def use_yplus_based_htc_calculation(self, *args, **kwargs):
                            """
                            Enable/disable yplus in htc computation.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/system_coupling_settings/htc/htc_calculation_method/use_yplus_based_htc_calculation").execute(*args, **kwargs)
                        def use_tref_in_htc_calculation(self, *args, **kwargs):
                            """
                            Enable/disable tref in htc computation.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/system_coupling_settings/htc/htc_calculation_method/use_tref_in_htc_calculation").execute(*args, **kwargs)
                        def use_wall_function_based_htc(self, *args, **kwargs):
                            """
                            Enable/disable wall function based htc computation.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/system_coupling_settings/htc/htc_calculation_method/use_wall_function_based_htc").execute(*args, **kwargs)

            class acoustics(TUIMenu):
                """
                Enters the acoustics menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.sources_fft = self.__class__.sources_fft(service, version, mode, path + ["sources_fft"])
                    self.far_field_parameters = self.__class__.far_field_parameters(service, version, mode, path + ["far_field_parameters"])
                    self.sponge_layers = self.__class__.sponge_layers(service, version, mode, path + ["sponge_layers"])
                    self.wave_equation_options = self.__class__.wave_equation_options(service, version, mode, path + ["wave_equation_options"])
                    super().__init__(service, version, mode, path)
                def moving_receiver(self, *args, **kwargs):
                    """
                    Enables/disables the moving receiver option.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/moving_receiver").execute(*args, **kwargs)
                def convective_effects(self, *args, **kwargs):
                    """
                    Enables/disables the convective effects option.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/convective_effects").execute(*args, **kwargs)
                def export_volumetric_sources(self, *args, **kwargs):
                    """
                    Enables/disables the export of fluid zones.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/export_volumetric_sources").execute(*args, **kwargs)
                def acoustic_modal_analysis(self, *args, **kwargs):
                    """
                    Iterate linear acoustic solver to compute the resonance frequencies and the acoustic modes.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/acoustic_modal_analysis").execute(*args, **kwargs)
                def modal_analysis(self, *args, **kwargs):
                    """
                    Enable/disable the modal analysis model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/modal_analysis").execute(*args, **kwargs)
                def export_source_data(self, *args, **kwargs):
                    """
                    Enables/disables the export of acoustic source data in 	ASD format during the wave equation model run.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/export_source_data").execute(*args, **kwargs)
                def wave_equation(self, *args, **kwargs):
                    """
                    Enables/disables the wave equation model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/wave_equation").execute(*args, **kwargs)
                def compute_write(self, *args, **kwargs):
                    """
                    Computes sound pressure.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/compute_write").execute(*args, **kwargs)
                def write_acoustic_signals(self, *args, **kwargs):
                    """
                    Writes on-the-fly sound pressure.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/write_acoustic_signals").execute(*args, **kwargs)
                def write_centroid_info(self, *args, **kwargs):
                    """
                    Writes centroid info.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/write_centroid_info").execute(*args, **kwargs)
                def auto_prune(self, *args, **kwargs):
                    """
                    Enables/disables auto prune of the receiver signal(s) during 	read-and-compute.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/auto_prune").execute(*args, **kwargs)
                def broad_band_noise(self, *args, **kwargs):
                    """
                    Enables/disables the broadband noise model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/broad_band_noise").execute(*args, **kwargs)
                def ffowcs_williams(self, *args, **kwargs):
                    """
                    Enables/disables the Ffowcs-Williams-and-Hawkings model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/ffowcs_williams").execute(*args, **kwargs)
                def display_flow_time(self, *args, **kwargs):
                    """
                    Enables/disables the display of flow time during read-and-compute.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/display_flow_time").execute(*args, **kwargs)
                def display_frequencies(self, *args, **kwargs):
                    """
                    Display resonance frequencies.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/display_frequencies").execute(*args, **kwargs)
                def cylindrical_export(self, *args, **kwargs):
                    """
                    Enables/disables the export of data in cylindrical coordinates.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/cylindrical_export").execute(*args, **kwargs)
                def sources(self, *args, **kwargs):
                    """
                    Sets acoustic sources.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sources").execute(*args, **kwargs)
                def export_volumetric_sources_cgns(self, *args, **kwargs):
                    """
                    Enables/disables the export of fluid zones.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/export_volumetric_sources_cgns").execute(*args, **kwargs)
                def read_compute_write(self, *args, **kwargs):
                    """
                    Reads acoustic source data files and computes sound pressure.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/read_compute_write").execute(*args, **kwargs)
                def off(self, *args, **kwargs):
                    """
                    Enables/disables the acoustics model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/off").execute(*args, **kwargs)
                def export_source_data_cgns(self, *args, **kwargs):
                    """
                    Enables/disables the export of acoustic source data in CGNS format.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/export_source_data_cgns").execute(*args, **kwargs)
                def receivers(self, *args, **kwargs):
                    """
                    Sets acoustic receivers.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/receivers").execute(*args, **kwargs)

                class sources_fft(TUIMenu):
                    """
                    Enters the acoustic sources fast Fourier transform (FFT) menu, to compute Fourier 	spectra from acoustic source data (ASD) files, create 	postprocessing variables for the pressure signals, and 	write CGNS files of the spectrum data.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.fft_surface_variables = self.__class__.fft_surface_variables(service, version, mode, path + ["fft_surface_variables"])
                        super().__init__(service, version, mode, path)
                    def compute_fft_fields(self, *args, **kwargs):
                        """
                        Computes FFT of the read pressure histories. The computed spectra replace the pressure histories in memory.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sources_fft/compute_fft_fields").execute(*args, **kwargs)
                    def clean_up_storage_area(self, *args, **kwargs):
                        """
                        De-allocates memory used to store the pressure histories and their Fourier spectra, as well as any created surface variables for the visualization.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sources_fft/clean_up_storage_area").execute(*args, **kwargs)
                    def read_asd_files(self, *args, **kwargs):
                        """
                        Reads ASD files to perform FFT of the pressure history field.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sources_fft/read_asd_files").execute(*args, **kwargs)
                    def write_cgns_files(self, *args, **kwargs):
                        """
                        Writes surface pressure spectra in CGNS format, which can be used for one-way coupling with Ansys Mechanical in the frequency domain.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sources_fft/write_cgns_files").execute(*args, **kwargs)

                    class fft_surface_variables(TUIMenu):
                        """
                        Enters the menu to create surface variables from the computed Fourier spectra for visualization.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def remove_variables(self, *args, **kwargs):
                            """
                            Removes all variables created in this menu.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sources_fft/fft_surface_variables/remove_variables").execute(*args, **kwargs)
                        def create_set_of_modes(self, *args, **kwargs):
                            """
                            Selects up to 20 individual Fourier modes and create variable pairs for them, containing the real and the imaginary parts of the complex Fourier amplitudes.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sources_fft/fft_surface_variables/create_set_of_modes").execute(*args, **kwargs)
                        def create_third_bands(self, *args, **kwargs):
                            """
                            Creates either the surface pressure level (SPL) variables or the PSD of dp/dt variables for 54 technical thirds.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sources_fft/fft_surface_variables/create_third_bands").execute(*args, **kwargs)
                        def create_octave_bands(self, *args, **kwargs):
                            """
                            Creates either the surface pressure level (SPL) variables or the PSD of dp/dt variables for 17 technical octaves.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sources_fft/fft_surface_variables/create_octave_bands").execute(*args, **kwargs)
                        def create_constant_width_bands(self, *args, **kwargs):
                            """
                            Selects up to 20 constant width bands and creates either the surface pressures level (SPL) variables or the PSD of dp/dt variables for them.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sources_fft/fft_surface_variables/create_constant_width_bands").execute(*args, **kwargs)

                class far_field_parameters(TUIMenu):
                    """
                    Enters the menu to specify the far-field density and 	speed of sound. Note that this menu is currently 	available only with the acoustics wave equation model.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def far_field_sound_speed(self, *args, **kwargs):
                        """
                        Specifies the far-field speed of sound value for the acoustics wave equation model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/far_field_parameters/far_field_sound_speed").execute(*args, **kwargs)
                    def far_field_density(self, *args, **kwargs):
                        """
                        Specifies the far-field density value for the acoustics wave equation model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/far_field_parameters/far_field_density").execute(*args, **kwargs)

                class sponge_layers(TUIMenu):
                    """
                    Manage sponge layers where density is blended to eliminate reflections from boundary zones.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def list_active(self, *args, **kwargs):
                        """
                        List the names of the active sponge layer definitions.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sponge_layers/list_active").execute(*args, **kwargs)
                    def deactivate(self, *args, **kwargs):
                        """
                        Deactivate a sponge layer definition.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sponge_layers/deactivate").execute(*args, **kwargs)
                    def edit(self, *args, **kwargs):
                        """
                        Edits an existing sponge layer. You can revise the fields listed previously for the define/models/acoustics/sponge-layers/add text command.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sponge_layers/edit").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        Prints a list of the existing sponge layers in the console.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sponge_layers/list").execute(*args, **kwargs)
                    def list_properties(self, *args, **kwargs):
                        """
                        Prints the properties of an existing sponge layer of your choice in the console.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sponge_layers/list_properties").execute(*args, **kwargs)
                    def add(self, *args, **kwargs):
                        """
                        Add a new sponge layer definition.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sponge_layers/add").execute(*args, **kwargs)
                    def activate(self, *args, **kwargs):
                        """
                        Activate a sponge object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sponge_layers/activate").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Deletes an existing sponge layer definition.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/sponge_layers/delete").execute(*args, **kwargs)

                class wave_equation_options(TUIMenu):
                    """
                    Enters the menu to define the acoustics wave equation 	model options.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.remote_receivers_options = self.__class__.remote_receivers_options(service, version, mode, path + ["remote_receivers_options"])
                        self.basic_shapes = self.__class__.basic_shapes(service, version, mode, path + ["basic_shapes"])
                        super().__init__(service, version, mode, path)
                    def sponge_layer_base_level(self, *args, **kwargs):
                        """
                        Specify artificial viscosity base level applied everywhere.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/wave_equation_options/sponge_layer_base_level").execute(*args, **kwargs)
                    def sponge_layer_factor(self, *args, **kwargs):
                        """
                        Specifies the factor of the artificial viscosity coefficient.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/wave_equation_options/sponge_layer_factor").execute(*args, **kwargs)
                    def source_mask_udf(self, *args, **kwargs):
                        """
                        Specifies the name of a user-defined function, which defines geometry of the source mask.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/wave_equation_options/source_mask_udf").execute(*args, **kwargs)
                    def remote_receivers(self, *args, **kwargs):
                        """
                        Enables/disables the Kirchhoff integral model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/wave_equation_options/remote_receivers").execute(*args, **kwargs)
                    def sponge_layer_udf(self, *args, **kwargs):
                        """
                        Specifies the name of a user-defined function, which defines geometry of the sponge layer.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/wave_equation_options/sponge_layer_udf").execute(*args, **kwargs)
                    def time_filter_source(self, *args, **kwargs):
                        """
                        Enables/disables a time filter for the sound source.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/wave_equation_options/time_filter_source").execute(*args, **kwargs)

                    class remote_receivers_options(TUIMenu):
                        """
                        Enters the menu to define remote receivers for the Kirchhoff integral model.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def write_signals(self, *args, **kwargs):
                            """
                            Writes the computed receiver signals to the ASCII files.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/wave_equation_options/remote_receivers_options/write_signals").execute(*args, **kwargs)
                        def integration_surface(self, *args, **kwargs):
                            """
                            Selects the integration surface for the Kirchhoff model.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/wave_equation_options/remote_receivers_options/integration_surface").execute(*args, **kwargs)

                    class basic_shapes(TUIMenu):
                        """
                        Enters the menu to define the geometry of the source mask and sponge layer using the basic shapes, represented by the cell registers of the type "Region".
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def remove_source_mask_shape(self, *args, **kwargs):
                            """
                            Remove a basic shape from the definition of the source mask geometry.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/wave_equation_options/basic_shapes/remove_source_mask_shape").execute(*args, **kwargs)
                        def list_region_registers(self, *args, **kwargs):
                            """
                            List all available cell registers of the type "Region".
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/wave_equation_options/basic_shapes/list_region_registers").execute(*args, **kwargs)
                        def add_source_mask_shape(self, *args, **kwargs):
                            """
                            Adds a basic shape to the definition of the source mask geometry.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/wave_equation_options/basic_shapes/add_source_mask_shape").execute(*args, **kwargs)
                        def add_sponge_layer_shape(self, *args, **kwargs):
                            """
                            Adds a basic shape to the definition of the sponge layer geometry.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/wave_equation_options/basic_shapes/add_sponge_layer_shape").execute(*args, **kwargs)
                        def remove_sponge_layer_shape(self, *args, **kwargs):
                            """
                            Remove a basic shape from the definition of the sponge layer geometry.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/wave_equation_options/basic_shapes/remove_sponge_layer_shape").execute(*args, **kwargs)
                        def list_source_mask_shapes(self, *args, **kwargs):
                            """
                            List basic shapes, which are currently used in the definition of the source mask geometry.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/wave_equation_options/basic_shapes/list_source_mask_shapes").execute(*args, **kwargs)
                        def list_sponge_layer_shapes(self, *args, **kwargs):
                            """
                            List basic shapes, which are currently used in the definition of the sponge layer geometry.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/acoustics/wave_equation_options/basic_shapes/list_sponge_layer_shapes").execute(*args, **kwargs)

            class virtual_blade_model(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.rotor = self.__class__.rotor(service, version, mode, path + ["rotor"])
                    super().__init__(service, version, mode, path)
                def mode(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/virtual_blade_model/mode").execute(*args, **kwargs)
                def apply(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/virtual_blade_model/apply").execute(*args, **kwargs)
                def enable(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/virtual_blade_model/enable").execute(*args, **kwargs)

                class rotor(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def list(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/virtual_blade_model/rotor/list").execute(*args, **kwargs)
                    def list_properties(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/virtual_blade_model/rotor/list_properties").execute(*args, **kwargs)
                    def rename(self, *args, **kwargs):
                        """
                        Rename rotor object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/virtual_blade_model/rotor/rename").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete rotor object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/virtual_blade_model/rotor/delete").execute(*args, **kwargs)
                    def new(self, *args, **kwargs):
                        """
                        Create a new rotor object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/virtual_blade_model/rotor/new").execute(*args, **kwargs)
                    def duplicate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/virtual_blade_model/rotor/duplicate").execute(*args, **kwargs)
                    def edit(self, *args, **kwargs):
                        """
                        Edit rotor object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/virtual_blade_model/rotor/edit").execute(*args, **kwargs)

            class structure(TUIMenu):
                """
                Enters the structure model menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.controls = self.__class__.controls(service, version, mode, path + ["controls"])
                    super().__init__(service, version, mode, path)
                def linear_elasticity(self, *args, **kwargs):
                    """
                    Enables the linear elasticity model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/structure/linear_elasticity").execute(*args, **kwargs)
                def structure_off(self, *args, **kwargs):
                    """
                    Disables the structural model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/structure/structure_off").execute(*args, **kwargs)
                def thermal_effects(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/structure/thermal_effects").execute(*args, **kwargs)
                def nonlinear_elasticity(self, *args, **kwargs):
                    """
                    Enable the nonlinear elasticity model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/structure/nonlinear_elasticity").execute(*args, **kwargs)

                class expert(TUIMenu):
                    """
                    Enters the structure expert menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def include_viscous_fsi_force(self, *args, **kwargs):
                        """
                        Enables/disables the inclusion of a viscous fluid-structure interaction force.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/structure/expert/include_viscous_fsi_force").execute(*args, **kwargs)
                    def explicit_fsi_force(self, *args, **kwargs):
                        """
                        Enables/disables an explicit fluid-structure interaction force.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/structure/expert/explicit_fsi_force").execute(*args, **kwargs)
                    def steady_2way_fsi(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/structure/expert/steady_2way_fsi").execute(*args, **kwargs)
                    def starting_t_re_initialization(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/structure/expert/starting_t_re_initialization").execute(*args, **kwargs)
                    def include_pop_in_fsi_force(self, *args, **kwargs):
                        """
                        Enables/disables the inclusion of operating pressure into the fluid-structure interaction force.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/structure/expert/include_pop_in_fsi_force").execute(*args, **kwargs)

                class controls(TUIMenu):
                    """
                    Enters the structure controls menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def unsteady_damping_rayleigh(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/structure/controls/unsteady_damping_rayleigh").execute(*args, **kwargs)
                    def max_iter(self, *args, **kwargs):
                        """
                        Sets the maximum number of iterations for the structural model calculations.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/structure/controls/max_iter").execute(*args, **kwargs)
                    def numerical_damping_factor(self, *args, **kwargs):
                        """
                        Sets the damping factor for the structural model (that is, the amplitude decay factor  in  in the Theory Guide).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/structure/controls/numerical_damping_factor").execute(*args, **kwargs)
                    def amg_stabilization(self, *args, **kwargs):
                        """
                        Sets the algebraic multigrid (AMG) stabilization method for the structural model calculations.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/structure/controls/amg_stabilization").execute(*args, **kwargs)
                    def enhanced_strain(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/structure/controls/enhanced_strain").execute(*args, **kwargs)

            class nox_parameters(TUIMenu):
                """
                Enters the NOx parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def inlet_diffusion(self, *args, **kwargs):
                    """
                    Enables/disables inclusion of diffusion at inlets.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/nox_parameters/inlet_diffusion").execute(*args, **kwargs)
                def nox_turbulence_interaction(self, *args, **kwargs):
                    """
                    Sets NOx turbulence interaction model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/nox_parameters/nox_turbulence_interaction").execute(*args, **kwargs)
                def nox_chemistry(self, *args, **kwargs):
                    """
                    Selects NOx chemistry model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/nox_parameters/nox_chemistry").execute(*args, **kwargs)
                def nox_expert(self, *args, **kwargs):
                    """
                    Selects additional NOx equations.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/nox_parameters/nox_expert").execute(*args, **kwargs)

            class dpm(TUIMenu):
                """
                Enters the dispersed phase model menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.numerics = self.__class__.numerics(service, version, mode, path + ["numerics"])
                    self.stripping_options = self.__class__.stripping_options(service, version, mode, path + ["stripping_options"])
                    self.collisions = self.__class__.collisions(service, version, mode, path + ["collisions"])
                    self.parallel = self.__class__.parallel(service, version, mode, path + ["parallel"])
                    self.interaction = self.__class__.interaction(service, version, mode, path + ["interaction"])
                    self.erosion_dynamic_mesh = self.__class__.erosion_dynamic_mesh(service, version, mode, path + ["erosion_dynamic_mesh"])
                    self.splash_options = self.__class__.splash_options(service, version, mode, path + ["splash_options"])
                    self.options = self.__class__.options(service, version, mode, path + ["options"])
                    super().__init__(service, version, mode, path)
                def injections(self, *args, **kwargs):
                    """
                    Enters the injections menu.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/injections").execute(*args, **kwargs)
                def fill_injection_material_sources(self, *args, **kwargs):
                    """
                    Initialize the DPM sources corresponding to each material.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/fill_injection_material_sources").execute(*args, **kwargs)
                def user_defined(self, *args, **kwargs):
                    """
                    Sets DPM user-defined functions.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/user_defined").execute(*args, **kwargs)
                def clear_particles_from_domain(self, *args, **kwargs):
                    """
                    Removes/keeps all particles currently in the domain.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/clear_particles_from_domain").execute(*args, **kwargs)
                def unsteady_tracking(self, *args, **kwargs):
                    """
                    Enables/disables unsteady particle tracking.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/unsteady_tracking").execute(*args, **kwargs)
                def spray_model(self, *args, **kwargs):
                    """
                    Enters the spray model menu. This command is available only if the breakup model 	enabled globally.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/spray_model").execute(*args, **kwargs)

                class numerics(TUIMenu):
                    """
                    Enters the numerics menu to set numerical solution parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.high_resolution_tracking = self.__class__.high_resolution_tracking(service, version, mode, path + ["high_resolution_tracking"])
                        super().__init__(service, version, mode, path)
                    def enable_node_based_averaging(self, *args, **kwargs):
                        """
                        Enables/disables mesh node averaging of DPM quantities.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/enable_node_based_averaging").execute(*args, **kwargs)
                    def mppic_settings(self, *args, **kwargs):
                        """
                        Enable PIC and MPPIC to compute DPM and DDPM source terms.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/mppic_settings").execute(*args, **kwargs)
                    def packed_region_detection_enabled(self, *args, **kwargs):
                        """
                        Identify cells in packed region to apply limiting of granular forces.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/packed_region_detection_enabled").execute(*args, **kwargs)
                    def average_source_terms(self, *args, **kwargs):
                        """
                        Enables/disables mesh node averaging of DPM source terms.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/average_source_terms").execute(*args, **kwargs)
                    def tracking_statistics(self, *args, **kwargs):
                        """
                        Controls the format of the one-line tracking statistics to be printed after every DPM tracking pass. A value of 0 (the default) prints only fates with non-zero values. A value of 1 prints all fates, including fates with zero values.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/tracking_statistics").execute(*args, **kwargs)
                    def minimum_liquid_fraction(self, *args, **kwargs):
                        """
                        A droplet evaporates completely when the remaining mass is below this fraction of the initial droplet mass.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/minimum_liquid_fraction").execute(*args, **kwargs)
                    def dynamic_interaction(self, *args, **kwargs):
                        """
                        Enable/disable dynamic interaction range.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/dynamic_interaction").execute(*args, **kwargs)
                    def error_control(self, *args, **kwargs):
                        """
                        Adapts integration step length based on a maximum error.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/error_control").execute(*args, **kwargs)
                    def average_kernel(self, *args, **kwargs):
                        """
                        Specifies the averaging kernel to use for mesh node averaging.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/average_kernel").execute(*args, **kwargs)
                    def re_randomize_every_iteration(self, *args, **kwargs):
                        """
                        Determines whether or not the initial particle positions will vary from iteration to iteration.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/re_randomize_every_iteration").execute(*args, **kwargs)
                    def enhanced_packing_limit_numerics(self, *args, **kwargs):
                        """
                        Enable enhanced packing limit numerics to avoid exceeding of packing limit for granular phases.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/enhanced_packing_limit_numerics").execute(*args, **kwargs)
                    def predictor_corrector(self, *args, **kwargs):
                        """
                        Enable predictor/corrector approach to track particles.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/predictor_corrector").execute(*args, **kwargs)
                    def average_DDPM_variables(self, *args, **kwargs):
                        """
                        Enables/disables mesh node averaging of DDPM quantities.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/average_DDPM_variables").execute(*args, **kwargs)
                    def drag_law(self, *args, **kwargs):
                        """
                        Sets the drag law.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/drag_law").execute(*args, **kwargs)
                    def tracking_parameters(self, *args, **kwargs):
                        """
                        Sets parameters for the (initial) tracking step length.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/tracking_parameters").execute(*args, **kwargs)
                    def average_each_step(self, *args, **kwargs):
                        """
                        Enables/disables mesh node averaging during integration time step.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/average_each_step").execute(*args, **kwargs)
                    def re_randomize_every_timestep(self, *args, **kwargs):
                        """
                        Determines whether or not the initial particle positions will vary from time step to time step.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/re_randomize_every_timestep").execute(*args, **kwargs)
                    def gaussian_factor(self, *args, **kwargs):
                        """
                        Specifies the Gaussian constant when using thegaussian kernel for mesh node averaging.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/gaussian_factor").execute(*args, **kwargs)
                    def underrelax_film_height(self, *args, **kwargs):
                        """
                        Sets the under-relaxation factor for the film height calculation. The recommended values range between 0.5 (default) and 0.9.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/underrelax_film_height").execute(*args, **kwargs)
                    def automated_scheme_selection(self, *args, **kwargs):
                        """
                        Enables/disables the adaptation of integration step length based on a maximum error.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/automated_scheme_selection").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        Adjust the DPM tracker's verbosity level.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/verbosity").execute(*args, **kwargs)
                    def coupled_heat_mass_update(self, *args, **kwargs):
                        """
                        Enables/disables coupled heat and mass update.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/coupled_heat_mass_update").execute(*args, **kwargs)
                    def tracking_scheme(self, *args, **kwargs):
                        """
                        Specifies a tracking scheme.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/tracking_scheme").execute(*args, **kwargs)
                    def granular_stress_tensor(self, *args, **kwargs):
                        """
                        Enable granular stress tensor to be considered with solid pressure gradient as collision force.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/granular_stress_tensor").execute(*args, **kwargs)
                    def limit_granular_forces(self, *args, **kwargs):
                        """
                        Enable limiting of granular forces from solid pressure gradients to avoid particle velocity overshoots.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/limit_granular_forces").execute(*args, **kwargs)
                    def vaporization_limiting_factors(self, *args, **kwargs):
                        """
                        Sets the Vaporization Fractional Change Limits.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/vaporization_limiting_factors").execute(*args, **kwargs)

                    class high_resolution_tracking(TUIMenu):
                        """
                        Enters the high resolution tracking menu. See  for more information about these options.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.barycentric_interpolation = self.__class__.barycentric_interpolation(service, version, mode, path + ["barycentric_interpolation"])
                            self.particle_relocation = self.__class__.particle_relocation(service, version, mode, path + ["particle_relocation"])
                            super().__init__(service, version, mode, path)
                        def wallfilm_relocation_tolerance(self, *args, **kwargs):
                            """
                            Set the relocation tolerance for wallfilm particles after remeshing.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/wallfilm_relocation_tolerance").execute(*args, **kwargs)
                        def sliding_interface_crossover_fraction(self, *args, **kwargs):
                            """
                            Specifies the fraction of the distance to the subtet center to move the particle.  At non-conformal interfaces, the nodes used for the barycentric interpolation are different on either side of the interface. This may result in incomplete particles due to discontinuities in the variable interpolation. The number of incomplete particles may be reduced by moving the particles slightly off of the sliding interface. Recommended values range between 0 and 0.5.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/sliding_interface_crossover_fraction").execute(*args, **kwargs)
                        def enable_automatic_intersection_tolerance(self, *args, **kwargs):
                            """
                            Enables/disables the automatic calculation of intersection tolerance. By default, the tolerance used in intersection calculations is scaled by the residence time of the particle in the cell to improve robustness. For most cases, the scaled tolerance is sufficient to identify all intersections of the particle trajectory and the subtet faces. You can set the intersection tolerance manually using the set-subtet-intersection-tolerance text command.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/enable_automatic_intersection_tolerance").execute(*args, **kwargs)
                        def use_velocity_based_error_control(self, *args, **kwargs):
                            """
                            Enables/disables an alternative method of timestep adaption. By default, ANSYS Fluent uses the half-step method of timestep adaption with particle integration. This alternative method of controlling the integration timestep based upon velocity changes is faster; however, you need to ensure that the accuracy is comparable for your specific application.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/use_velocity_based_error_control").execute(*args, **kwargs)
                        def enable_barycentric_intersections(self, *args, **kwargs):
                            """
                            Enables/disables an alternative method of calculating intersections with cell boundaries. Barycentric intersections are linear calculations and are faster than the default intersection algorithm. The default intersection algorithm is second-order for stationary meshes; therefore, using the barycentric intersection may sacrifice accuracy. You must verify that the barycentric intersections provide comparable results to the default intersection method. This option is available only for 3D stationary meshes and the double precision solver.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/enable_barycentric_intersections").execute(*args, **kwargs)
                        def project_wall_film_particles_to_film(self, *args, **kwargs):
                            """
                            Enables/disables projecting existing particles to Lagrangian wall film to track using high-resolution tracking.  When reading in a data file that contains wall film particles previously tracked with the existing ANSYS Fluent tracking method, you need to either clear the particles from the domain or project their positions to the wall film surface using the project-wall-film-particles-to-film? text command prior to using the high-resolution tracking method. After tracking the particles for one timestep, this option can be disabled to improve performance.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/project_wall_film_particles_to_film").execute(*args, **kwargs)
                        def use_barycentric_sampling(self, *args, **kwargs):
                            """
                            When enabled, this option provides improved accuracy and parallel consistency when sampling particles at planes. This item is available only with the 3D solver. Using the double-precision solver and bounded planes is recommended.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/use_barycentric_sampling").execute(*args, **kwargs)
                        def load_legacy_particles(self, *args, **kwargs):
                            """
                            Load particles that were tracked without high-resolution tracking enabled.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/load_legacy_particles").execute(*args, **kwargs)
                        def use_particle_timestep_for_intersection_tolerance(self, *args, **kwargs):
                            """
                            Enables/disables the use of the particle timestep for the subtet intersection tolerance with axisymmetric grids (default: enabled). If disabled, the tolerance will be calculated in the same manner as non-axisymmetric meshes (a scaled value of the tolerance which is set using the define/models/dpm/numerics/high-resolution-tracking/set-subtet-intersection-tolerance text command).
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/use_particle_timestep_for_intersection_tolerance").execute(*args, **kwargs)
                        def enhanced_wallfilm_location_method(self, *args, **kwargs):
                            """
                            Enable enhanced method of locating film particles on faces.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/enhanced_wallfilm_location_method").execute(*args, **kwargs)
                        def always_use_face_centroid_with_periodics(self, *args, **kwargs):
                            """
                            When enabled, ANSYS Fluent uses quad face centroids when creating subtets in cases with periodic boundaries.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/always_use_face_centroid_with_periodics").execute(*args, **kwargs)
                        def check_subtet_validity(self, *args, **kwargs):
                            """
                            When enabled, checks the validity of a subtet when the particle first enters it. If the subtet is found to be degenerate, the tracking algorithm modifies to accommodate it.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/check_subtet_validity").execute(*args, **kwargs)
                        def set_film_spreading_parameter(self, *args, **kwargs):
                            """
                            Set the spreading parameter for Lagrangian wallfilm particles.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/set_film_spreading_parameter").execute(*args, **kwargs)
                        def use_legacy_particle_location_method(self, *args, **kwargs):
                            """
                            Enable legacy method of locating particles in cells.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/use_legacy_particle_location_method").execute(*args, **kwargs)
                        def enable_high_resolution_tracking(self, *args, **kwargs):
                            """
                            Enables/disables high resolution tracking.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/enable_high_resolution_tracking").execute(*args, **kwargs)
                        def set_subtet_intersection_tolerance(self, *args, **kwargs):
                            """
                            Specifies the tolerance used in intersection calculations. This tolerance will be scaled by the characteristic cell crossing time of the particle if the enable-automatic-intersection-tolerance? text command is enabled. If that option is disabled, the specified tolerance will be used without scaling. The default intersection tolerance is 10-5.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/set_subtet_intersection_tolerance").execute(*args, **kwargs)
                        def remove_stuck_particles(self, *args, **kwargs):
                            """
                            Remove particles that are stuck at edges or faces.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/remove_stuck_particles").execute(*args, **kwargs)
                        def use_quad_face_centroid(self, *args, **kwargs):
                            """
                            Enables/disables using quad face centroids when creating subtets. This option changes the way hexahedral cells are decomposed to avoid creating degenerate subtets.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/use_quad_face_centroid").execute(*args, **kwargs)
                        def boundary_layer_tracking(self, *args, **kwargs):
                            """
                            Enables/disables the calculation of the particle time step that considers both the cell aspect ratio and the particle trajectory. This method improves the accuracy of the predictions in boundary layer cells, particularly in layers where flow gradients are large.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/boundary_layer_tracking").execute(*args, **kwargs)

                        class barycentric_interpolation(TUIMenu):
                            """
                            Enter the barycentric interpolation menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def interpolate_temperature(self, *args, **kwargs):
                                """
                                Enables/disables the barycentric interpolation of temperature to the particle position. The cell temperature is used by default in calculations of heat transfer to/from the particle.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_temperature").execute(*args, **kwargs)
                            def interpolate_wallfilm_properties(self, *args, **kwargs):
                                """
                                When enabled, the wall film properties (film height, film mass, and wall shear) are interpolated to the particle position.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_wallfilm_properties").execute(*args, **kwargs)
                            def precompute_pdf_species(self, *args, **kwargs):
                                """
                                When this option is enabled for premixed or non-premixed combustion simulations, the species composition in each cell is precomputed prior to tracking particles. This approach may improve performance for cases with many particles and relatively few cells. By default, this option is set to no, and ANSYS Fluent calculates the species composition during particle tracking. The solution results will be identical for both methods.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/precompute_pdf_species").execute(*args, **kwargs)
                            def zero_nodal_velocity_on_walls(self, *args, **kwargs):
                                """
                                When enabled, sets the velocity at wall nodes to zero. (By default, the nodal velocities on walls are first reconstructed from cell and face values and then corrected to ensure that there are no velocity components directed towards the walls). This may be useful if you want to consider particle impingement on the walls. Note that enabling this option will more likely produce incomplete particles as some particles may settle on the walls.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/zero_nodal_velocity_on_walls").execute(*args, **kwargs)
                            def interpolate_flow_cp(self, *args, **kwargs):
                                """
                                Enables/disables the barycentric interpolation of specific heat to the particle position. This option is recommended when the specific heat varies with position to avoid discontinuities in the interpolated variable at cell boundaries. For flows with constant specific heat, this option is unnecessary.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_flow_cp").execute(*args, **kwargs)
                            def interpolate_flow_solution_gradients(self, *args, **kwargs):
                                """
                                When enabled, flow solution gradients are interpolated to the particle position. This can be useful when using physical models that depend on these gradients (for example, the thermophoretic force, pressure-gradient force, or virtual mass force). Interpolating the gradients also improves the accuracy and robustness of the trapezoidal numerics scheme, which is the default method for pathlines.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_flow_solution_gradients").execute(*args, **kwargs)
                            def user_interpolation_function(self, *args, **kwargs):
                                """
                                Enter user interpolation function.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/user_interpolation_function").execute(*args, **kwargs)
                            def interpolate_flow_density(self, *args, **kwargs):
                                """
                                Enables/disables the barycentric interpolation of the flow density. This option is recommended when the density varies with position to avoid discontinuities in the interpolated variable at cell boundaries. For constant density flows, this option is unnecessary.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_flow_density").execute(*args, **kwargs)
                            def interpolate_flow_viscosity(self, *args, **kwargs):
                                """
                                Enables/disables the barycentric interpolation of flow viscosity to the particle position. This option is recommended when the flow viscosity varies with position to avoid discontinuities in the interpolated variable at cell boundaries. For flows with constant viscosity, this option is unnecessary.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_flow_viscosity").execute(*args, **kwargs)
                            def nodal_reconstruction_frequency(self, *args, **kwargs):
                                """
                                Update nodal reconstruction every N'th DPM iteration.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/nodal_reconstruction_frequency").execute(*args, **kwargs)
                            def enable_transient_variable_interpolation(self, *args, **kwargs):
                                """
                                Enable transient variable interpolation.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/enable_transient_variable_interpolation").execute(*args, **kwargs)

                        class particle_relocation(TUIMenu):
                            """
                            Enter the particle relocation menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def load_legacy_particles(self, *args, **kwargs):
                                """
                                Load particles that were tracked without high-resolution tracking enabled.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/particle_relocation/load_legacy_particles").execute(*args, **kwargs)
                            def enhanced_wallfilm_location_method(self, *args, **kwargs):
                                """
                                Enable enhanced method of locating film particles on faces.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/particle_relocation/enhanced_wallfilm_location_method").execute(*args, **kwargs)
                            def wallfilm_relocation_tolerance_scale_factor(self, *args, **kwargs):
                                """
                                Set the relocation tolerance scaling factor for wallfilm particles after remeshing.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/particle_relocation/wallfilm_relocation_tolerance_scale_factor").execute(*args, **kwargs)
                            def use_legacy_particle_location_method(self, *args, **kwargs):
                                """
                                Enable legacy method of locating particles in cells.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/particle_relocation/use_legacy_particle_location_method").execute(*args, **kwargs)
                            def overset_relocation_robustness_level(self, *args, **kwargs):
                                """
                                Set the robustness level for particle relocation in overset meshes.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/particle_relocation/overset_relocation_robustness_level").execute(*args, **kwargs)
                            def enhanced_cell_relocation_method(self, *args, **kwargs):
                                """
                                Enable enhanced method of locating particles in cells.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/numerics/high_resolution_tracking/particle_relocation/enhanced_cell_relocation_method").execute(*args, **kwargs)

                class stripping_options(TUIMenu):
                    """
                    Enters the stripping options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def diameter_coefficient(self, *args, **kwargs):
                        """
                        Sets the diameter coefficient (  in  in the Theory Guide).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/stripping_options/diameter_coefficient").execute(*args, **kwargs)
                    def mass_coefficient(self, *args, **kwargs):
                        """
                        Sets the mass coefficient (  in  in the Theory Guide).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/stripping_options/mass_coefficient").execute(*args, **kwargs)

                class collisions(TUIMenu):
                    """
                    Enters the DEM collisions menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.collision_partners = self.__class__.collision_partners(service, version, mode, path + ["collision_partners"])
                        super().__init__(service, version, mode, path)
                    def collision_mesh(self, *args, **kwargs):
                        """
                        Input for the collision mesh.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/collisions/collision_mesh").execute(*args, **kwargs)
                    def max_particle_velocity(self, *args, **kwargs):
                        """
                        Sets the maximum particle velocity that may arise from collisions.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/collisions/max_particle_velocity").execute(*args, **kwargs)
                    def list_all_pair_settings(self, *args, **kwargs):
                        """
                        For each pair of collision partners, lists the collision laws and their parameters.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/collisions/list_all_pair_settings").execute(*args, **kwargs)
                    def collision_pair_settings(self, *args, **kwargs):
                        """
                        Supplies settings for collisions to a pair of collision partners. You will be prompted to specify theImpact collision partner and the Target collision partner.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/collisions/collision_pair_settings").execute(*args, **kwargs)
                    def dem_collisions(self, *args, **kwargs):
                        """
                        Enables/disables the DEM collision model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/collisions/dem_collisions").execute(*args, **kwargs)

                    class collision_partners(TUIMenu):
                        """
                        Manages collision partners.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def list(self, *args, **kwargs):
                            """
                            Lists all known collision partners.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/collisions/collision_partners/list").execute(*args, **kwargs)
                        def copy(self, *args, **kwargs):
                            """
                            Copies a collision partner.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/collisions/collision_partners/copy").execute(*args, **kwargs)
                        def rename(self, *args, **kwargs):
                            """
                            Renames a collision partner.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/collisions/collision_partners/rename").execute(*args, **kwargs)
                        def delete(self, *args, **kwargs):
                            """
                            Deletes a collision partner.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/collisions/collision_partners/delete").execute(*args, **kwargs)
                        def create(self, *args, **kwargs):
                            """
                            Creates a collision partner.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/collisions/collision_partners/create").execute(*args, **kwargs)

                class parallel(TUIMenu):
                    """
                    Enters the parallel menu to set parameters for parallel DPM calculations.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                        super().__init__(service, version, mode, path)
                    def hybrid_collision_unidirectional(self, *args, **kwargs):
                        """
                        A faster, yet potentially somewhat less accurate, modification to the beta feature
                        that allows 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/parallel/hybrid_collision_unidirectional").execute(*args, **kwargs)
                    def hybrid_collision_model(self, *args, **kwargs):
                        """
                        An EXPERIMENTAL feature to allow 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/parallel/hybrid_collision_model").execute(*args, **kwargs)
                    def hybrid_collision_variant(self, *args, **kwargs):
                        """
                        Further reduce the residual risk of dead-locks in the experimental feature that
                        allows 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/parallel/hybrid_collision_variant").execute(*args, **kwargs)
                    def hybrid_workpile(self, *args, **kwargs):
                        """
                        Optimize multi-thread load balancing within each partition in hybrid-parallel DPM tracking.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/parallel/hybrid_workpile").execute(*args, **kwargs)
                    def report(self, *args, **kwargs):
                        """
                        Prints particle workpile statistics. This option is only available when the define/models/dpm/parallel/enable-workpile? option is enabled.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/parallel/report").execute(*args, **kwargs)
                    def hybrid_2domain(self, *args, **kwargs):
                        """
                        Enables/disables the use of a second domain for DPM particle tracking.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/parallel/hybrid_2domain").execute(*args, **kwargs)
                    def enable_workpile(self, *args, **kwargs):
                        """
                        Turns on/off particle workpile algorithm. This option is only available when the define/models/dpm/parallel/use-shared-memory option is selected.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/parallel/enable_workpile").execute(*args, **kwargs)
                    def n_threads(self, *args, **kwargs):
                        """
                        Sets the number of processors to use for DPM. This option is only available when the define/models/dpm/parallel/enable-workpile? option is enabled.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/parallel/n_threads").execute(*args, **kwargs)
                    def fix_source_term_accumulation_order(self, *args, **kwargs):
                        """
                        Enforce deterministic order of source term accumulation.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/parallel/fix_source_term_accumulation_order").execute(*args, **kwargs)
                    def use_shared_memory(self, *args, **kwargs):
                        """
                        Specifies that the calculations are performed on shared-memory multiprocessor machines.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/parallel/use_shared_memory").execute(*args, **kwargs)
                    def use_hybrid(self, *args, **kwargs):
                        """
                        Specifies that the calculations are performed using multicore cluster computing or shared-memory machines. This option works in conjunction withopenmpi for a dynamic load balancing without migration of cells.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/parallel/use_hybrid").execute(*args, **kwargs)
                    def use_message_passing(self, *args, **kwargs):
                        """
                        Specifies that the calculations are performed using cluster computing or shared-memory machines. With this option, the compute node processes themselves perform the particle work on their local partitions and particle migration to other compute nodes is implemented using message passing primitives.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/parallel/use_message_passing").execute(*args, **kwargs)

                    class expert(TUIMenu):
                        """
                        Enters the menu for expert DPM parallel text commands.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def partition_method_hybrid_2domain(self, *args, **kwargs):
                            """
                            Enables/disables a partitioning method that is more granular and can yield faster calculations (especially for cases that are running on a low to moderate number of processors). This partitioning method is only applied when you use the DPM domain for the hybrid parallel DPM tracking mode (that is, when you have enabled the define/models/dpm/parallel/hybrid-2domain? text command).
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/parallel/expert/partition_method_hybrid_2domain").execute(*args, **kwargs)

                class interaction(TUIMenu):
                    """
                    Sets parameters for coupled discrete phase calculations.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def linearized_dpm_source_terms_limiter(self, *args, **kwargs):
                        """
                        Relative limit for DPM source linear coefficient with respect to fluid linear Ap coefficient.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/linearized_dpm_source_terms_limiter").execute(*args, **kwargs)
                    def min_vf_threshold_for_dpm_src_scaling(self, *args, **kwargs):
                        """
                        Minimum DPM volume fraction below which no DPM source scaling is applied.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/min_vf_threshold_for_dpm_src_scaling").execute(*args, **kwargs)
                    def ddpm_energy_coupling_via_source_term(self, *args, **kwargs):
                        """
                        Energy coupling in DDPM established via source term.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/ddpm_energy_coupling_via_source_term").execute(*args, **kwargs)
                    def max_vf_allowed_for_blocking(self, *args, **kwargs):
                        """
                        Maximum DPM volume fraction used in continuous flow.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/max_vf_allowed_for_blocking").execute(*args, **kwargs)
                    def update_dpm_sources_every_flow_iteration(self, *args, **kwargs):
                        """
                        Enables/disables the update of DPM source terms every flow iteration (if this option is not enabled, the terms will be updated every DPM iteration).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/update_dpm_sources_every_flow_iteration").execute(*args, **kwargs)
                    def linearized_dpm_source_terms(self, *args, **kwargs):
                        """
                        Enables/disables linearization of source terms for the discrete phase.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/linearized_dpm_source_terms").execute(*args, **kwargs)
                    def ddpm_enhanced_inter_phase_exchange(self, *args, **kwargs):
                        """
                        Enhanced Eulerian inter-phase exchange.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/ddpm_enhanced_inter_phase_exchange").execute(*args, **kwargs)
                    def coupled_calculations(self, *args, **kwargs):
                        """
                        Selects whether or not to couple continuous and discrete phase calculations.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/coupled_calculations").execute(*args, **kwargs)
                    def choice_of_eulerian_phase_for_interaction(self, *args, **kwargs):
                        """
                        Enable/disable the option to choose for every injection the Eulerian phase for the DPM continuous phase interaction.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/choice_of_eulerian_phase_for_interaction").execute(*args, **kwargs)
                    def enable_source_scaling_due_to_flow_blocking(self, *args, **kwargs):
                        """
                        Enable/disable scaling of DPM source terms due to inclusion of DPM volume fraction in continuous flow.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/enable_source_scaling_due_to_flow_blocking").execute(*args, **kwargs)
                    def enhanced_source_term_linearization_enabled(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/enhanced_source_term_linearization_enabled").execute(*args, **kwargs)
                    def reset_sources_at_timestep(self, *args, **kwargs):
                        """
                        Enables/disables flush of DPM source terms at beginning of every time step.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/reset_sources_at_timestep").execute(*args, **kwargs)
                    def keep_linearized_dpm_source_terms_constant(self, *args, **kwargs):
                        """
                        Keep linearized DPM source terms constant until the next DPM Update.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/keep_linearized_dpm_source_terms_constant").execute(*args, **kwargs)
                    def ddpm_iad_particle(self, *args, **kwargs):
                        """
                        Enable/disable the non-default interfacial area method IA-particle.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/ddpm_iad_particle").execute(*args, **kwargs)
                    def replace_dpm_mass_source_by_mixture_fraction(self, *args, **kwargs):
                        """
                        When enabled, recalculates the mixture fraction source terms as a function of the primary mixture fraction. This command is available for non- or partially-premixed combustion cases only.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/replace_dpm_mass_source_by_mixture_fraction").execute(*args, **kwargs)
                    def enable_drag_scaling_due_to_flow_blocking(self, *args, **kwargs):
                        """
                        Enable/disable scaling of DPM drag coefficient due to inclusion of DPM volume fraction in continuous flow.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/enable_drag_scaling_due_to_flow_blocking").execute(*args, **kwargs)
                    def implicit_momentum_coupling(self, *args, **kwargs):
                        """
                        Enables/disables implicit treatment for the DPM momentum source terms.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/implicit_momentum_coupling").execute(*args, **kwargs)
                    def linearized_dpm_species_source_terms(self, *args, **kwargs):
                        """
                        Perform linearization of species source terms.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/linearized_dpm_species_source_terms").execute(*args, **kwargs)
                    def implicit_source_term_coupling(self, *args, **kwargs):
                        """
                        Enables/disables implicit treatment for all DPM source terms.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/implicit_source_term_coupling").execute(*args, **kwargs)
                    def linear_growth_of_dpm_source_term(self, *args, **kwargs):
                        """
                        Enables/disables the linear ramping up of the DPM source terms at every DPM iteration.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/linear_growth_of_dpm_source_term").execute(*args, **kwargs)
                    def enable_flow_blocking_by_particles(self, *args, **kwargs):
                        """
                        Enable/disable inclusion of DPM volume fraction in continuous flow.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/enable_flow_blocking_by_particles").execute(*args, **kwargs)
                    def underrelaxation_factor(self, *args, **kwargs):
                        """
                        Sets the under-relaxation factor for the discrete phase sources.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/underrelaxation_factor").execute(*args, **kwargs)
                    def linearized_dpm_mixture_fraction_source_terms(self, *args, **kwargs):
                        """
                        Enables/disables linearization of mixture fraction source terms. This command is available only for non- or partially-premixed combustion cases.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/linearized_dpm_mixture_fraction_source_terms").execute(*args, **kwargs)
                    def second_order_time_accurate_sources_enabled(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/second_order_time_accurate_sources_enabled").execute(*args, **kwargs)
                    def dpm_iteration_interval(self, *args, **kwargs):
                        """
                        Sets the frequency with which the particle trajectory calculations are introduced.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/interaction/dpm_iteration_interval").execute(*args, **kwargs)

                class erosion_dynamic_mesh(TUIMenu):
                    """
                    Enters the menu to enable/configure/run the erosion-dynamic mesh interaction.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.general_parameters = self.__class__.general_parameters(service, version, mode, path + ["general_parameters"])
                        self.run_parameters = self.__class__.run_parameters(service, version, mode, path + ["run_parameters"])
                        super().__init__(service, version, mode, path)
                    def run_simulation(self, *args, **kwargs):
                        """
                        Performs a coupled erosion-dynamic mesh simulation.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/erosion_dynamic_mesh/run_simulation").execute(*args, **kwargs)
                    def enable_erosion_dynamic_mesh_coupling(self, *args, **kwargs):
                        """
                        Enables mesh deformation due to wall erosion.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/erosion_dynamic_mesh/enable_erosion_dynamic_mesh_coupling").execute(*args, **kwargs)

                    class general_parameters(TUIMenu):
                        """
                        Enters the menu for setting erosion coupling with dynamic mesh.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def participating_walls(self, *args, **kwargs):
                            """
                            Specifies all participating walls.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/erosion_dynamic_mesh/general_parameters/participating_walls").execute(*args, **kwargs)
                        def erosion_settings(self, *args, **kwargs):
                            """
                            Sets parameters for erosion calculations.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/erosion_dynamic_mesh/general_parameters/erosion_settings").execute(*args, **kwargs)
                        def dynamic_mesh_settings(self, *args, **kwargs):
                            """
                            Sets parameters for dynamic mesh calculations.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/erosion_dynamic_mesh/general_parameters/dynamic_mesh_settings").execute(*args, **kwargs)

                    class run_parameters(TUIMenu):
                        """
                        Manages erosion-dynamic mesh run settings.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def autosave_graphics(self, *args, **kwargs):
                            """
                            Sets the iteration increment to save graphics files.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/erosion_dynamic_mesh/run_parameters/autosave_graphics").execute(*args, **kwargs)
                        def flow_simulation_control(self, *args, **kwargs):
                            """
                            Sets the number of iterations per flow simulation step.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/erosion_dynamic_mesh/run_parameters/flow_simulation_control").execute(*args, **kwargs)
                        def simulation_termination(self, *args, **kwargs):
                            """
                            Sets the total time of erosion.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/erosion_dynamic_mesh/run_parameters/simulation_termination").execute(*args, **kwargs)
                        def autosave_files(self, *args, **kwargs):
                            """
                            Sets the iteration increment and filename to save data files.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/erosion_dynamic_mesh/run_parameters/autosave_files").execute(*args, **kwargs)
                        def mesh_motion_time_step(self, *args, **kwargs):
                            """
                            Sets the mesh motion time stepping parameters and method.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/erosion_dynamic_mesh/run_parameters/mesh_motion_time_step").execute(*args, **kwargs)

                class splash_options(TUIMenu):
                    """
                    Enters the splash option menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def splash_pdf_limiting(self, *args, **kwargs):
                        """
                        Sets the splash pdf limiting method. Available methods are: the splash pdf tail limiting (default for the LWF model) and the splash pdf peak limiting (default for the EWF model). For the splash pdf peak limiting, you will be prompted to specify the peak limiting value.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/splash_options/splash_pdf_limiting").execute(*args, **kwargs)
                    def orourke_splash_fraction(self, *args, **kwargs):
                        """
                        Enables/disables the ORourke formulation (default for the Lagrangian Wall Film (LWF) model). If the ORourke formulation is disabled, the Stanton formulation (default for the Eulerian Wall Film (EWF) model) is used in a simulation.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/splash_options/orourke_splash_fraction").execute(*args, **kwargs)

                class options(TUIMenu):
                    """
                    Enters the options menu to set optional models.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def stagger_temporally(self, *args, **kwargs):
                        """
                        Enables/disables temporal staggering.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/stagger_temporally").execute(*args, **kwargs)
                    def track_in_absolute_frame(self, *args, **kwargs):
                        """
                        Enables/disables tracking in absolute frame.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/track_in_absolute_frame").execute(*args, **kwargs)
                    def staggering_factor(self, *args, **kwargs):
                        """
                        S.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/staggering_factor").execute(*args, **kwargs)
                    def enable_contour_plots(self, *args, **kwargs):
                        """
                        Enables computation of mean and/or RMS values of additional discrete phase variables for postprocessing.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/enable_contour_plots").execute(*args, **kwargs)
                    def brownian_motion(self, *args, **kwargs):
                        """
                        Enables/disables Brownian motion of particles.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/brownian_motion").execute(*args, **kwargs)
                    def stagger_spatially_standard_injections(self, *args, **kwargs):
                        """
                        Enables/disables spatial staggering for standard (non-atomizer and non-solid-cone) injections.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/stagger_spatially_standard_injections").execute(*args, **kwargs)
                    def remove_wall_film_temperature_limiter(self, *args, **kwargs):
                        """
                        Answering yes at the prompt removes the wall temperature limiter for Lagrangian wall-film walls. If you enter no (default), two additional prompts will appear in the console allowing you to define the temperature difference above the boiling point and to enable/disable the reporting of the Leidenfrost temperature on the wall faces.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/remove_wall_film_temperature_limiter").execute(*args, **kwargs)
                    def set_minimum_particle_diameter(self, *args, **kwargs):
                        """
                        Set the minimum particle diameter.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/set_minimum_particle_diameter").execute(*args, **kwargs)
                    def stagger_spatially_atomizer_injections(self, *args, **kwargs):
                        """
                        Enables/disables spatial staggering for atomizer and solid-cone injections.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/stagger_spatially_atomizer_injections").execute(*args, **kwargs)
                    def allow_supercritical_pressure_vaporization(self, *args, **kwargs):
                        """
                        Enforces the switching from vaporization to boiling even if the boiling point is not calculated from the vapor pressure data. If the pressure in your model is above critical you must retain the default setting (yes). This options is available only if whenPressure Dependent Boiling is enabled in the Physical Models tab of the Discrete Phase Models dialog box. For more details, see .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/allow_supercritical_pressure_vaporization").execute(*args, **kwargs)
                    def scr_urea_deposition_risk_analysis(self, *args, **kwargs):
                        """
                        Enters the menu for setting up the risk for solids deposit formation for the Selective Catalytic Reduction (SCR) process. For more information, see .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/scr_urea_deposition_risk_analysis").execute(*args, **kwargs)
                    def use_absolute_pressure_for_vaporization(self, *args, **kwargs):
                        """
                        Determines whether the absolute pressure or constant operating pressure (specified in define/operating-conditions/operating-pressure) will be used in vaporization rates calculations.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/use_absolute_pressure_for_vaporization").execute(*args, **kwargs)
                    def init_erosion_accretion_rate(self, *args, **kwargs):
                        """
                        Initializes the erosion/accretion rates with zero.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/init_erosion_accretion_rate").execute(*args, **kwargs)
                    def virtual_mass_force(self, *args, **kwargs):
                        """
                        Enables/disables inclusion of the virtual mass force in the particle force balance.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/virtual_mass_force").execute(*args, **kwargs)
                    def two_way_coupling(self, *args, **kwargs):
                        """
                        Enables/disables calculation of DPM sources in TKE equation.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/two_way_coupling").execute(*args, **kwargs)
                    def saffman_lift_force(self, *args, **kwargs):
                        """
                        Enables/disables Saffman lift force.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/saffman_lift_force").execute(*args, **kwargs)
                    def convective_film_heat_transfer(self, *args, **kwargs):
                        """
                        Enable/disable convection/conduction film to wall heat transfer model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/convective_film_heat_transfer").execute(*args, **kwargs)
                    def treat_multicomponent_saturation_temperature_failure(self, *args, **kwargs):
                        """
                        Enables/disables dumping multicomponent particle mass into the continuous phase if the saturation temperature calculation fails.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/treat_multicomponent_saturation_temperature_failure").execute(*args, **kwargs)
                    def step_report_sig_figures(self, *args, **kwargs):
                        """
                        Sets significant figures in the step-by-step report.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/step_report_sig_figures").execute(*args, **kwargs)
                    def film_movement(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/film_movement").execute(*args, **kwargs)
                    def particle_radiation(self, *args, **kwargs):
                        """
                        Enables/disables particle radiation.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/particle_radiation").execute(*args, **kwargs)
                    def stagger_radius(self, *args, **kwargs):
                        """
                        Specifies the region over which to spatially stagger particles when particle-staggering is enabled for non-atomizer injections.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/stagger_radius").execute(*args, **kwargs)
                    def pressure_gradient_force(self, *args, **kwargs):
                        """
                        Enables/disables inclusion of pressure gradient effects in the particle force balance.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/pressure_gradient_force").execute(*args, **kwargs)
                    def set_thermolysis_limit(self, *args, **kwargs):
                        """
                        Sets the limit for the thermolysis model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/set_thermolysis_limit").execute(*args, **kwargs)
                    def uniform_mass_distribution_for_injections(self, *args, **kwargs):
                        """
                        Specifies a uniform distribution of mass over the cross-section of solid cone and atomizer injections. This can become important when the mesh is smaller than the diameter (or another characteristic size) of the injection.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/uniform_mass_distribution_for_injections").execute(*args, **kwargs)
                    def erosion_accretion(self, *args, **kwargs):
                        """
                        Enables/disables erosion/accretion.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/erosion_accretion").execute(*args, **kwargs)
                    def thermophoretic_force(self, *args, **kwargs):
                        """
                        Enables/disables thermophoretic force.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/thermophoretic_force").execute(*args, **kwargs)
                    def lowest_volatiles_mass_fraction(self, *args, **kwargs):
                        """
                        Set the lowest volatiles mass fraction.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/lowest_volatiles_mass_fraction").execute(*args, **kwargs)
                    def vaporization_options(self, *args, **kwargs):
                        """
                        Sets Vaporization options.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/vaporization_options").execute(*args, **kwargs)
                    def current_positions_in_sample_file_format(self, *args, **kwargs):
                        """
                        When enabled, generates a file containing particle current positions (step-by-step history report for unsteady tracking) in the sampling file format.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/current_positions_in_sample_file_format").execute(*args, **kwargs)
                    def ensemble_average(self, *args, **kwargs):
                        """
                        Ensembles average cloud properties.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/ensemble_average").execute(*args, **kwargs)
                    def include_lwf_particles_in_dpm_concentration(self, *args, **kwargs):
                        """
                        Include LWF particle mass in DPM Concentration.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/include_lwf_particles_in_dpm_concentration").execute(*args, **kwargs)
                    def vaporization_heat_transfer_averaging(self, *args, **kwargs):
                        """
                        Enables averaging of the Spalding heat transfer term for the convection/diffusion-controlled model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/vaporization_heat_transfer_averaging").execute(*args, **kwargs)
                    def maximum_udf_species(self, *args, **kwargs):
                        """
                        Specifies the maximum number of species that will be accessible from discrete phase model UDFs. Only species with indices up to this value are accessible in discrete phase model UDFs.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/dpm/options/maximum_udf_species").execute(*args, **kwargs)

            class electrolysis_setup(TUIMenu):
                """
                Enter the electrolysis and H2 pump model setup menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.membrane_setup = self.__class__.membrane_setup(service, version, mode, path + ["membrane_setup"])
                    self.advanced_setup = self.__class__.advanced_setup(service, version, mode, path + ["advanced_setup"])
                    self.cathode_setup = self.__class__.cathode_setup(service, version, mode, path + ["cathode_setup"])
                    self.anode_setup = self.__class__.anode_setup(service, version, mode, path + ["anode_setup"])
                    super().__init__(service, version, mode, path)
                def model_options(self, *args, **kwargs):
                    """
                    Specify electrolysis model options.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/model_options").execute(*args, **kwargs)
                def parameters(self, *args, **kwargs):
                    """
                    Specify electrolysis model parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/parameters").execute(*args, **kwargs)
                def electrical_tabs_setup(self, *args, **kwargs):
                    """
                    Specify settings for the electrical tabs.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/electrical_tabs_setup").execute(*args, **kwargs)

                class membrane_setup(TUIMenu):
                    """
                    Specify parameters for electrolyte.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def current_collector(self, *args, **kwargs):
                        """
                        Set parameters for the current collector.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/membrane_setup/current_collector").execute(*args, **kwargs)
                    def electrolyte(self, *args, **kwargs):
                        """
                        Set parameters for the electrolyte.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/membrane_setup/electrolyte").execute(*args, **kwargs)
                    def porous_layer(self, *args, **kwargs):
                        """
                        Set parameters for the porous layer.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/membrane_setup/porous_layer").execute(*args, **kwargs)
                    def catalyst_layer(self, *args, **kwargs):
                        """
                        Set parameters for the catalyst layer.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/membrane_setup/catalyst_layer").execute(*args, **kwargs)
                    def flow_channel(self, *args, **kwargs):
                        """
                        Set parameters for the flow channel.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/membrane_setup/flow_channel").execute(*args, **kwargs)

                class advanced_setup(TUIMenu):
                    """
                    Enter the menu for the advanced controls.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def contact_resistivity(self, *args, **kwargs):
                        """
                        Set Contact Resistivity.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/advanced_setup/contact_resistivity").execute(*args, **kwargs)

                class cathode_setup(TUIMenu):
                    """
                    Enter the menu for the cathode controls.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def catalyst_layer(self, *args, **kwargs):
                        """
                        Set parameters for the catalyst layer.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/cathode_setup/catalyst_layer").execute(*args, **kwargs)
                    def porous_layer(self, *args, **kwargs):
                        """
                        Set parameters for the porous layer.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/cathode_setup/porous_layer").execute(*args, **kwargs)
                    def current_collector(self, *args, **kwargs):
                        """
                        Set parameters for the current collector.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/cathode_setup/current_collector").execute(*args, **kwargs)
                    def flow_channel(self, *args, **kwargs):
                        """
                        Set parameters for the flow channel.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/cathode_setup/flow_channel").execute(*args, **kwargs)
                    def electrolyte(self, *args, **kwargs):
                        """
                        Set parameters for the electrolyte.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/cathode_setup/electrolyte").execute(*args, **kwargs)

                class anode_setup(TUIMenu):
                    """
                    Enter the menu for the anode controls.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def catalyst_layer(self, *args, **kwargs):
                        """
                        Set parameters for the catalyst layer.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/anode_setup/catalyst_layer").execute(*args, **kwargs)
                    def porous_layer(self, *args, **kwargs):
                        """
                        Set parameters for the porous layer.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/anode_setup/porous_layer").execute(*args, **kwargs)
                    def current_collector(self, *args, **kwargs):
                        """
                        Set parameters for the current collector.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/anode_setup/current_collector").execute(*args, **kwargs)
                    def electrolyte(self, *args, **kwargs):
                        """
                        Set parameters for the electrolyte.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/anode_setup/electrolyte").execute(*args, **kwargs)
                    def flow_channel(self, *args, **kwargs):
                        """
                        Set parameters for the flow channel.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/electrolysis_setup/anode_setup/flow_channel").execute(*args, **kwargs)

            class eulerian_wallfilm(TUIMenu):
                """
                Enters the Eulerian wall film model menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.implicit_options = self.__class__.implicit_options(service, version, mode, path + ["implicit_options"])
                    self.coupled_solution = self.__class__.coupled_solution(service, version, mode, path + ["coupled_solution"])
                    super().__init__(service, version, mode, path)
                def solution_options(self, *args, **kwargs):
                    """
                    Sets Eulerian Wall Film Model Solution Options.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/eulerian_wallfilm/solution_options").execute(*args, **kwargs)
                def film_material(self, *args, **kwargs):
                    """
                    Sets Film Material and Properties.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/eulerian_wallfilm/film_material").execute(*args, **kwargs)
                def enable_film_nci_support(self, *args, **kwargs):
                    """
                    Enable wall film fluid-fluid NCI support.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/eulerian_wallfilm/enable_film_nci_support").execute(*args, **kwargs)
                def list_film_walls(self, *args, **kwargs):
                    """
                    List film walls.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/eulerian_wallfilm/list_film_walls").execute(*args, **kwargs)
                def enable_wallfilm_model(self, *args, **kwargs):
                    """
                    Enables/disables Eulerian Wall Film Model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/eulerian_wallfilm/enable_wallfilm_model").execute(*args, **kwargs)
                def initialize_wallfilm_model(self, *args, **kwargs):
                    """
                    Initializes Eulerian Wall Film Model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/eulerian_wallfilm/initialize_wallfilm_model").execute(*args, **kwargs)
                def model_options(self, *args, **kwargs):
                    """
                    Set Eulerian wall film model options.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/eulerian_wallfilm/model_options").execute(*args, **kwargs)
                def enable_film_vof_transition_message(self, *args, **kwargs):
                    """
                    Enable film-VOF transition message.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/eulerian_wallfilm/enable_film_vof_transition_message").execute(*args, **kwargs)
                def solve_wallfilm_equation(self, *args, **kwargs):
                    """
                    Activates Eulerian Wall Film Equations.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/eulerian_wallfilm/solve_wallfilm_equation").execute(*args, **kwargs)

                class implicit_options(TUIMenu):
                    """
                    Enter Implicit Scheme Option (beta).
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def relative_error_residual(self, *args, **kwargs):
                        """
                        Enable relative error residual.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/eulerian_wallfilm/implicit_options/relative_error_residual").execute(*args, **kwargs)
                    def new_implicit_scheme(self, *args, **kwargs):
                        """
                        Enable alternative implicit scheme.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/eulerian_wallfilm/implicit_options/new_implicit_scheme").execute(*args, **kwargs)

                class coupled_solution(TUIMenu):
                    """
                    Enters the Coupled-Solution menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def enable_coupled_solution(self, *args, **kwargs):
                        """
                        Enables/disables the coupled solution method.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/eulerian_wallfilm/coupled_solution/enable_coupled_solution").execute(*args, **kwargs)
                    def enable_curvature_smoothing(self, *args, **kwargs):
                        """
                        Enables/disables the film curvature smoothing option and sets the smoothing parameters.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/eulerian_wallfilm/coupled_solution/enable_curvature_smoothing").execute(*args, **kwargs)

            class radiation(TUIMenu):
                """
                Enters the radiation models menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.dtrm_parameters = self.__class__.dtrm_parameters(service, version, mode, path + ["dtrm_parameters"])
                    self.s2s_parameters = self.__class__.s2s_parameters(service, version, mode, path + ["s2s_parameters"])
                    self.solar_parameters = self.__class__.solar_parameters(service, version, mode, path + ["solar_parameters"])
                    super().__init__(service, version, mode, path)
                def do_coupling(self, *args, **kwargs):
                    """
                    Enables/disables DO/energy coupling.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/do_coupling").execute(*args, **kwargs)
                def fast_second_order_discrete_ordinate(self, *args, **kwargs):
                    """
                    Enables/disables the fast-second-order option for Discrete Ordinate Model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/fast_second_order_discrete_ordinate").execute(*args, **kwargs)
                def radiation_model_parameters(self, *args, **kwargs):
                    """
                    Set parameters for radiation models.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/radiation_model_parameters").execute(*args, **kwargs)
                def discrete_transfer(self, *args, **kwargs):
                    """
                    Enables/disables discrete transfer radiation model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/discrete_transfer").execute(*args, **kwargs)
                def beta_radiation_features(self, *args, **kwargs):
                    """
                    Enable Radiation Models with Non-Iterative Time Advancement (NITA) as Beta features in FL12.0.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/beta_radiation_features").execute(*args, **kwargs)
                def p1(self, *args, **kwargs):
                    """
                    Enables/disables P1 radiation model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/p1").execute(*args, **kwargs)
                def blending_factor(self, *args, **kwargs):
                    """
                    Sets numeric option for Discrete Ordinate model. Make sure thatSecond Order Upwind is selected for the Discrete Ordinates spatial 	discretization for the blending-factor option to 	appear in the text command list.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/blending_factor").execute(*args, **kwargs)
                def do_acceleration(self, *args, **kwargs):
                    """
                    Enables/disables the acceleration of the discrete 	ordinates (DO) radiation model calculations. Note that 	this text command is only available when running on 	Linux in parallel.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/do_acceleration").execute(*args, **kwargs)
                def discrete_ordinates(self, *args, **kwargs):
                    """
                    Enables/disables discrete ordinates radiation model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/discrete_ordinates").execute(*args, **kwargs)
                def mc_model_parameters(self, *args, **kwargs):
                    """
                    Specifies Monte Carlo model parameters. This text command is available only when the 	Monte Carlo model is enabled.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/mc_model_parameters").execute(*args, **kwargs)
                def mc_under_relaxation(self, *args, **kwargs):
                    """
                    Sets the under-relaxation factor for Monte Carlo radiation sources used in the 	energy equation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/mc_under_relaxation").execute(*args, **kwargs)
                def s2s(self, *args, **kwargs):
                    """
                    Enables/disables S2S radiation model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/s2s").execute(*args, **kwargs)
                def solar_calculator(self, *args, **kwargs):
                    """
                    Calculates sun direction and intensity.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solar_calculator").execute(*args, **kwargs)
                def montecarlo(self, *args, **kwargs):
                    """
                    Enables/disables the Monte Carlo radiation model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/montecarlo").execute(*args, **kwargs)
                def method_partially_specular_wall(self, *args, **kwargs):
                    """
                    Sets the method for partially specular wall with discrete ordinate model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/method_partially_specular_wall").execute(*args, **kwargs)
                def rosseland(self, *args, **kwargs):
                    """
                    Enables/disables Rosseland radiation model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/rosseland").execute(*args, **kwargs)
                def solar(self, *args, **kwargs):
                    """
                    Enables/disables solar model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solar").execute(*args, **kwargs)
                def target_cells_per_volume_cluster(self, *args, **kwargs):
                    """
                    Sets the amount of coarsening of the radiation mesh 	for the Monte Carlo radiation model. A number greater 	than one implies coarsening, whereas equal to one 	implies no coarsening.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/target_cells_per_volume_cluster").execute(*args, **kwargs)
                def radiation_iteration_parameters(self, *args, **kwargs):
                    """
                    Sets iteration parameters for radiation models.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/radiation_iteration_parameters").execute(*args, **kwargs)
                def non_gray_model_parameters(self, *args, **kwargs):
                    """
                    Sets parameters for non-gray model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/non_gray_model_parameters").execute(*args, **kwargs)
                def solar_irradiation(self, *args, **kwargs):
                    """
                    Enables/disables the solar irradiation model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solar_irradiation").execute(*args, **kwargs)
                def solution_method_for_do_coupling(self, *args, **kwargs):
                    """
                    Enables/disables the solution method for DO/energy coupling.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solution_method_for_do_coupling").execute(*args, **kwargs)
                def apply_full_solar_irradiation(self, *args, **kwargs):
                    """
                    Enables/disables the application of the complete solar load to the first wavelength 	band only, reverting to the pre-2019 R1 behavior of the 	Solar Load and Discrete Ordinates models.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/apply_full_solar_irradiation").execute(*args, **kwargs)
                def wsggm_cell_based(self, *args, **kwargs):
                    """
                    Enables/disables WSGGM cell based method. Note that when enabled, the wsggm-cell-based option will 	become available in theAbsorption Coefficient drop-down list in the Create/Edit Materials dialog 	box.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/wsggm_cell_based").execute(*args, **kwargs)

                class dtrm_parameters(TUIMenu):
                    """
                    Enters the dtrm parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def ray_trace(self, *args, **kwargs):
                        """
                        Creates DTRM rays for radiation.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/dtrm_parameters/ray_trace").execute(*args, **kwargs)
                    def controls(self, *args, **kwargs):
                        """
                        Sets dtrm solution controls.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/dtrm_parameters/controls").execute(*args, **kwargs)
                    def check_ray_file(self, *args, **kwargs):
                        """
                        Reads DTRM rays file.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/dtrm_parameters/check_ray_file").execute(*args, **kwargs)
                    def make_globs(self, *args, **kwargs):
                        """
                        Makes globs (coarser mesh) for radiation.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/dtrm_parameters/make_globs").execute(*args, **kwargs)

                class s2s_parameters(TUIMenu):
                    """
                    Enters the S2S parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def compute_vf_accelerated(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/s2s_parameters/compute_vf_accelerated").execute(*args, **kwargs)
                    def use_old_cluster_algorithm(self, *args, **kwargs):
                        """
                        Uses the old surface clustering algorithm.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/s2s_parameters/use_old_cluster_algorithm").execute(*args, **kwargs)
                    def set_global_faces_per_surface_cluster(self, *args, **kwargs):
                        """
                        Sets global value of faces per surface cluster for all boundary zones.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/s2s_parameters/set_global_faces_per_surface_cluster").execute(*args, **kwargs)
                    def print_thread_clusters(self, *args, **kwargs):
                        """
                        Prints the following for all boundary threads: thread-id, number of faces, faces per surface cluster, and the number of surface clusters.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/s2s_parameters/print_thread_clusters").execute(*args, **kwargs)
                    def non_participating_boundary_zones_temperature(self, *args, **kwargs):
                        """
                        Sets temperature for the non-participating boundary zones.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/s2s_parameters/non_participating_boundary_zones_temperature").execute(*args, **kwargs)
                    def split_angle(self, *args, **kwargs):
                        """
                        Sets split angle for the clustering algorithm.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/s2s_parameters/split_angle").execute(*args, **kwargs)
                    def compute_vf_only(self, *args, **kwargs):
                        """
                        Computes/writes view factors only.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/s2s_parameters/compute_vf_only").execute(*args, **kwargs)
                    def compute_fpsc_values(self, *args, **kwargs):
                        """
                        Computes only fpsc values based on current settings.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/s2s_parameters/compute_fpsc_values").execute(*args, **kwargs)
                    def compute_clusters_and_vf_accelerated(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/s2s_parameters/compute_clusters_and_vf_accelerated").execute(*args, **kwargs)
                    def print_zonewise_radiation(self, *args, **kwargs):
                        """
                        Prints the zonewise incoming radiation, viewfactors, and average temperature.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/s2s_parameters/print_zonewise_radiation").execute(*args, **kwargs)
                    def use_new_cluster_algorithm(self, *args, **kwargs):
                        """
                        Uses the new surface clustering algorithm.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/s2s_parameters/use_new_cluster_algorithm").execute(*args, **kwargs)
                    def compute_write_vf(self, *args, **kwargs):
                        """
                        Computes/writes surface clusters and view factors for S2S radiation model.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/s2s_parameters/compute_write_vf").execute(*args, **kwargs)
                    def enable_mesh_interface_clustering(self, *args, **kwargs):
                        """
                        Enables surface clusters on mesh interfaces.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/s2s_parameters/enable_mesh_interface_clustering").execute(*args, **kwargs)
                    def read_vf_file(self, *args, **kwargs):
                        """
                        Reads S2S file.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/s2s_parameters/read_vf_file").execute(*args, **kwargs)
                    def set_vf_parameters(self, *args, **kwargs):
                        """
                        Sets the parameters needed for the viewfactor calculations.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/s2s_parameters/set_vf_parameters").execute(*args, **kwargs)

                class solar_parameters(TUIMenu):
                    """
                    Enters the solar parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def ground_reflectivity(self, *args, **kwargs):
                        """
                        Sets ground reflectivity parameters.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solar_parameters/ground_reflectivity").execute(*args, **kwargs)
                    def autoread_solar_data(self, *args, **kwargs):
                        """
                        Sets autoread solar data parameters.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solar_parameters/autoread_solar_data").execute(*args, **kwargs)
                    def use_direction_from_sol_calc(self, *args, **kwargs):
                        """
                        Sets direction computed from solar calculator.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solar_parameters/use_direction_from_sol_calc").execute(*args, **kwargs)
                    def illumination_parameters(self, *args, **kwargs):
                        """
                        Sets illumination parameters.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solar_parameters/illumination_parameters").execute(*args, **kwargs)
                    def sol_adjacent_fluidcells(self, *args, **kwargs):
                        """
                        Sets solar load on for adjacent fluid cells.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solar_parameters/sol_adjacent_fluidcells").execute(*args, **kwargs)
                    def sol_on_demand(self, *args, **kwargs):
                        """
                        Sets solar load on demand.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solar_parameters/sol_on_demand").execute(*args, **kwargs)
                    def iteration_parameters(self, *args, **kwargs):
                        """
                        Sets update parameters.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solar_parameters/iteration_parameters").execute(*args, **kwargs)
                    def scattering_fraction(self, *args, **kwargs):
                        """
                        Sets scattering fraction parameters.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solar_parameters/scattering_fraction").execute(*args, **kwargs)
                    def solar_thread_control(self, *args, **kwargs):
                        """
                        Sets the number of threads to run the solar flux calculation. This item appears only when running in parallel with nodes located on a separate machine from the one running the host process andSolar Ray Tracing is enabled.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solar_parameters/solar_thread_control").execute(*args, **kwargs)
                    def quad_tree_parameters(self, *args, **kwargs):
                        """
                        Sets quad-tree refinement parameters.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solar_parameters/quad_tree_parameters").execute(*args, **kwargs)
                    def sun_direction_vector(self, *args, **kwargs):
                        """
                        Sets sun direction vector.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solar_parameters/sun_direction_vector").execute(*args, **kwargs)
                    def sol_camera_pos(self, *args, **kwargs):
                        """
                        Sets camera position based on sun direction vector.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solar_parameters/sol_camera_pos").execute(*args, **kwargs)
                    def autosave_solar_data(self, *args, **kwargs):
                        """
                        Sets autosave solar data parameters.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/radiation/solar_parameters/autosave_solar_data").execute(*args, **kwargs)

            class solver(TUIMenu):
                """
                Enters the menu to select the solver.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def density_based_implicit(self, *args, **kwargs):
                    """
                    Enables/disables the density-based-implicit solver.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/solver/density_based_implicit").execute(*args, **kwargs)
                def pressure_based(self, *args, **kwargs):
                    """
                    Enables/disables the pressure-based solver.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/solver/pressure_based").execute(*args, **kwargs)
                def adjust_solver_defaults_based_on_setup(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/solver/adjust_solver_defaults_based_on_setup").execute(*args, **kwargs)
                def density_based_explicit(self, *args, **kwargs):
                    """
                    Enables/disables the density-based-explicit solver.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/solver/density_based_explicit").execute(*args, **kwargs)

            class species(TUIMenu):
                """
                Enters the species models menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.CHEMKIN_CFD_parameters = self.__class__.CHEMKIN_CFD_parameters(service, version, mode, path + ["CHEMKIN_CFD_parameters"])
                    super().__init__(service, version, mode, path)
                def pdf_transport_expert(self, *args, **kwargs):
                    """
                    Enables/disables PDF Transport expert user.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/pdf_transport_expert").execute(*args, **kwargs)
                def spark_model(self, *args, **kwargs):
                    """
                    Switches between the R15 and R14.5 spark models and sets spark model 	parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/spark_model").execute(*args, **kwargs)
                def stiff_chemistry(self, *args, **kwargs):
                    """
                    Enables/disables stiff chemistry option.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/stiff_chemistry").execute(*args, **kwargs)
                def premixed_combustion(self, *args, **kwargs):
                    """
                    Enables/disables premixed combustion model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/premixed_combustion").execute(*args, **kwargs)
                def set_multi_regime_fgm(self, *args, **kwargs):
                    """
                    Set-multi-regim-fgm-parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/set_multi_regime_fgm").execute(*args, **kwargs)
                def partially_premixed_properties(self, *args, **kwargs):
                    """
                    Sets/changes partially-premixed mixture properties. 	This command is only available when partially-premixed-combustion? 	is enabled.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/partially_premixed_properties").execute(*args, **kwargs)
                def pdf_transport(self, *args, **kwargs):
                    """
                    Enables/disables the composition PDF transport combustion model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/pdf_transport").execute(*args, **kwargs)
                def reactor_network_model(self, *args, **kwargs):
                    """
                    Enables/disables the Reactor Network Model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/reactor_network_model").execute(*args, **kwargs)
                def off(self, *args, **kwargs):
                    """
                    Enables/disables solution of species models.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/off").execute(*args, **kwargs)
                def surf_reaction_aggressiveness_factor(self, *args, **kwargs):
                    """
                    Sets the surface reaction aggressiveness factor.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/surf_reaction_aggressiveness_factor").execute(*args, **kwargs)
                def ignition_model_controls(self, *args, **kwargs):
                    """
                    Sets ignition model parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/ignition_model_controls").execute(*args, **kwargs)
                def mixing_model(self, *args, **kwargs):
                    """
                    Sets PDF Transport mixing model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/mixing_model").execute(*args, **kwargs)
                def set_turb_chem_interaction(self, *args, **kwargs):
                    """
                    Sets EDC model constants.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/set_turb_chem_interaction").execute(*args, **kwargs)
                def set_premixed_combustion(self, *args, **kwargs):
                    """
                    Sets premixed combustion parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/set_premixed_combustion").execute(*args, **kwargs)
                def particle_surface_reactions(self, *args, **kwargs):
                    """
                    Enables/disables particle surface reactions.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/particle_surface_reactions").execute(*args, **kwargs)
                def init_unsteady_flamelet_prob(self, *args, **kwargs):
                    """
                    Initializes Unsteady Flamelet Probability.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/init_unsteady_flamelet_prob").execute(*args, **kwargs)
                def reaction_diffusion_balance(self, *args, **kwargs):
                    """
                    Enables/disables reaction diffusion balance at reacting surface for surface 	reactions.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/reaction_diffusion_balance").execute(*args, **kwargs)
                def save_gradients(self, *args, **kwargs):
                    """
                    Enables/disables storage of species mass fraction gradients.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/save_gradients").execute(*args, **kwargs)
                def relax_to_equil(self, *args, **kwargs):
                    """
                    Enables/disables the Relaxation to Chemical Equilibrium model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/relax_to_equil").execute(*args, **kwargs)
                def ignition_model(self, *args, **kwargs):
                    """
                    Enables/disables the ignition model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/ignition_model").execute(*args, **kwargs)
                def partially_premixed_combustion(self, *args, **kwargs):
                    """
                    Enables/disables partially premixed combustion model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/partially_premixed_combustion").execute(*args, **kwargs)
                def combustion_expert(self, *args, **kwargs):
                    """
                    Enables import of the CHEMKIN mechanism transport 	data. When this option is enabled, you will be prompted 	for importing CHEMKIN transport property database when 	setting your combustion case.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/combustion_expert").execute(*args, **kwargs)
                def volumetric_reactions(self, *args, **kwargs):
                    """
                    Enables/disables volumetric reactions.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/volumetric_reactions").execute(*args, **kwargs)
                def heat_of_surface_reactions(self, *args, **kwargs):
                    """
                    Enables/disables heat of surface reactions.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/heat_of_surface_reactions").execute(*args, **kwargs)
                def liquid_energy_diffusion(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/liquid_energy_diffusion").execute(*args, **kwargs)
                def diffusion_energy_source(self, *args, **kwargs):
                    """
                    Enables/disables diffusion energy source.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/diffusion_energy_source").execute(*args, **kwargs)
                def partially_premixed_combustion_grids(self, *args, **kwargs):
                    """
                    Sets values for the grid distribution for PDF table or 	flamelet parameter. This text command is available only 	for partially premixed combustion cases with FGM.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/partially_premixed_combustion_grids").execute(*args, **kwargs)
                def species_transport(self, *args, **kwargs):
                    """
                    Enables/disables the species transport model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/species_transport").execute(*args, **kwargs)
                def mass_deposition_source(self, *args, **kwargs):
                    """
                    Enables/disables mass deposition source due to surface reactions.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/mass_deposition_source").execute(*args, **kwargs)
                def premixed_model(self, *args, **kwargs):
                    """
                    Sets premixed combustion model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/premixed_model").execute(*args, **kwargs)
                def non_premixed_combustion_parameters(self, *args, **kwargs):
                    """
                    Sets PDF parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/non_premixed_combustion_parameters").execute(*args, **kwargs)
                def CHEMKIN_CFD(self, *args, **kwargs):
                    """
                    Enables/disables the Ansys CHEMKIN-CFD solver.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/CHEMKIN_CFD").execute(*args, **kwargs)
                def decoupled_detailed_chemistry(self, *args, **kwargs):
                    """
                    Enables/disables the Decoupled Detailed Chemistry model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/decoupled_detailed_chemistry").execute(*args, **kwargs)
                def multicomponent_diffusion(self, *args, **kwargs):
                    """
                    Enables/disables multicomponent diffusion.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/multicomponent_diffusion").execute(*args, **kwargs)
                def reacting_channel_model(self, *args, **kwargs):
                    """
                    Enables/disables the Reacting Channel Model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/reacting_channel_model").execute(*args, **kwargs)
                def combustion_numerics(self, *args, **kwargs):
                    """
                    Applies optimal solver settings automatically to provide a faster solution time. 	This command is available only for transient 	non-premixed and partially premixed combustion 	models.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/combustion_numerics").execute(*args, **kwargs)
                def thermal_diffusion(self, *args, **kwargs):
                    """
                    Enables/disables thermal diffusion.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/thermal_diffusion").execute(*args, **kwargs)
                def liquid_micro_mixing(self, *args, **kwargs):
                    """
                    Enables/disables liquid micro mixing.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/liquid_micro_mixing").execute(*args, **kwargs)
                def partially_premixed_combustion_parameters(self, *args, **kwargs):
                    """
                    Sets PDF parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/partially_premixed_combustion_parameters").execute(*args, **kwargs)
                def full_tabulation(self, *args, **kwargs):
                    """
                    Enables/disables building of a full 2-mixture fraction table.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/full_tabulation").execute(*args, **kwargs)
                def clear_isat_table(self, *args, **kwargs):
                    """
                    Clears ISAT table.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/clear_isat_table").execute(*args, **kwargs)
                def coal_calculator(self, *args, **kwargs):
                    """
                    Sets up coal modeling inputs.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/coal_calculator").execute(*args, **kwargs)
                def epdf_energy(self, *args, **kwargs):
                    """
                    Enables/disables EPDF energy option.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/epdf_energy").execute(*args, **kwargs)
                def water_corrosion_pre(self, *args, **kwargs):
                    """
                    Compute water chemistry and set up corrosion material.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/water_corrosion_pre").execute(*args, **kwargs)
                def species_transport_expert(self, *args, **kwargs):
                    """
                    Sets the convergence acceleration expert parameters. This command is only available 	when the species transport model is enabled.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/species_transport_expert").execute(*args, **kwargs)
                def inlet_diffusion(self, *args, **kwargs):
                    """
                    Enables/disables inclusion of diffusion at inlets.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/inlet_diffusion").execute(*args, **kwargs)
                def import_flamelet_for_restart(self, *args, **kwargs):
                    """
                    Imports Flamelet File for Restart.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/import_flamelet_for_restart").execute(*args, **kwargs)
                def inert_transport_controls(self, *args, **kwargs):
                    """
                    Sets inert transport model parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/inert_transport_controls").execute(*args, **kwargs)
                def inert_transport_model(self, *args, **kwargs):
                    """
                    Enables/disables the inert transport model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/inert_transport_model").execute(*args, **kwargs)
                def electro_chemical_surface_reactions(self, *args, **kwargs):
                    """
                    Enables/disables electrochemical surface reactions.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/electro_chemical_surface_reactions").execute(*args, **kwargs)
                def reacting_channel_model_options(self, *args, **kwargs):
                    """
                    Sets Reacting Channel Model parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/reacting_channel_model_options").execute(*args, **kwargs)
                def partially_premixed_combustion_expert(self, *args, **kwargs):
                    """
                    Sets PDF expert parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/partially_premixed_combustion_expert").execute(*args, **kwargs)
                def re_calc_par_premix_props(self, *args, **kwargs):
                    """
                    Re-calculate partially-premixed properties.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/re_calc_par_premix_props").execute(*args, **kwargs)
                def surf_reaction_netm_params(self, *args, **kwargs):
                    """
                    Sets the surface reaction parameters for the Non-Equilibrium Thermal Model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/surf_reaction_netm_params").execute(*args, **kwargs)
                def integration_parameters(self, *args, **kwargs):
                    """
                    Sets chemistry ODE integrator parameters. Enables/disables stiff chemistry 	acceleration methods and set their parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/integration_parameters").execute(*args, **kwargs)
                def thickened_flame_model(self, *args, **kwargs):
                    """
                    Enables/disables the Relaxation to Chemical Equilibrium model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/thickened_flame_model").execute(*args, **kwargs)
                def wall_surface_reactions(self, *args, **kwargs):
                    """
                    Enables/disables wall surface reactions.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/wall_surface_reactions").execute(*args, **kwargs)
                def species_migration(self, *args, **kwargs):
                    """
                    Includes species migration in electric field. This command is available only when 	the electrochemical surface reactions are 	enabled.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/species_migration").execute(*args, **kwargs)
                def flamelet_expert(self, *args, **kwargs):
                    """
                    Sets flamelet expert parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/flamelet_expert").execute(*args, **kwargs)
                def non_premixed_combustion_expert(self, *args, **kwargs):
                    """
                    Sets PDF expert parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/non_premixed_combustion_expert").execute(*args, **kwargs)
                def non_premixed_combustion(self, *args, **kwargs):
                    """
                    Enables/disables non-premixed combustion model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/species/non_premixed_combustion").execute(*args, **kwargs)

                class CHEMKIN_CFD_parameters(TUIMenu):
                    """
                    Enters the expert CHEMKIN-CFD parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def add_cell_monitor(self, *args, **kwargs):
                        """
                        Monitors cell for debug output.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/species/CHEMKIN_CFD_parameters/add_cell_monitor").execute(*args, **kwargs)
                    def advanced_options(self, *args, **kwargs):
                        """
                        Sets advanced parameter options.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/species/CHEMKIN_CFD_parameters/advanced_options").execute(*args, **kwargs)
                    def delete_cell_monitors(self, *args, **kwargs):
                        """
                        Deletes cell monitors.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/species/CHEMKIN_CFD_parameters/delete_cell_monitors").execute(*args, **kwargs)
                    def basic_options(self, *args, **kwargs):
                        """
                        Sets basic parameter options.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/species/CHEMKIN_CFD_parameters/basic_options").execute(*args, **kwargs)
                    def list_cell_monitors(self, *args, **kwargs):
                        """
                        Lists cell monitors.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/species/CHEMKIN_CFD_parameters/list_cell_monitors").execute(*args, **kwargs)

            class two_temperature(TUIMenu):
                """
                Enters the Two-Temperature model menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def nasa9_enhancement(self, *args, **kwargs):
                    """
                    Apply nasa9 robustness enhancements in the two-temperature model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/two_temperature/nasa9_enhancement").execute(*args, **kwargs)
                def set_verbosity(self, *args, **kwargs):
                    """
                    Specifies the level of detail printed in the console 	about the Two-Temperature model. For a verbosity of one, 	Fluent will print the number of cells that reach the 	temperature limit, have an excessive temperature change, 	or get a negative temperature.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/two_temperature/set_verbosity").execute(*args, **kwargs)
                def robustness_enhancement(self, *args, **kwargs):
                    """
                    Enables/disables the robustness enhancement, which is 	on by default.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/two_temperature/robustness_enhancement").execute(*args, **kwargs)
                def enable(self, *args, **kwargs):
                    """
                    Enables/disables the Two-Temperature model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/two_temperature/enable").execute(*args, **kwargs)

            class cht(TUIMenu):
                """
                Enters the cht (conjugate heat transfer) menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.explicit_time_averaged_coupling = self.__class__.explicit_time_averaged_coupling(service, version, mode, path + ["explicit_time_averaged_coupling"])
                    super().__init__(service, version, mode, path)
                def implicit_coupling(self, *args, **kwargs):
                    """
                    Enables the implicit mapping scheme for any 	fluid-solid pair with a mapped mesh interface (only 	required for cases set up in version 19.2 or 	earlier).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/cht/implicit_coupling").execute(*args, **kwargs)
                def read_mi_type_wall(self, *args, **kwargs):
                    """
                    Read mapped interface data settings from a csv file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/cht/read_mi_type_wall").execute(*args, **kwargs)
                def write_mi_type_wall(self, *args, **kwargs):
                    """
                    Write mapped interface settings to a scv file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/models/cht/write_mi_type_wall").execute(*args, **kwargs)

                class explicit_time_averaged_coupling(TUIMenu):
                    """
                    Enters the explicit time averaged thermal coupling 	menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def conformal_coupled_walls(self, *args, **kwargs):
                        """
                        Select fluid-solid coupled walls (without shell) for explicit coupling using time averaged thermal variables.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/cht/explicit_time_averaged_coupling/conformal_coupled_walls").execute(*args, **kwargs)
                    def fuse_explicit_cht_zones(self, *args, **kwargs):
                        """
                        Fuse slitted conformal coupled walls marked for transient explicit thermal coupling.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/cht/explicit_time_averaged_coupling/fuse_explicit_cht_zones").execute(*args, **kwargs)
                    def mapped_interfaces(self, *args, **kwargs):
                        """
                        Select fluid-solid mapped interfaces for explicit coupling using time averaged thermal variables.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/cht/explicit_time_averaged_coupling/mapped_interfaces").execute(*args, **kwargs)
                    def coupling_controls(self, *args, **kwargs):
                        """
                        Specify explcit coupling controls.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/models/cht/explicit_time_averaged_coupling/coupling_controls").execute(*args, **kwargs)

        class curvilinear_coordinate_system(TUIMenu):
            """
            Curvilinear Coordinate System.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def delete(self, *args, **kwargs):
                """
                Delete Curvilinear Coordinate System.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/curvilinear_coordinate_system/delete").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an existing curvilinear coordinate system.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/curvilinear_coordinate_system/edit").execute(*args, **kwargs)
            def display_settings(self, *args, **kwargs):
                """
                Display settings for Curvilinear Coordinate System.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/curvilinear_coordinate_system/display_settings").execute(*args, **kwargs)
            def calculation_settings(self, *args, **kwargs):
                """
                Define Settings for curvilinear coordinate system.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/curvilinear_coordinate_system/calculation_settings").execute(*args, **kwargs)
            def new(self, *args, **kwargs):
                """
                Define a new curvilinear coordinate system.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/curvilinear_coordinate_system/new").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Display Curvilinear Coordinate System.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/curvilinear_coordinate_system/display").execute(*args, **kwargs)

        class parameters(TUIMenu):
            """
            Enters the parameters menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.input_parameters = self.__class__.input_parameters(service, version, mode, path + ["input_parameters"])
                self.list_parameters = self.__class__.list_parameters(service, version, mode, path + ["list_parameters"])
                self.output_parameters = self.__class__.output_parameters(service, version, mode, path + ["output_parameters"])
                super().__init__(service, version, mode, path)
            def enable_in_TUI(self, *args, **kwargs):
                """
                Enables/disables parameters in the text user interface.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/parameters/enable_in_TUI").execute(*args, **kwargs)

            class input_parameters(TUIMenu):
                """
                Enters the input-parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.advance = self.__class__.advance(service, version, mode, path + ["advance"])
                    super().__init__(service, version, mode, path)
                def delete(self, *args, **kwargs):
                    """
                    Deletes an input parameter.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/parameters/input_parameters/delete").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edits an input parameter.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/parameters/input_parameters/edit").execute(*args, **kwargs)

                class advance(TUIMenu):
                    """
                    Define custom variable to use input parameter.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def use_in(self, *args, **kwargs):
                        """
                        Use input parameter in solver-udf or in scheme-procedure.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/parameters/input_parameters/advance/use_in").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        List of custom-input-parameters.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/parameters/input_parameters/advance/list").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete selected custom-input-parameters.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/parameters/input_parameters/advance/delete").execute(*args, **kwargs)

            class list_parameters(TUIMenu):
                """
                Enter list-param menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def input_parameters(self, *args, **kwargs):
                    """
                    List all input parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/parameters/list_parameters/input_parameters").execute(*args, **kwargs)
                def output_parameters(self, *args, **kwargs):
                    """
                    List all output parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/parameters/list_parameters/output_parameters").execute(*args, **kwargs)

            class output_parameters(TUIMenu):
                """
                Enters the output-parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def print_all_to_console(self, *args, **kwargs):
                    """
                    Displays all parameter values in the console.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/parameters/output_parameters/print_all_to_console").execute(*args, **kwargs)
                def print_to_console(self, *args, **kwargs):
                    """
                    Displays parameter value in the console.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/parameters/output_parameters/print_to_console").execute(*args, **kwargs)
                def write_to_file(self, *args, **kwargs):
                    """
                    Writes parameter value to file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/parameters/output_parameters/write_to_file").execute(*args, **kwargs)
                def write_all_to_file(self, *args, **kwargs):
                    """
                    Writes all parameter values to file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/parameters/output_parameters/write_all_to_file").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Creates an output parameter.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/parameters/output_parameters/create").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edits an output parameter.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/parameters/output_parameters/edit").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Deletes an output parameter.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/parameters/output_parameters/delete").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Renames an output parameter.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/parameters/output_parameters/rename").execute(*args, **kwargs)

        class overset_interfaces(TUIMenu):
            """
            Enters the overset interfaces menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.adapt = self.__class__.adapt(service, version, mode, path + ["adapt"])
                self.options = self.__class__.options(service, version, mode, path + ["options"])
                self.cut_control = self.__class__.cut_control(service, version, mode, path + ["cut_control"])
                super().__init__(service, version, mode, path)
            def check(self, *args, **kwargs):
                """
                Checks the integrity of the overset interfaces. Reports orphan cells and errors in the domain connectivity.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/check").execute(*args, **kwargs)
            def write_dci_to_case(self, *args, **kwargs):
                """
                Save domain connectivity information (DCI) to case file.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/write_dci_to_case").execute(*args, **kwargs)
            def find_bounding_cell(self, *args, **kwargs):
                """
                Find bounding cell for given cell or search point.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/find_bounding_cell").execute(*args, **kwargs)
            def read_dci_from_case(self, *args, **kwargs):
                """
                Read domain connectivity information (DCI) from case file.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/read_dci_from_case").execute(*args, **kwargs)
            def write_cell_types(self, *args, **kwargs):
                """
                Write overset cell types into file.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/write_cell_types").execute(*args, **kwargs)
            def display_cells(self, *args, **kwargs):
                """
                Displays the overset cells marked using the text command define/overset-interfaces/mark-cells.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/display_cells").execute(*args, **kwargs)
            def debug_hole_cut(self, *args, **kwargs):
                """
                Debugging tool to troubleshoot hole cutting of overset interfaces. This text command is only available when define/overset-interfaces/options/expert? is set to yes.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/debug_hole_cut").execute(*args, **kwargs)
            def grid_priorities(self, *args, **kwargs):
                """
                Allows you to specify grid priorities on background and component meshes, used in the overlap minimization of an overset interface.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/grid_priorities").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Deletes all overset interfaces in the domain.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/delete_all").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                Lists information about the overset interfaces. The output depends on the overset verbosity setting.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/list").execute(*args, **kwargs)
            def write_dci(self, *args, **kwargs):
                """
                Save domain connectivity information (DCI) to a text file.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/write_dci").execute(*args, **kwargs)
            def mark_cells(self, *args, **kwargs):
                """
                Marks the specified overset cells (solve, receptor, donor, orphan, or dead) and fills registers based on the markings. Display the marked cells via the text command define/overset-interfaces/display-cells.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/mark_cells").execute(*args, **kwargs)
            def mark_cell_change(self, *args, **kwargs):
                """
                Marks cells that have undergone a specified overset cell type change (from solve,receptor, or dead to any other type) in the last time step. Adaption registers are automatically filled based on these markings. This text command is only available for unsteady simulations and if define/overset-interfaces/options/expert? is set to yes.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/mark_cell_change").execute(*args, **kwargs)
            def set_mark_bounds(self, *args, **kwargs):
                """
                Allows you to set bounds so that any marking of cells is performed within a spherical region based on a specified origin and radius. This can be useful when diagnosing a local problem on a large mesh. This text command is only available if define/overset-interfaces/options/expert? is set to yes. After defining the bounds, you can then mark the cells using the define/overset-interfaces/mark-cell-change or define/overset-interfaces/mark-cells text command. To disable the bounds, enter a radius of 0.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/set_mark_bounds").execute(*args, **kwargs)
            def clear(self, *args, **kwargs):
                """
                Clears the domain connectivity of an overset interface. This text command is only available when define/overset-interfaces/options/expert? is set to yes.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/clear").execute(*args, **kwargs)
            def clear_all(self, *args, **kwargs):
                """
                Clears the domain connectivity of all overset interfaces. This text command is only available when define/overset-interfaces/options/expert? is set to yes.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/clear_all").execute(*args, **kwargs)
            def update_from_dci(self, *args, **kwargs):
                """
                Update all overset intrfaces from stored domain connectivity information (DCI).
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/update_from_dci").execute(*args, **kwargs)
            def find_all_bounding_cells(self, *args, **kwargs):
                """
                Find bounding cells for all cell centroids.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/find_all_bounding_cells").execute(*args, **kwargs)
            def intersect(self, *args, **kwargs):
                """
                Executes the hole cutting of an overset interface and establishes the domain connectivity. This text command is only available when define/overset-interfaces/options/expert? is set to yes.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/intersect").execute(*args, **kwargs)
            def free_dci(self, *args, **kwargs):
                """
                Free overset domain connectivity information (DCI).
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/free_dci").execute(*args, **kwargs)
            def intersect_all(self, *args, **kwargs):
                """
                Executes hole cutting for all overset interfaces in the domain. This text command is only available when define/overset-interfaces/options/expert? is set to yes.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/intersect_all").execute(*args, **kwargs)
            def fill_dci(self, *args, **kwargs):
                """
                Fill overset domain connectivity information (DCI).
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/fill_dci").execute(*args, **kwargs)
            def create(self, *args, **kwargs):
                """
                Creates an overset interface.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/create").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Deletes an overset interface.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/delete").execute(*args, **kwargs)

            class adapt(TUIMenu):
                """
                Enters the overset adaption menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.set = self.__class__.set(service, version, mode, path + ["set"])
                    super().__init__(service, version, mode, path)
                def mark_adaption(self, *args, **kwargs):
                    """
                    Marks cells to identify those that can be adapted in 	order to improve your overset mesh.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/adapt/mark_adaption").execute(*args, **kwargs)
                def adapt_mesh(self, *args, **kwargs):
                    """
                    Marks and adapts the mesh to improve your overset 	mesh.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/adapt/adapt_mesh").execute(*args, **kwargs)

                class set(TUIMenu):
                    """
                    Enters the overset adaption set menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def automatic(self, *args, **kwargs):
                        """
                        Enable the option to automatically adapt overset meshes during solution update.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/adapt/set/automatic").execute(*args, **kwargs)
                    def maximum_refinement_level(self, *args, **kwargs):
                        """
                        Sets the maximum level of refinement during overset adaption, in conjunction with the value set using the mesh/adapt/set/maximum-refinement-level text command (the larger of the two values is used).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/adapt/set/maximum_refinement_level").execute(*args, **kwargs)
                    def mark_orphans(self, *args, **kwargs):
                        """
                        Enables/disables the option to adapt for orphan reduction.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/adapt/set/mark_orphans").execute(*args, **kwargs)
                    def adaption_sweeps(self, *args, **kwargs):
                        """
                        Sets the number of rounds of adaption applied during each adaption cycle.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/adapt/set/adaption_sweeps").execute(*args, **kwargs)
                    def length_ratio_max(self, *args, **kwargs):
                        """
                        Sets the length scale ratio threshold used to determine which cells are marked for adaption based on donor-receptor cell size differences.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/adapt/set/length_ratio_max").execute(*args, **kwargs)
                    def mark_gaps(self, *args, **kwargs):
                        """
                        Enable the option to adapt underresolved gaps.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/adapt/set/mark_gaps").execute(*args, **kwargs)
                    def mark_coarsening(self, *args, **kwargs):
                        """
                        Enables/disables the option to coarsen the mesh if mesh refinement is no longer needed. This option is enabled by default.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/adapt/set/mark_coarsening").execute(*args, **kwargs)
                    def mark_size(self, *args, **kwargs):
                        """
                        Enables/disables the option to adapt based on donor-receptor cell size differences.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/adapt/set/mark_size").execute(*args, **kwargs)
                    def mark_fixed_orphans(self, *args, **kwargs):
                        """
                        Enables/disables the option to also adapt based on cells that are not actual orphans because they were fixed by accepting neighbor donors. This option is only applied if define/overset-interfaces/adapt/set/mark-orphans? is enabled.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/adapt/set/mark_fixed_orphans").execute(*args, **kwargs)
                    def buffer_layers(self, *args, **kwargs):
                        """
                        Sets the number of cell layers marked in addition to the cells marked for orphan adaption.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/adapt/set/buffer_layers").execute(*args, **kwargs)
                    def gap_resolution(self, *args, **kwargs):
                        """
                        Set the target (minimum) gap resolution used when marking cells for gap adaption.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/adapt/set/gap_resolution").execute(*args, **kwargs)
                    def prismatic(self, *args, **kwargs):
                        """
                        Enable the option to use anisotropic adaption in prismatic cells.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/adapt/set/prismatic").execute(*args, **kwargs)

            class options(TUIMenu):
                """
                Enters the overset interface options menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def render_receptor_cells(self, *args, **kwargs):
                    """
                    Allows you to enable visualization of receptor cells in contour and mesh 	displays.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/render_receptor_cells").execute(*args, **kwargs)
                def auto_create(self, *args, **kwargs):
                    """
                    Enables the automatic creation of a default overset interface during 	initialization or mesh motion update.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/auto_create").execute(*args, **kwargs)
                def donor_priority_method(self, *args, **kwargs):
                    """
                    Allows you to specify whether the cell donor priority used in the overlap 	minimization of an overset interface is inversely proportional to either the 	cell size or the distance to the nearest boundary.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/donor_priority_method").execute(*args, **kwargs)
                def mesh_interfaces(self, *args, **kwargs):
                    """
                    Allows the inclusion of non-conformal mesh interfaces 	inside overset cell zones, as long as the mesh 	interfaces do not spatially overlap with the cells where 	the overset interfaces lie.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/mesh_interfaces").execute(*args, **kwargs)
                def modified_hole_cutting(self, *args, **kwargs):
                    """
                    Enables / disables modified hole cutting parameters. When enabled, the parameters used can 	help avoid dead cell zones that result from a hole 	cutting failure. This text command is only available 	when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/modified_hole_cutting").execute(*args, **kwargs)
                def modified_donor_search(self, *args, **kwargs):
                    """
                    Enables / disables modified donor search parameters. When enabled, these parameters result in 	a more extended donor search, which can be helpful for 	meshes with orphans. This text command is only available 	when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/modified_donor_search").execute(*args, **kwargs)
                def parallel(self, *args, **kwargs):
                    """
                    Allows you to select the algorithm used for overset parallel processing. You can 	select from the default cell exchange model or the local 	cell zone replication model; the cell exchange model 	should require less memory and may result in faster 	calculations.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/parallel").execute(*args, **kwargs)
                def solve_island_removal(self, *args, **kwargs):
                    """
                    Sets the method used to control the removal of isolated patches of solve cells. This text 	command is only available when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/solve_island_removal").execute(*args, **kwargs)
                def transient_caching(self, *args, **kwargs):
                    """
                    Sets the options to control caching of entities in transient overset simulations. This text 	command is only available when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/transient_caching").execute(*args, **kwargs)
                def overlap_boundaries(self, *args, **kwargs):
                    """
                    Allows you to disable the detection of overlapping boundaries during hole cutting, 	in order to reduce the computational expense for cases 	that do not include such boundaries. When enabled, this 	text command also allows you to specify which boundary 	zones should be considered when detecting overlapping 	boundaries; this can be helpful when the default hole 	cutting process fails.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/overlap_boundaries").execute(*args, **kwargs)
                def partial_cut_faces(self, *args, **kwargs):
                    """
                    Enables/disables enhanced hole cutting, where partially overlapping cut faces are 	decomposed into overlapping and non-overlapping 	fractions, and only the non-overlapping fractions 	participate in the hole cutting. This can help avoid the 	situation where a region or cell zone is erroneously 	identified as dead because of leakage during flood 	filling, even though it has overlapping boundaries that 	match well. When this text command is disabled, the 	partially overlapping faces are entirely protected from 	cutting.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/partial_cut_faces").execute(*args, **kwargs)
                def minimize_overlap(self, *args, **kwargs):
                    """
                    Allows you to disable overlap minimization during hole cutting.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/minimize_overlap").execute(*args, **kwargs)
                def expert(self, *args, **kwargs):
                    """
                    Enables / disables overset-related expert tools.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/expert").execute(*args, **kwargs)
                def dead_cell_update(self, *args, **kwargs):
                    """
                    Enables/disables the updating of dead cells during the solution process, which may 	be helpful for some moving and dynamic mesh simulations 	(though at the cost of solver performance). You can 	enter the number of layers of dead cells adjacent to the 	receptor cells that you want updated, or enter -1 to request that all dead 	cells are updated. This text command is only available 	for transient simulations when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/dead_cell_update").execute(*args, **kwargs)
                def update_before_case_write(self, *args, **kwargs):
                    """
                    Enables/disables the updating of the overset interfaces before writing a case file in the 	Common Fluids Format (CFF). This text command is only 	available when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/update_before_case_write").execute(*args, **kwargs)
                def node_connected_donors(self, *args, **kwargs):
                    """
                    Allows you to switch between face or node connected donor cells. This text command is only 	available when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/node_connected_donors").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    Specifies the level of detail printed in the console about overset 	interfaces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/options/verbosity").execute(*args, **kwargs)

            class cut_control(TUIMenu):
                """
                Enters the overset hole cut control menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.cut_seeds = self.__class__.cut_seeds(service, version, mode, path + ["cut_seeds"])
                    super().__init__(service, version, mode, path)
                def add(self, *args, **kwargs):
                    """
                    Adds a hole cut control, so that a boundary zone does 	not cut specified cell zones.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/cut_control/add").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Deletes the hole cut control for a boundary 	zone.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/cut_control/delete").execute(*args, **kwargs)
                def delete_all(self, *args, **kwargs):
                    """
                    Deletes the hole cut controls for all boundary 	zones.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/cut_control/delete_all").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    Lists the defined hole cut controls.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/cut_control/list").execute(*args, **kwargs)

                class cut_seeds(TUIMenu):
                    """
                    Enters the overset hole cut seeds menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def add(self, *args, **kwargs):
                        """
                        Add a hole cut seed.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/cut_control/cut_seeds/add").execute(*args, **kwargs)
                    def delete_all(self, *args, **kwargs):
                        """
                        Delete all hole cut seeds.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/cut_control/cut_seeds/delete_all").execute(*args, **kwargs)
                    def cut_seeds_for_all_component_zones(self, *args, **kwargs):
                        """
                        Specifies whether all component zones get cut seeds, which cut pilot holes into the overlapping meshes that will then be enlarged during overlap minimization.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/cut_control/cut_seeds/cut_seeds_for_all_component_zones").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        List the defined hole cut seeds.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/cut_control/cut_seeds/list").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete a hole cut seed.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/overset_interfaces/cut_control/cut_seeds/delete").execute(*args, **kwargs)

        class materials(TUIMenu):
            """
            Enters the materials menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.data_base = self.__class__.data_base(service, version, mode, path + ["data_base"])
                super().__init__(service, version, mode, path)
            def delete(self, *args, **kwargs):
                """
                Deletes a material from local storage.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/materials/delete").execute(*args, **kwargs)
            def list_materials(self, *args, **kwargs):
                """
                Lists all locally-stored materials.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/materials/list_materials").execute(*args, **kwargs)
            def copy(self, *args, **kwargs):
                """
                Copies a material from the database.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/materials/copy").execute(*args, **kwargs)
            def change_create(self, *args, **kwargs):
                """
                Changes the properties of a locally-stored material or create a new material.   Generally, the properties you enter at the prompts will be filtered according to your case and model settings. However, some of the listed properties may not match the selection choice in the Graphics User Interface. Typically, those excessive properties in the Text User Interface will not be used in your simulation.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/materials/change_create").execute(*args, **kwargs)
            def copy_by_formula(self, *args, **kwargs):
                """
                Copies a material from the database by formula.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/materials/copy_by_formula").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                Lists the properties of a locally-stored material.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/materials/list_properties").execute(*args, **kwargs)

            class data_base(TUIMenu):
                """
                Enters the material database menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def edit(self, *args, **kwargs):
                    """
                    Edits material.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/materials/data_base/edit").execute(*args, **kwargs)
                def list_materials(self, *args, **kwargs):
                    """
                    Lists all materials in the database.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/materials/data_base/list_materials").execute(*args, **kwargs)
                def new(self, *args, **kwargs):
                    """
                    Defines new material.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/materials/data_base/new").execute(*args, **kwargs)
                def database_type(self, *args, **kwargs):
                    """
                    Sets the database type 	(fluent-database, 	granta-mds, or 	user-defined).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/materials/data_base/database_type").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    Lists the properties of a material in the database.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/materials/data_base/list_properties").execute(*args, **kwargs)
                def save(self, *args, **kwargs):
                    """
                    Saves user-defined database.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/materials/data_base/save").execute(*args, **kwargs)

        class mixing_planes(TUIMenu):
            """
            Enters the mixing planes menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                super().__init__(service, version, mode, path)
            def create(self, *args, **kwargs):
                """
                Creates a mixing plane.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mixing_planes/create").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                Lists defined mixing plane(s).
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mixing_planes/list").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Deletes a mixing plane.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/mixing_planes/delete").execute(*args, **kwargs)

            class set(TUIMenu):
                """
                Sets global parameters relevant to mixing planes.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.conserve_total_enthalpy = self.__class__.conserve_total_enthalpy(service, version, mode, path + ["conserve_total_enthalpy"])
                    self.conserve_swirl = self.__class__.conserve_swirl(service, version, mode, path + ["conserve_swirl"])
                    super().__init__(service, version, mode, path)
                def fix_pressure_level(self, *args, **kwargs):
                    """
                    Sets fixed pressure level using value based on define/reference-pressure-location.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/mixing_planes/set/fix_pressure_level").execute(*args, **kwargs)
                def averaging_method(self, *args, **kwargs):
                    """
                    Sets the mixing plane profile averaging method.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/mixing_planes/set/averaging_method").execute(*args, **kwargs)
                def under_relaxation(self, *args, **kwargs):
                    """
                    Sets mixing plane under-relaxation factor.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/mixing_planes/set/under_relaxation").execute(*args, **kwargs)

                class conserve_total_enthalpy(TUIMenu):
                    """
                    Enters the menu to set total enthalpy conservation in mixing plane menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def verbosity(self, *args, **kwargs):
                        """
                        Enables/disables verbosity in total-enthalpy conservation calculations.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/mixing_planes/set/conserve_total_enthalpy/verbosity").execute(*args, **kwargs)
                    def enable(self, *args, **kwargs):
                        """
                        Enables/disables total enthalpy conservation in mixing plane.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/mixing_planes/set/conserve_total_enthalpy/enable").execute(*args, **kwargs)

                class conserve_swirl(TUIMenu):
                    """
                    Enters the menu to set swirl conservation in mixing plane menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def verbosity(self, *args, **kwargs):
                        """
                        Enables/disables verbosity in swirl conservation calculations.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/mixing_planes/set/conserve_swirl/verbosity").execute(*args, **kwargs)
                    def enable(self, *args, **kwargs):
                        """
                        Enables/disables swirl conservation in mixing plane.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/mixing_planes/set/conserve_swirl/enable").execute(*args, **kwargs)
                    def report_swirl_integration(self, *args, **kwargs):
                        """
                        Reports swirl integration (Torque) on inflow and outflow zones.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/define/mixing_planes/set/conserve_swirl/report_swirl_integration").execute(*args, **kwargs)

        class gap_model(TUIMenu):
            """
            Enters the gap model menu, where you can define one or more gap regions where the flow is blocked or decelerated when face zones move within a specified proximity threshold of each other.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.advanced_options = self.__class__.advanced_options(service, version, mode, path + ["advanced_options"])
                super().__init__(service, version, mode, path)
            def edit(self, *args, **kwargs):
                """
                Edits an existing gap region.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/gap_model/edit").execute(*args, **kwargs)
            def create(self, *args, **kwargs):
                """
                Creates a single gap region, so that when selected face zones move within a specified proximity threshold of each other, flow blockage / deceleration is applied to the cells that lie within the threshold.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/gap_model/create").execute(*args, **kwargs)
            def list_gap_regions(self, *args, **kwargs):
                """
                Lists the properties of the gap regions.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/gap_model/list_gap_regions").execute(*args, **kwargs)
            def list_gap_face_zones(self, *args, **kwargs):
                """
                Lists the names of the face zones that can be used for creating gap regions.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/gap_model/list_gap_face_zones").execute(*args, **kwargs)
            def render_gap_regions(self, *args, **kwargs):
                """
                Update gap regions for postprocessing.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/gap_model/render_gap_regions").execute(*args, **kwargs)
            def enable(self, *args, **kwargs):
                """
                Enables/disables the gap model.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/gap_model/enable").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Deletes all of the existing gap regions.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/gap_model/delete_all").execute(*args, **kwargs)
            def list_gap_cell_zones(self, *args, **kwargs):
                """
                Lists the names of the cell zones that can be excluded for individual gap regions (so that such cells are not marked for flow blockage / deceleration).
                """
                return PyMenu(self._service, self._version, self._mode, "/define/gap_model/list_gap_cell_zones").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Deletes an existing gap region.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/gap_model/delete").execute(*args, **kwargs)

            class advanced_options(TUIMenu):
                """
                Enters the advanced options menu for the gap model.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def sponge_layer(self, *args, **kwargs):
                    """
                    Allows you to edit the solution stabilization settings for flow-modeling gap regions 	that have sponge-layer local stabilization 	enabled.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/sponge_layer").execute(*args, **kwargs)
                def fill_data_in_gap_regions(self, *args, **kwargs):
                    """
                    Enables/disables the interpolation of solution data throughout the gap regions. This 	text command is only available if you have enabled the 	define/gap-model/advanced-options/expert? 	text command.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/fill_data_in_gap_regions").execute(*args, **kwargs)
                def solution_stabilization(self, *args, **kwargs):
                    """
                    Sets the global solution stabilization level for the gap 	regions.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/solution_stabilization").execute(*args, **kwargs)
                def precise_gap_marking(self, *args, **kwargs):
                    """
                    Enables/disables the use of a more accurate search algorithm for marking cells in 	gap regions. Note that it can be costly, particularly 	for 3D cases or those with a large number of cells 	inside the gap regions. This text command is only 	available if you have enabled the 	define/gap-model/advanced-options/expert? 	text command.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/precise_gap_marking").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    Sets the verbosity for messages printed in the console 	related to the gap model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/verbosity").execute(*args, **kwargs)
                def check_cfl_condition(self, *args, **kwargs):
                    """
                    Enables/disables the printing of warnings if the time 	step size is too large based on a Courant (CFL) number 	automatically determined for your specified solution 	stability level.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/check_cfl_condition").execute(*args, **kwargs)
                def alternative_marking(self, *args, **kwargs):
                    """
                    Mark gap regions using an alternative marking algorithm.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/alternative_marking").execute(*args, **kwargs)
                def extend_gap_regions(self, *args, **kwargs):
                    """
                    Enables/disables the extending of the gap regions by including additional cells in 	the vicinity of the gap interfaces during marking. This 	is useful when the default shape of the marked cells is 	negatively affecting solution stability or convergence 	behavior.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/extend_gap_regions").execute(*args, **kwargs)
                def include_coupled_walls(self, *args, **kwargs):
                    """
                    Include coupled walls in gap face zones.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/include_coupled_walls").execute(*args, **kwargs)
                def render_gap_interface(self, *args, **kwargs):
                    """
                    Enables/disables the rendering of the mesh surfaces inside the gap regions when 	displaying the mesh with contours. Note that the 	solution is still not rendered inside the flow-blocking 	gap regions.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/render_gap_interface").execute(*args, **kwargs)
                def flow_blocking_stabilization_parameters(self, *args, **kwargs):
                    """
                    Adjust stabilization settings for the sponge layer used for blocked gap regions.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/flow_blocking_stabilization_parameters").execute(*args, **kwargs)
                def enhanced_data_interpolation(self, *args, **kwargs):
                    """
                    Enables/disables the use of enhanced data 	interpolation when updating information in gap regions. 	This text command is only available if you have enabled 	the 	define/gap-model/advanced-options/expert? 	text command.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/enhanced_data_interpolation").execute(*args, **kwargs)
                def expert(self, *args, **kwargs):
                    """
                    Enables/disables access to expert-level text commands 	for the gap model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/expert").execute(*args, **kwargs)
                def update_gap_regions(self, *args, **kwargs):
                    """
                    Update gap regions and gap model solution information.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/update_gap_regions").execute(*args, **kwargs)
                def cell_check_distance_factor(self, *args, **kwargs):
                    """
                    Enter value of the cell distance factor.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/cell_check_distance_factor").execute(*args, **kwargs)
                def reduce_gap_regions(self, *args, **kwargs):
                    """
                    Enables/disables a more restrictive algorithm for marking cells in gap regions. This 	text command is only available if you have enabled the 	define/gap-model/advanced-options/expert? 	text command.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/reduce_gap_regions").execute(*args, **kwargs)
                def revert_controls_to_default(self, *args, **kwargs):
                    """
                    Reverts the global gap stabilization level and any related 	solver settings to the default.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/revert_controls_to_default").execute(*args, **kwargs)
                def render_flow_modeling_gaps(self, *args, **kwargs):
                    """
                    Enables/disables the rendering of the solution in the cells of flow-modeling gap 	regions during postprocessing. This text command is only 	available if you have enabled the 	define/gap-model/advanced-options/expert? 	text command.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/render_flow_modeling_gaps").execute(*args, **kwargs)
                def clear_gap_regions(self, *args, **kwargs):
                    """
                    Clear gap model solution information and marks.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/gap_model/advanced_options/clear_gap_regions").execute(*args, **kwargs)

        class solution_strategy(TUIMenu):
            """
            Enters the automatic initialization and case modification strategy menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.automatic_case_modification = self.__class__.automatic_case_modification(service, version, mode, path + ["automatic_case_modification"])
                super().__init__(service, version, mode, path)
            def delete_modification(self, *args, **kwargs):
                """
                Delete a single case modification.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/solution_strategy/delete_modification").execute(*args, **kwargs)
            def automatic_initialization(self, *args, **kwargs):
                """
                Defines how the case is to be automatically initialized.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/solution_strategy/automatic_initialization").execute(*args, **kwargs)
            def enable_strategy(self, *args, **kwargs):
                """
                Enables/disables automatic initialization and case modification.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/solution_strategy/enable_strategy").execute(*args, **kwargs)
            def execute_strategy(self, *args, **kwargs):
                """
                Executes the currently defined automatic initialization and case modification strategy.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/solution_strategy/execute_strategy").execute(*args, **kwargs)
            def enable_modification(self, *args, **kwargs):
                """
                Enable a single defined case modification.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/solution_strategy/enable_modification").execute(*args, **kwargs)
            def add_edit_modification(self, *args, **kwargs):
                """
                Define a single case modification.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/solution_strategy/add_edit_modification").execute(*args, **kwargs)
            def continue_strategy_execution(self, *args, **kwargs):
                """
                Continues execution of the currently defined automatic initialization and case modification strategy.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/solution_strategy/continue_strategy_execution").execute(*args, **kwargs)
            def export_modifications(self, *args, **kwargs):
                """
                Export all case modifications to a tsv file.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/solution_strategy/export_modifications").execute(*args, **kwargs)
            def import_modifications(self, *args, **kwargs):
                """
                Import a list of case modifications from a tsv file.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/solution_strategy/import_modifications").execute(*args, **kwargs)
            def disable_modification(self, *args, **kwargs):
                """
                Disable a single defined case modification.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/solution_strategy/disable_modification").execute(*args, **kwargs)
            def copy_modification(self, *args, **kwargs):
                """
                Copy a single case modification.
                """
                return PyMenu(self._service, self._version, self._mode, "/define/solution_strategy/copy_modification").execute(*args, **kwargs)

            class automatic_case_modification(TUIMenu):
                """
                Enters the automatic case modification menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def before_init_modification(self, *args, **kwargs):
                    """
                    Specifies modification to be performed before initialization.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/solution_strategy/automatic_case_modification/before_init_modification").execute(*args, **kwargs)
                def modifications(self, *args, **kwargs):
                    """
                    Specifies modifications to be performed during solution.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/solution_strategy/automatic_case_modification/modifications").execute(*args, **kwargs)
                def original_settings(self, *args, **kwargs):
                    """
                    Specifies modification to be performed after initialization to restore to original 	settings.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/define/solution_strategy/automatic_case_modification/original_settings").execute(*args, **kwargs)

    class turbo_post(TUIMenu):
        """
        Enter the turbo menu.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            super().__init__(service, version, mode, path)
        def compute_report(self, *args, **kwargs):
            """
            Computes turbomachinery quantities.
            """
            return PyMenu(self._service, self._version, self._mode, "/turbo_post/compute_report").execute(*args, **kwargs)
        def two_d_contours(self, *args, **kwargs):
            """
            Display 2d contours.
            """
            return PyMenu(self._service, self._version, self._mode, "/turbo_post/two_d_contours").execute(*args, **kwargs)
        def write_report(self, *args, **kwargs):
            """
            Writes the turbo report to file.
            """
            return PyMenu(self._service, self._version, self._mode, "/turbo_post/write_report").execute(*args, **kwargs)
        def avg_contours(self, *args, **kwargs):
            """
            Displays average contours.
            """
            return PyMenu(self._service, self._version, self._mode, "/turbo_post/avg_contours").execute(*args, **kwargs)
        def current_topology(self, *args, **kwargs):
            """
            Sets the current turbo topology for global use.
            """
            return PyMenu(self._service, self._version, self._mode, "/turbo_post/current_topology").execute(*args, **kwargs)
        def xy_plot_avg(self, *args, **kwargs):
            """
            Displays average XY plots.
            """
            return PyMenu(self._service, self._version, self._mode, "/turbo_post/xy_plot_avg").execute(*args, **kwargs)

    class display(TUIMenu):
        """
        Enter the display menu.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
            self.embedded_windows = self.__class__.embedded_windows(service, version, mode, path + ["embedded_windows"])
            self.raytracer = self.__class__.raytracer(service, version, mode, path + ["raytracer"])
            self.path_lines = self.__class__.path_lines(service, version, mode, path + ["path_lines"])
            self.set = self.__class__.set(service, version, mode, path + ["set"])
            self.particle_tracks = self.__class__.particle_tracks(service, version, mode, path + ["particle_tracks"])
            self.define = self.__class__.define(service, version, mode, path + ["define"])
            self.objects = self.__class__.objects(service, version, mode, path + ["objects"])
            self.flamelet_data = self.__class__.flamelet_data(service, version, mode, path + ["flamelet_data"])
            self.update_scene = self.__class__.update_scene(service, version, mode, path + ["update_scene"])
            self.views = self.__class__.views(service, version, mode, path + ["views"])
            self.pdf_data = self.__class__.pdf_data(service, version, mode, path + ["pdf_data"])
            self.view_sync = self.__class__.view_sync(service, version, mode, path + ["view_sync"])
            self.display_states = self.__class__.display_states(service, version, mode, path + ["display_states"])
            super().__init__(service, version, mode, path)
        def grid(self, *args, **kwargs):
            """
            Display the mesh.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/grid").execute(*args, **kwargs)
        def save_picture(self, *args, **kwargs):
            """
            Generate a "hardcopy" of the active window.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/save_picture").execute(*args, **kwargs)
        def mesh_partition_boundary(self, *args, **kwargs):
            """
            Displays mesh partition boundaries.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/mesh_partition_boundary").execute(*args, **kwargs)
        def graphics_window_layout(self, *args, **kwargs):
            """
            Arranges the graphics window layout.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/graphics_window_layout").execute(*args, **kwargs)
        def mesh_outline(self, *args, **kwargs):
            """
            Displays the mesh boundaries.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/mesh_outline").execute(*args, **kwargs)
        def multigrid_coarsening(self, *args, **kwargs):
            """
            Displays a coarse mesh level from the last multigrid coarsening.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/multigrid_coarsening").execute(*args, **kwargs)
        def add_custom_vector(self, *args, **kwargs):
            """
            Adds new custom vector definition.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/add_custom_vector").execute(*args, **kwargs)
        def close_window(self, *args, **kwargs):
            """
            Close a "user" graphics window. User windows are specified by number (1-50), with the associated number corresponding to the order, left-to-right, that the windows were created in.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/close_window").execute(*args, **kwargs)
        def reacting_channel_curves(self, *args, **kwargs):
            """
            Plots the reacting channel variables.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/reacting_channel_curves").execute(*args, **kwargs)
        def vector(self, *args, **kwargs):
            """
            Displays vectors of a space vector variable.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/vector").execute(*args, **kwargs)
        def close_window_by_name(self, *args, **kwargs):
            """
            Close a reserved graphics window (windows used for residuals, report plots, and animation definitions).
            """
            return PyMenu(self._service, self._version, self._mode, "/display/close_window_by_name").execute(*args, **kwargs)
        def surface_cells(self, *args, **kwargs):
            """
            Draws the cells on the specified surfaces. You can include a wildcard (\\*) within the surface names.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/surface_cells").execute(*args, **kwargs)
        def mesh(self, *args, **kwargs):
            """
            Displays the entire mesh. For 3D, you will be asked to confirm that you really want to draw the entire mesh (not just themesh-outline).
            """
            return PyMenu(self._service, self._version, self._mode, "/display/mesh").execute(*args, **kwargs)
        def surface_mesh(self, *args, **kwargs):
            """
            Draws the mesh defined by the specified surfaces. You can include a wildcard (\\*) within the surface names.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/surface_mesh").execute(*args, **kwargs)
        def velocity_vector(self, *args, **kwargs):
            """
            Prompts for a scalar field by which to color the vectors, the minimum and maximum values, and the scale factor, and then draws the velocity vectors.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/velocity_vector").execute(*args, **kwargs)
        def profile(self, *args, **kwargs):
            """
            Displays profiles of a flow variable.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/profile").execute(*args, **kwargs)
        def set_list_tree_separator(self, *args, **kwargs):
            """
            Set the separator character for list tree.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/set_list_tree_separator").execute(*args, **kwargs)
        def clear_annotations(self, *args, **kwargs):
            """
            Removes all annotations and attachment lines from the active graphics window.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/clear_annotations").execute(*args, **kwargs)
        def annotate(self, *args, **kwargs):
            """
            Add a text annotation string to the active graphics window.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/annotate").execute(*args, **kwargs)
        def re_scale(self, *args, **kwargs):
            """
            Re-renders the last contour, profile, or vector plot with updated scale, surfaces, meshes, lights, colormap, rendering options, and so on, but without recalculating the field data.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/re_scale").execute(*args, **kwargs)
        def re_render(self, *args, **kwargs):
            """
            Re-renders the last contour, profile, or vector plot with updated surfaces, meshed, lights, colormap, rendering options, and so on, without recalculating the contour data.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/re_render").execute(*args, **kwargs)
        def set_window_by_name(self, *args, **kwargs):
            """
            Sets the specified graphics window as active. The graphics windows specified using this command are "reserved" windows, that is, residual monitors, report plots, and animation definitions. The name will match the name you provided when creating the object (report plots and animation definitions).
            """
            return PyMenu(self._service, self._version, self._mode, "/display/set_window_by_name").execute(*args, **kwargs)
        def switch_to_post_processing_volume(self, *args, **kwargs):
            """
            Switch to post processing volume.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/switch_to_post_processing_volume").execute(*args, **kwargs)
        def hsf_file(self, *args, **kwargs):
            """
            Loads an HSF file for viewing.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/hsf_file").execute(*args, **kwargs)
        def zone_mesh(self, *args, **kwargs):
            """
            Draws the mesh defined by specified face zones. Zone names can be indicated using wildcards (\\*).
            """
            return PyMenu(self._service, self._version, self._mode, "/display/zone_mesh").execute(*args, **kwargs)
        def contour(self, *args, **kwargs):
            """
            Prompts for a scalar field and minimum and maximum values, and then displays a contour plot.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/contour").execute(*args, **kwargs)
        def open_window(self, *args, **kwargs):
            """
            Opens a graphics window.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/open_window").execute(*args, **kwargs)
        def update_layout(self, *args, **kwargs):
            """
            Update the fluent layout.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/update_layout").execute(*args, **kwargs)
        def transient_post_processing(self, *args, **kwargs):
            """
            Enter transient postprocessing menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/transient_post_processing").execute(*args, **kwargs)
        def set_window(self, *args, **kwargs):
            """
            Sets a "user" graphics window to be the active window. User windows are specified by number (1-50), with the associated number corresponding to the order, left-to-right, that the windows were created in.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/set_window").execute(*args, **kwargs)
        def switch_to_primary_volume(self, *args, **kwargs):
            """
            Switch to primary volume.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/switch_to_primary_volume").execute(*args, **kwargs)
        def grid_outline(self, *args, **kwargs):
            """
            Display the mesh boundaries.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/grid_outline").execute(*args, **kwargs)
        def display_custom_vector(self, *args, **kwargs):
            """
            Displays custom vector.
            """
            return PyMenu(self._service, self._version, self._mode, "/display/display_custom_vector").execute(*args, **kwargs)

        class surface(TUIMenu):
            """
            Enters the data surface-manipulation menu. For a description of the items in this menu, see surface/.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.query = self.__class__.query(service, version, mode, path + ["query"])
                self.post_processing_volume = self.__class__.post_processing_volume(service, version, mode, path + ["post_processing_volume"])
                super().__init__(service, version, mode, path)
            def iso_surface(self, *args, **kwargs):
                """
                Extract an iso-surface (surface, curve, or point) from the curent data field.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/iso_surface").execute(*args, **kwargs)
            def mouse_plane(self, *args, **kwargs):
                """
                Define a plane surface using the mouse to select three points.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/mouse_plane").execute(*args, **kwargs)
            def iso_clip_multiple(self, *args, **kwargs):
                """
                Clip a data surface (surface, curve, or point) between two iso-values.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/iso_clip_multiple").execute(*args, **kwargs)
            def mouse_rake(self, *args, **kwargs):
                """
                Define a "rake" surface using the mouse to select the end points.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/mouse_rake").execute(*args, **kwargs)
            def closest_point_search(self, *args, **kwargs):
                """
                Enable the point surface algorithm to look for the nearest point instead of reporting a creation failure.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/closest_point_search").execute(*args, **kwargs)
            def plane_surface(self, *args, **kwargs):
                """
                Create a plane from a coordinate plane, point and normal, or three points.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/plane_surface").execute(*args, **kwargs)
            def edit_surface(self, *args, **kwargs):
                """
                Edit a defined data surface.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/edit_surface").execute(*args, **kwargs)
            def plane_point_n_normal(self, *args, **kwargs):
                """
                Create a plane from a point and normal.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/plane_point_n_normal").execute(*args, **kwargs)
            def point_array(self, *args, **kwargs):
                """
                Extract a rectangular array of data points.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/point_array").execute(*args, **kwargs)
            def create_imprint_surface(self, *args, **kwargs):
                """
                Imprint surface.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/create_imprint_surface").execute(*args, **kwargs)
            def zone_surface(self, *args, **kwargs):
                """
                Define a data surface on a mesh zone.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/zone_surface").execute(*args, **kwargs)
            def rake_surface(self, *args, **kwargs):
                """
                Define a "rake" surface by specifying the end points.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/rake_surface").execute(*args, **kwargs)
            def transform_surface(self, *args, **kwargs):
                """
                Transform surface.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/transform_surface").execute(*args, **kwargs)
            def rename_surface(self, *args, **kwargs):
                """
                Rename a defined data surface.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/rename_surface").execute(*args, **kwargs)
            def plane_slice(self, *args, **kwargs):
                """
                Extract a planar slice.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/plane_slice").execute(*args, **kwargs)
            def sphere_slice(self, *args, **kwargs):
                """
                Extract a spherical slice.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/sphere_slice").execute(*args, **kwargs)
            def multiple_iso_surfaces(self, *args, **kwargs):
                """
                Create multiple iso-surfaces from the data field at specified spacing.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/multiple_iso_surfaces").execute(*args, **kwargs)
            def partition_surface(self, *args, **kwargs):
                """
                Define a data surface on mesh faces on the partition boundary.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/partition_surface").execute(*args, **kwargs)
            def plane_view_plane_align(self, *args, **kwargs):
                """
                Create a plane aligned to a view-plane.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/plane_view_plane_align").execute(*args, **kwargs)
            def rendering_priority(self, *args, **kwargs):
                """
                Define Priority for given surface
                id.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/rendering_priority").execute(*args, **kwargs)
            def multiple_zone_surfaces(self, *args, **kwargs):
                """
                Create multiple data surfaces at a time.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/multiple_zone_surfaces").execute(*args, **kwargs)
            def quadric_slice(self, *args, **kwargs):
                """
                Extract a quadric slice.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/quadric_slice").execute(*args, **kwargs)
            def list_surfaces(self, *args, **kwargs):
                """
                List the number of facets in the defined surfaces.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/list_surfaces").execute(*args, **kwargs)
            def line_slice(self, *args, **kwargs):
                """
                Extract a linear slice.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/line_slice").execute(*args, **kwargs)
            def ungroup_surface(self, *args, **kwargs):
                """
                Ungroup the surface(if grouped).
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/ungroup_surface").execute(*args, **kwargs)
            def group_surfaces(self, *args, **kwargs):
                """
                Group a set of surfaces.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/group_surfaces").execute(*args, **kwargs)
            def ellipsoid_slice(self, *args, **kwargs):
                """
                Extract a ellipsoid slice.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/ellipsoid_slice").execute(*args, **kwargs)
            def imprint_surface(self, *args, **kwargs):
                """
                Imprint surface.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/imprint_surface").execute(*args, **kwargs)
            def plane_bounded(self, *args, **kwargs):
                """
                Create a bounded surface.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/plane_bounded").execute(*args, **kwargs)
            def iso_clip(self, *args, **kwargs):
                """
                Clip a data surface (surface, curve, or point) between two iso-values.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/iso_clip").execute(*args, **kwargs)
            def surface_cells(self, *args, **kwargs):
                """
                Extract all cells intersected by a data surface.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/surface_cells").execute(*args, **kwargs)
            def mouse_line(self, *args, **kwargs):
                """
                Define a line surface using the mouse to select two points.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/mouse_line").execute(*args, **kwargs)
            def delete_surface(self, *args, **kwargs):
                """
                Remove a defined data surface.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/delete_surface").execute(*args, **kwargs)
            def point_surface(self, *args, **kwargs):
                """
                Define a "point" surface by specifying the coordinates.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/point_surface").execute(*args, **kwargs)
            def multiple_plane_surfaces(self, *args, **kwargs):
                """
                Create multiple plane surfaces at specified spacing.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/multiple_plane_surfaces").execute(*args, **kwargs)
            def structural_point_surface(self, *args, **kwargs):
                """
                Define a "structural point" surface by specifying the coordinates.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/structural_point_surface").execute(*args, **kwargs)
            def plane(self, *args, **kwargs):
                """
                Create a plane given 3 points bounded by the domain.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/plane").execute(*args, **kwargs)
            def expression_volume(self, *args, **kwargs):
                """
                Create volume with boolean expression.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/expression_volume").execute(*args, **kwargs)
            def line_surface(self, *args, **kwargs):
                """
                Define a "line" surface by specifying the two endpoint coordinates.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/line_surface").execute(*args, **kwargs)
            def circle_slice(self, *args, **kwargs):
                """
                Extract a circular slice.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/circle_slice").execute(*args, **kwargs)
            def reset_zone_surfaces(self, *args, **kwargs):
                """
                Reset case surface list.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/reset_zone_surfaces").execute(*args, **kwargs)
            def cone_slice(self, *args, **kwargs):
                """
                Extract a cone slice.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/cone_slice").execute(*args, **kwargs)
            def plane_surf_aligned(self, *args, **kwargs):
                """
                Create a plane aligned to a surface.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/surface/plane_surf_aligned").execute(*args, **kwargs)

            class query(TUIMenu):
                """
                Enter surface query menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def list_queries(self, *args, **kwargs):
                    """
                    List all saved queries.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/surface/query/list_queries").execute(*args, **kwargs)
                def named_surface_list(self, *args, **kwargs):
                    """
                    Create named list of surfaces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/surface/query/named_surface_list").execute(*args, **kwargs)
                def list_named_selection(self, *args, **kwargs):
                    """
                    List named selection of surface type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/surface/query/list_named_selection").execute(*args, **kwargs)
                def delete_query(self, *args, **kwargs):
                    """
                    Delete saved query.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/surface/query/delete_query").execute(*args, **kwargs)
                def list_surfaces(self, *args, **kwargs):
                    """
                    List surfaces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/surface/query/list_surfaces").execute(*args, **kwargs)

            class post_processing_volume(TUIMenu):
                """
                Enter post-processing volume menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def create_octree(self, *args, **kwargs):
                    """
                    Create post-processing octree mesh based on current case.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/surface/post_processing_volume/create_octree").execute(*args, **kwargs)
                def create_from_file(self, *args, **kwargs):
                    """
                    Read post-processing mesh from file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/surface/post_processing_volume/create_from_file").execute(*args, **kwargs)

        class embedded_windows(TUIMenu):
            """
            Enter the embedded window menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def update_dimensions(self, *args, **kwargs):
                """
                Update the embedded windows dimensions.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/embedded_windows/update_dimensions").execute(*args, **kwargs)
            def move_out(self, *args, **kwargs):
                """
                Move an embedded window out of the parent window, returning the embedded window to a non-embedded state.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/embedded_windows/move_out").execute(*args, **kwargs)
            def embed_in(self, *args, **kwargs):
                """
                Specify a window to embed and a parent window to receive the embedded window.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/embedded_windows/embed_in").execute(*args, **kwargs)
            def move_out_all(self, *args, **kwargs):
                """
                Move all the embedded windows out of the specified parent window.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/embedded_windows/move_out_all").execute(*args, **kwargs)
            def close_all(self, *args, **kwargs):
                """
                Close all the embedded windows within the specified parent window.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/embedded_windows/close_all").execute(*args, **kwargs)
            def close(self, *args, **kwargs):
                """
                Close an embedded window.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/embedded_windows/close").execute(*args, **kwargs)

        class raytracer(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.background = self.__class__.background(service, version, mode, path + ["background"])
                self.rendering = self.__class__.rendering(service, version, mode, path + ["rendering"])
                super().__init__(service, version, mode, path)
            def display_live_preview(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/display/raytracer/display_live_preview").execute(*args, **kwargs)

            class background(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def backplate_color(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/raytracer/background/backplate_color").execute(*args, **kwargs)
                def environment_image(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/raytracer/background/environment_image").execute(*args, **kwargs)
                def view_zoom(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/raytracer/background/view_zoom").execute(*args, **kwargs)
                def backplate_image(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/raytracer/background/backplate_image").execute(*args, **kwargs)
                def latitude(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/raytracer/background/latitude").execute(*args, **kwargs)
                def longitude(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/raytracer/background/longitude").execute(*args, **kwargs)
                def hide_environment_keep_effects(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/raytracer/background/hide_environment_keep_effects").execute(*args, **kwargs)
                def show_backplate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/raytracer/background/show_backplate").execute(*args, **kwargs)

            class rendering(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def thread_count(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/raytracer/rendering/thread_count").execute(*args, **kwargs)
                def denoiser(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/raytracer/rendering/denoiser").execute(*args, **kwargs)
                def max_rendering_timeout(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/raytracer/rendering/max_rendering_timeout").execute(*args, **kwargs)
                def quality(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/raytracer/rendering/quality").execute(*args, **kwargs)

        class path_lines(TUIMenu):
            """
            Enters the pathlines menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def plot_write_xy_plot(self, *args, **kwargs):
                """
                Plots or writes an XY plot of pathlines.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/path_lines/plot_write_xy_plot").execute(*args, **kwargs)
            def path_lines(self, *args, **kwargs):
                """
                Displays pathlines from a surface.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/path_lines/path_lines").execute(*args, **kwargs)
            def write_to_files(self, *args, **kwargs):
                """
                Writes pathlines to a file.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/path_lines/write_to_files").execute(*args, **kwargs)

        class set(TUIMenu):
            """
            Enter the set menu to set display parameters.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.colors = self.__class__.colors(service, version, mode, path + ["colors"])
                self.windows = self.__class__.windows(service, version, mode, path + ["windows"])
                self.picture = self.__class__.picture(service, version, mode, path + ["picture"])
                self.particle_tracks = self.__class__.particle_tracks(service, version, mode, path + ["particle_tracks"])
                self.rendering_options = self.__class__.rendering_options(service, version, mode, path + ["rendering_options"])
                self.contours = self.__class__.contours(service, version, mode, path + ["contours"])
                self.path_lines = self.__class__.path_lines(service, version, mode, path + ["path_lines"])
                self.velocity_vectors = self.__class__.velocity_vectors(service, version, mode, path + ["velocity_vectors"])
                self.lights = self.__class__.lights(service, version, mode, path + ["lights"])
                self.titles = self.__class__.titles(service, version, mode, path + ["titles"])
                super().__init__(service, version, mode, path)
            def duplicate_node_display(self, *args, **kwargs):
                """
                Set flag to remove duplicate nodes in mesh display.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/duplicate_node_display").execute(*args, **kwargs)
            def grid_level(self, *args, **kwargs):
                """
                Set coarse mesh level to be drawn.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/grid_level").execute(*args, **kwargs)
            def zero_angle_dir(self, *args, **kwargs):
                """
                Sets the vector having zero angular coordinates.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/zero_angle_dir").execute(*args, **kwargs)
            def color_map(self, *args, **kwargs):
                """
                Enters the color map menu, which contains names of predefined and user-defined (in the Colormap Editor panel) colormaps that can be selected. It prompts you for the name of the colormap to be used.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/color_map").execute(*args, **kwargs)
            def grid_surfaces(self, *args, **kwargs):
                """
                Set surface IDs to be drawn as mesh.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/grid_surfaces").execute(*args, **kwargs)
            def grid_partitions(self, *args, **kwargs):
                """
                Enable/disable drawing of the mesh partition boundaries.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/grid_partitions").execute(*args, **kwargs)
            def proximity_zones(self, *args, **kwargs):
                """
                Sets zones to be used for boundary cell distance and boundary proximity.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/proximity_zones").execute(*args, **kwargs)
            def filled_grid(self, *args, **kwargs):
                """
                Enable/disable the filled mesh option.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/filled_grid").execute(*args, **kwargs)
            def marker_symbol(self, *args, **kwargs):
                """
                Sets the type of markers used to represent points.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/marker_symbol").execute(*args, **kwargs)
            def mesh_display_configuration(self, *args, **kwargs):
                """
                Changes the default mesh display. If set tomeshing, it draws the mesh on edges and faces of the outline surfaces, colored by their zone ID with lighting enabled. If set tosolution, it draws the mesh on edges and faces of the outline surfaces, colored by their zone type with lighting enabled. If set to post-processing, it draws the object outline with lighting disabled. If set toclassic, it draws the mesh on all edges of the outline surfaces.  This only applies for 3D cases.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/mesh_display_configuration").execute(*args, **kwargs)
            def element_shrink(self, *args, **kwargs):
                """
                Sets shrinkage of both faces and cells. A value of zero indicates no shrinkage, while a value of one will shrink each face or cell to a point.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/element_shrink").execute(*args, **kwargs)
            def periodic_repeats(self, *args, **kwargs):
                """
                Sets the number of periodic repetitions.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/periodic_repeats").execute(*args, **kwargs)
            def mesh_level(self, *args, **kwargs):
                """
                Sets coarse mesh level to be drawn.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/mesh_level").execute(*args, **kwargs)
            def grid_zones(self, *args, **kwargs):
                """
                Set zone IDs to be drawn as mesh.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/grid_zones").execute(*args, **kwargs)
            def reset_graphics(self, *args, **kwargs):
                """
                Reset the graphics system.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/reset_graphics").execute(*args, **kwargs)
            def filled_mesh(self, *args, **kwargs):
                """
                Determines whether the meshes are drawn as wireframe or solid.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/filled_mesh").execute(*args, **kwargs)
            def mirror_zones(self, *args, **kwargs):
                """
                Sets the zones about which the domain is mirrored (symmetry planes).
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/mirror_zones").execute(*args, **kwargs)
            def n_stream_func(self, *args, **kwargs):
                """
                Sets number of iterations used in computing stream function.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/n_stream_func").execute(*args, **kwargs)
            def overlays(self, *args, **kwargs):
                """
                Enable/disable overlays.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/overlays").execute(*args, **kwargs)
            def line_weight(self, *args, **kwargs):
                """
                Set the line-weight factor for the window.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/line_weight").execute(*args, **kwargs)
            def periodic_instancing(self, *args, **kwargs):
                """
                Sets the number of periodic repetitions.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/periodic_instancing").execute(*args, **kwargs)
            def mesh_partitions(self, *args, **kwargs):
                """
                Enables/disables option to draw mesh partition boundaries.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/mesh_partitions").execute(*args, **kwargs)
            def mesh_surfaces(self, *args, **kwargs):
                """
                Sets surface IDs to be drawn as meshes. You can include a wildcard  (\\*) within the surface names.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/mesh_surfaces").execute(*args, **kwargs)
            def mesh_zones(self, *args, **kwargs):
                """
                Sets zone IDs to be drawn as meshes.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/mesh_zones").execute(*args, **kwargs)
            def nodewt_based_interp(self, *args, **kwargs):
                """
                Disables/enables the use of node weights for node-based gradients in postprocessing.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/nodewt_based_interp").execute(*args, **kwargs)
            def render_mesh(self, *args, **kwargs):
                """
                Enables/disables rendering the mesh on top of contours, vectors, and so on.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/render_mesh").execute(*args, **kwargs)
            def marker_size(self, *args, **kwargs):
                """
                Sets the size of markers used to represent points.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/set/marker_size").execute(*args, **kwargs)

            class colors(TUIMenu):
                """
                Enter the color options menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.by_type = self.__class__.by_type(service, version, mode, path + ["by_type"])
                    self.by_surface = self.__class__.by_surface(service, version, mode, path + ["by_surface"])
                    super().__init__(service, version, mode, path)
                def axis_faces(self, *args, **kwargs):
                    """
                    Set the color of axisymmetric faces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/axis_faces").execute(*args, **kwargs)
                def inlet_faces(self, *args, **kwargs):
                    """
                    Set the color of inlet faces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/inlet_faces").execute(*args, **kwargs)
                def color_by_type(self, *args, **kwargs):
                    """
                    Determine whether to color meshes by type or by surface (ID).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/color_by_type").execute(*args, **kwargs)
                def free_surface_faces(self, *args, **kwargs):
                    """
                    Set the color of free-surface faces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/free_surface_faces").execute(*args, **kwargs)
                def grid_inlet(self, *args, **kwargs):
                    """
                    Set the color of inlet faces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/grid_inlet").execute(*args, **kwargs)
                def symmetry_faces(self, *args, **kwargs):
                    """
                    Set the color of symmetric faces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/symmetry_faces").execute(*args, **kwargs)
                def traction_faces(self, *args, **kwargs):
                    """
                    Set the color of traction faces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/traction_faces").execute(*args, **kwargs)
                def outlet_faces(self, *args, **kwargs):
                    """
                    Set the color of outlet faces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/outlet_faces").execute(*args, **kwargs)
                def background(self, *args, **kwargs):
                    """
                    Set the background (window) color.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/background").execute(*args, **kwargs)
                def wall_faces(self, *args, **kwargs):
                    """
                    Set the color of wall faces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/wall_faces").execute(*args, **kwargs)
                def interior_faces(self, *args, **kwargs):
                    """
                    Set the color of interior faces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/interior_faces").execute(*args, **kwargs)
                def highlight_color(self, *args, **kwargs):
                    """
                    Set highlight color.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/highlight_color").execute(*args, **kwargs)
                def foreground(self, *args, **kwargs):
                    """
                    Set the foreground (text and window frame) color.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/foreground").execute(*args, **kwargs)
                def periodic_faces(self, *args, **kwargs):
                    """
                    Set the color of periodic faces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/periodic_faces").execute(*args, **kwargs)
                def internal_faces(self, *args, **kwargs):
                    """
                    Set the color of internal interface faces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/internal_faces").execute(*args, **kwargs)
                def rans_les_interface_faces(self, *args, **kwargs):
                    """
                    Set the color of RANS/LES interface faces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/rans_les_interface_faces").execute(*args, **kwargs)
                def surface(self, *args, **kwargs):
                    """
                    Set the color of surfaces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/surface").execute(*args, **kwargs)
                def interface_faces(self, *args, **kwargs):
                    """
                    Set the color of mesh Interfaces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/interface_faces").execute(*args, **kwargs)
                def user_color(self, *args, **kwargs):
                    """
                    Explicitly set color of display zone.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/user_color").execute(*args, **kwargs)
                def show_user_colors(self, *args, **kwargs):
                    """
                    List currently defined user colors.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/show_user_colors").execute(*args, **kwargs)
                def reset_colors(self, *args, **kwargs):
                    """
                    Reset individual mesh surface colors to the defaults.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/reset_colors").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List available colors.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/list").execute(*args, **kwargs)
                def skip_label(self, *args, **kwargs):
                    """
                    Set the number of labels to be skipped in the colopmap scale.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/skip_label").execute(*args, **kwargs)
                def automatic_skip(self, *args, **kwargs):
                    """
                    Determine whether to skip labels in the colopmap scale automatically.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/automatic_skip").execute(*args, **kwargs)
                def reset_user_colors(self, *args, **kwargs):
                    """
                    Reset all user colors.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/reset_user_colors").execute(*args, **kwargs)
                def graphics_color_theme(self, *args, **kwargs):
                    """
                    Enter the graphics color theme menu.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/graphics_color_theme").execute(*args, **kwargs)
                def overset_faces(self, *args, **kwargs):
                    """
                    Set the color of overset faces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/overset_faces").execute(*args, **kwargs)
                def grid_interior(self, *args, **kwargs):
                    """
                    Set the color of interior faces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/grid_interior").execute(*args, **kwargs)
                def far_field_faces(self, *args, **kwargs):
                    """
                    Set the color of far field faces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/colors/far_field_faces").execute(*args, **kwargs)

                class by_type(TUIMenu):
                    """
                    Enter the zone type color and material assignment menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.type_name = self.__class__.type_name(service, version, mode, path + ["type_name"])
                        super().__init__(service, version, mode, path)
                    def reset(self, *args, **kwargs):
                        """
                        To reset colors and/or materials to the defaults.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/reset").execute(*args, **kwargs)
                    def only_list_case_boundaries(self, *args, **kwargs):
                        """
                        Only list the boundary types that are assigned in this case.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/only_list_case_boundaries").execute(*args, **kwargs)
                    def use_inherent_material_color(self, *args, **kwargs):
                        """
                        Use inherent material color for boundary zones.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/use_inherent_material_color").execute(*args, **kwargs)

                    class type_name(TUIMenu):
                        """
                        Select the boundary type to specify colors and/or materials.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def outlet(self, *args, **kwargs):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/type_name/outlet").execute(*args, **kwargs)
                        def traction(self, *args, **kwargs):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/type_name/traction").execute(*args, **kwargs)
                        def periodic(self, *args, **kwargs):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/type_name/periodic").execute(*args, **kwargs)
                        def overset(self, *args, **kwargs):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/type_name/overset").execute(*args, **kwargs)
                        def wall(self, *args, **kwargs):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/type_name/wall").execute(*args, **kwargs)
                        def surface(self, *args, **kwargs):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/type_name/surface").execute(*args, **kwargs)
                        def far_field(self, *args, **kwargs):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/type_name/far_field").execute(*args, **kwargs)
                        def free_surface(self, *args, **kwargs):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/type_name/free_surface").execute(*args, **kwargs)
                        def axis(self, *args, **kwargs):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/type_name/axis").execute(*args, **kwargs)
                        def inlet(self, *args, **kwargs):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/type_name/inlet").execute(*args, **kwargs)
                        def rans_les_interface(self, *args, **kwargs):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/type_name/rans_les_interface").execute(*args, **kwargs)
                        def internal(self, *args, **kwargs):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/type_name/internal").execute(*args, **kwargs)
                        def symmetry(self, *args, **kwargs):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/type_name/symmetry").execute(*args, **kwargs)
                        def interior(self, *args, **kwargs):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/type_name/interior").execute(*args, **kwargs)
                        def interface(self, *args, **kwargs):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_type/type_name/interface").execute(*args, **kwargs)

                class by_surface(TUIMenu):
                    """
                    Enter the surface(s) color and material assignment menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def reset(self, *args, **kwargs):
                        """
                        To reset colors and/or materials to the defaults.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_surface/reset").execute(*args, **kwargs)
                    def list_surfaces_by_color(self, *args, **kwargs):
                        """
                        To list the surfaces by its color.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_surface/list_surfaces_by_color").execute(*args, **kwargs)
                    def list_surfaces_by_material(self, *args, **kwargs):
                        """
                        To list the surfaces by its material.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_surface/list_surfaces_by_material").execute(*args, **kwargs)
                    def use_inherent_material_color(self, *args, **kwargs):
                        """
                        Use inherent material color for surfaces.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_surface/use_inherent_material_color").execute(*args, **kwargs)
                    def surfaces(self, *args, **kwargs):
                        """
                        Select the surface(s) to specify colors and/or materials.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/colors/by_surface/surfaces").execute(*args, **kwargs)

            class windows(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                    self.text = self.__class__.text(service, version, mode, path + ["text"])
                    self.video = self.__class__.video(service, version, mode, path + ["video"])
                    self.main = self.__class__.main(service, version, mode, path + ["main"])
                    self.xy = self.__class__.xy(service, version, mode, path + ["xy"])
                    self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
                    super().__init__(service, version, mode, path)
                def ruler(self, *args, **kwargs):
                    """
                    Turns the ruler on/off. Note that if you are running Fluent in 3D, then the view must be set toorthographic.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/windows/ruler").execute(*args, **kwargs)
                def aspect_ratio(self, *args, **kwargs):
                    """
                    Sets the aspect ratio of the active window.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/windows/aspect_ratio").execute(*args, **kwargs)
                def logo_color(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/windows/logo_color").execute(*args, **kwargs)
                def logo(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/windows/logo").execute(*args, **kwargs)

                class axes(TUIMenu):
                    """
                    Enters the axes window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def bottom(self, *args, **kwargs):
                        """
                        Sets the bottom boundary of the axes window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/axes/bottom").execute(*args, **kwargs)
                    def top(self, *args, **kwargs):
                        """
                        Sets the top boundary of the axes window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/axes/top").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        Sets the right boundary of the axes window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/axes/right").execute(*args, **kwargs)
                    def clear(self, *args, **kwargs):
                        """
                        Sets the transparency of the axes window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/axes/clear").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        Controls the visibility of the axes window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/axes/visible").execute(*args, **kwargs)
                    def border(self, *args, **kwargs):
                        """
                        Sets whether or not to draw a border around the axes window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/axes/border").execute(*args, **kwargs)
                    def left(self, *args, **kwargs):
                        """
                        Sets the left boundary of the axes window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/axes/left").execute(*args, **kwargs)

                class text(TUIMenu):
                    """
                    Enters the text window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def bottom(self, *args, **kwargs):
                        """
                        Sets the bottom boundary of the text window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/text/bottom").execute(*args, **kwargs)
                    def application(self, *args, **kwargs):
                        """
                        Shows or hides the application name in the picture.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/text/application").execute(*args, **kwargs)
                    def clear(self, *args, **kwargs):
                        """
                        Enables/disables the transparency of the text window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/text/clear").execute(*args, **kwargs)
                    def date(self, *args, **kwargs):
                        """
                        Shows or hides the date in the picture.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/text/date").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        Controls the visibility of the text window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/text/visible").execute(*args, **kwargs)
                    def alignment(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/text/alignment").execute(*args, **kwargs)
                    def top(self, *args, **kwargs):
                        """
                        Sets the top boundary of the text window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/text/top").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        Sets the right boundary of the text window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/text/right").execute(*args, **kwargs)
                    def border(self, *args, **kwargs):
                        """
                        Sets whether or not to draw a border around the text window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/text/border").execute(*args, **kwargs)
                    def company(self, *args, **kwargs):
                        """
                        Shows or hides the company name in the picture.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/text/company").execute(*args, **kwargs)
                    def left(self, *args, **kwargs):
                        """
                        Sets the left boundary of the text window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/text/left").execute(*args, **kwargs)

                class video(TUIMenu):
                    """
                    Contains options for modifying a video. This menu is not relevant for the meshing mode.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def foreground(self, *args, **kwargs):
                        """
                        Sets the foreground (text) color of the graphics window. The color is specified as a string of three comma-separated numbers between 0 and 1, representing red, green, and blue. For example, to change the foreground from white (default) to gray, you would enter ".5,.5,.5" after selecting the foreground command.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/video/foreground").execute(*args, **kwargs)
                    def background(self, *args, **kwargs):
                        """
                        Sets the background color of the graphics window. The color is specified as a string of three comma-separated numbers between 0 and 1, representing red, green, and blue. For example, to change the background from black (default) to gray, you would enter ".5,.5,.5" after selecting the background command.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/video/background").execute(*args, **kwargs)
                    def color_filter(self, *args, **kwargs):
                        """
                        Sets the video color filter. For example, to change the color filter from its default setting  to PAL video with a saturation of 80percentage and a brightness of 90percentage, you would  enter "video=pal,sat=.8,gain=.9" after selecting the color-filter command.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/video/color_filter").execute(*args, **kwargs)
                    def on(self, *args, **kwargs):
                        """
                        Enables or disables the video picture settings.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/video/on").execute(*args, **kwargs)
                    def pixel_size(self, *args, **kwargs):
                        """
                        Sets the window size in pixels.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/video/pixel_size").execute(*args, **kwargs)

                class main(TUIMenu):
                    """
                    Enters the main view window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def border(self, *args, **kwargs):
                        """
                        Sets whether or not to draw a border around the main viewing window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/main/border").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        Controls the visibility of the main viewing window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/main/visible").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        Sets the right boundary of the main viewing window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/main/right").execute(*args, **kwargs)
                    def top(self, *args, **kwargs):
                        """
                        Sets the top boundary of the main viewing window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/main/top").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        Sets the bottom boundary of the main viewing window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/main/bottom").execute(*args, **kwargs)
                    def left(self, *args, **kwargs):
                        """
                        Sets the left boundary of the main viewing window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/main/left").execute(*args, **kwargs)

                class xy(TUIMenu):
                    """
                    Enters the XY plot window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def top(self, *args, **kwargs):
                        """
                        Sets the top boundary of the XY plot window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/xy/top").execute(*args, **kwargs)
                    def border(self, *args, **kwargs):
                        """
                        Sets whether or not to draw a border around the XY plot window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/xy/border").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        Sets the bottom boundary of the XY plot window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/xy/bottom").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        Sets the right boundary of the XY plot window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/xy/right").execute(*args, **kwargs)
                    def left(self, *args, **kwargs):
                        """
                        Sets the left boundary of the XY plot window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/xy/left").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        Controls the visibility of the XY plot window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/xy/visible").execute(*args, **kwargs)

                class scale(TUIMenu):
                    """
                    Enters the color scale window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def top(self, *args, **kwargs):
                        """
                        Sets the top boundary of the color scale window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/scale/top").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        Sets the bottom boundary of the color scale window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/scale/bottom").execute(*args, **kwargs)
                    def margin(self, *args, **kwargs):
                        """
                        Sets the margin of the color scale window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/scale/margin").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        Controls the visibility of the color scale window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/scale/visible").execute(*args, **kwargs)
                    def font_size(self, *args, **kwargs):
                        """
                        Sets the font size of the color scale window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/scale/font_size").execute(*args, **kwargs)
                    def clear(self, *args, **kwargs):
                        """
                        Sets the transparency of the color scale window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/scale/clear").execute(*args, **kwargs)
                    def left(self, *args, **kwargs):
                        """
                        Sets the left boundary of the color scale window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/scale/left").execute(*args, **kwargs)
                    def border(self, *args, **kwargs):
                        """
                        Sets whether or not to draw a border around the color scale window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/scale/border").execute(*args, **kwargs)
                    def format(self, *args, **kwargs):
                        """
                        Sets the number format of the color scale window (for example, percentage0.2e).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/scale/format").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        Sets the right boundary of the color scale window.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/windows/scale/right").execute(*args, **kwargs)

            class picture(TUIMenu):
                """
                Enter the hardcopy/save-picture options menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.driver = self.__class__.driver(service, version, mode, path + ["driver"])
                    self.color_mode = self.__class__.color_mode(service, version, mode, path + ["color_mode"])
                    super().__init__(service, version, mode, path)
                def set_standard_resolution(self, *args, **kwargs):
                    """
                    Select from pre-defined resolution list.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/picture/set_standard_resolution").execute(*args, **kwargs)
                def dpi(self, *args, **kwargs):
                    """
                    Set the DPI for EPS and Postscript files, specifies the resolution in dots per inch (DPI) instead of setting the width and height.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/picture/dpi").execute(*args, **kwargs)
                def x_resolution(self, *args, **kwargs):
                    """
                    Set the width of raster-formatted images in pixels (0 implies current window size).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/picture/x_resolution").execute(*args, **kwargs)
                def preview(self, *args, **kwargs):
                    """
                    Display a preview image of a hardcopy.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/picture/preview").execute(*args, **kwargs)
                def raytracer_image(self, *args, **kwargs):
                    """
                    Enable raytracering rendering.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/picture/raytracer_image").execute(*args, **kwargs)
                def jpeg_hardcopy_quality(self, *args, **kwargs):
                    """
                    To set jpeg hardcopy quality.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/picture/jpeg_hardcopy_quality").execute(*args, **kwargs)
                def y_resolution(self, *args, **kwargs):
                    """
                    Set the height of raster-formatted images in pixels (0 implies current window size).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/picture/y_resolution").execute(*args, **kwargs)
                def invert_background(self, *args, **kwargs):
                    """
                    Use a white background when the picture is saved.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/picture/invert_background").execute(*args, **kwargs)
                def landscape(self, *args, **kwargs):
                    """
                    Plot hardcopies in landscape or portrait orientation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/picture/landscape").execute(*args, **kwargs)
                def use_window_resolution(self, *args, **kwargs):
                    """
                    Use the currently active window's resolution for hardcopy (ignores the x-resolution and y-resolution in this case).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/picture/use_window_resolution").execute(*args, **kwargs)

                class driver(TUIMenu):
                    """
                    Enter the set hardcopy driver menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.post_format = self.__class__.post_format(service, version, mode, path + ["post_format"])
                        super().__init__(service, version, mode, path)
                    def glb(self, *args, **kwargs):
                        """
                        Use GLB output for hardcopies.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/glb").execute(*args, **kwargs)
                    def ppm(self, *args, **kwargs):
                        """
                        Produce PPM output for hardcopies.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/ppm").execute(*args, **kwargs)
                    def hsf(self, *args, **kwargs):
                        """
                        Use HSF output for hardcopies.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/hsf").execute(*args, **kwargs)
                    def eps(self, *args, **kwargs):
                        """
                        Produce encapsulated PostScript (EPS) output for hardcopies.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/eps").execute(*args, **kwargs)
                    def post_script(self, *args, **kwargs):
                        """
                        Produce PostScript output for hardcopies.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/post_script").execute(*args, **kwargs)
                    def png(self, *args, **kwargs):
                        """
                        Use PNG output for hardcopies.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/png").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        List the current hardcopy driver.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/list").execute(*args, **kwargs)
                    def dump_window(self, *args, **kwargs):
                        """
                        Set the command used to dump the graphics window to a file.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/dump_window").execute(*args, **kwargs)
                    def options(self, *args, **kwargs):
                        """
                        Set the hardcopy options. Available options are:
                        "no gamma correction", disables gamma correction of colors,
                        "physical size = (width,height)", where width and height
                        are the actual measurements of the printable area of the page
                        in centimeters.
                        "subscreen = (left,right,bottom,top)", where left,right,
                        bottom, and top are numbers in [-1,1] describing a subwindow on
                        the page in which to place the hardcopy.
                        The options may be combined by separating them with commas.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/options").execute(*args, **kwargs)
                    def tiff(self, *args, **kwargs):
                        """
                        Use TIFF output for hardcopies.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/tiff").execute(*args, **kwargs)
                    def vrml(self, *args, **kwargs):
                        """
                        Use VRML output for hardcopies.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/vrml").execute(*args, **kwargs)
                    def avz(self, *args, **kwargs):
                        """
                        Use AVZ output for hardcopies.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/avz").execute(*args, **kwargs)
                    def jpeg(self, *args, **kwargs):
                        """
                        Produce JPEG output for hardcopies.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/jpeg").execute(*args, **kwargs)

                    class post_format(TUIMenu):
                        """
                        Enter the PostScript driver format menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def fast_raster(self, *args, **kwargs):
                            """
                            Use the new raster format.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/post_format/fast_raster").execute(*args, **kwargs)
                        def rle_raster(self, *args, **kwargs):
                            """
                            Use the run-length encoded raster format.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/post_format/rle_raster").execute(*args, **kwargs)
                        def raster(self, *args, **kwargs):
                            """
                            Use the original raster format.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/post_format/raster").execute(*args, **kwargs)
                        def vector(self, *args, **kwargs):
                            """
                            Use vector format.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/display/set/picture/driver/post_format/vector").execute(*args, **kwargs)

                class color_mode(TUIMenu):
                    """
                    Enter the hardcopy color mode menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def list(self, *args, **kwargs):
                        """
                        Display the current hardcopy color mode.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/color_mode/list").execute(*args, **kwargs)
                    def gray_scale(self, *args, **kwargs):
                        """
                        Convert color to grayscale for hardcopy.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/color_mode/gray_scale").execute(*args, **kwargs)
                    def color(self, *args, **kwargs):
                        """
                        Plot hardcopies in color.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/color_mode/color").execute(*args, **kwargs)
                    def mono_chrome(self, *args, **kwargs):
                        """
                        Convert color to monochrome (black and white) for hardcopy.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/picture/color_mode/mono_chrome").execute(*args, **kwargs)

            class particle_tracks(TUIMenu):
                """
                Enters the particle-tracks menu to set parameters for display of particle tracks.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.vector_settings = self.__class__.vector_settings(service, version, mode, path + ["vector_settings"])
                    self.filter_settings = self.__class__.filter_settings(service, version, mode, path + ["filter_settings"])
                    self.sphere_settings = self.__class__.sphere_settings(service, version, mode, path + ["sphere_settings"])
                    super().__init__(service, version, mode, path)
                def line_width(self, *args, **kwargs):
                    """
                    Sets the width for particle track.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/line_width").execute(*args, **kwargs)
                def report_variables(self, *args, **kwargs):
                    """
                    Sets the report variables.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/report_variables").execute(*args, **kwargs)
                def marker_size(self, *args, **kwargs):
                    """
                    Sets the size of markers used to represent particle tracks.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/marker_size").execute(*args, **kwargs)
                def report_to(self, *args, **kwargs):
                    """
                    Specifies the destination for the report (console, file, none).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/report_to").execute(*args, **kwargs)
                def arrow_space(self, *args, **kwargs):
                    """
                    Sets the spacing factor for arrows drawn on particle tracks.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/arrow_space").execute(*args, **kwargs)
                def display(self, *args, **kwargs):
                    """
                    Determines whether particle tracks shall be displayed or only tracked.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/display").execute(*args, **kwargs)
                def report_type(self, *args, **kwargs):
                    """
                    Sets the report type for particle tracks.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/report_type").execute(*args, **kwargs)
                def twist_factor(self, *args, **kwargs):
                    """
                    Sets the scale factor for twisting (ribbons only).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/twist_factor").execute(*args, **kwargs)
                def sphere_attrib(self, *args, **kwargs):
                    """
                    Specifies the size and number of slices to be used in drawing spheres.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/sphere_attrib").execute(*args, **kwargs)
                def style(self, *args, **kwargs):
                    """
                    Sets the display style for particle track (line/ribbon/cylinder/sphere).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/style").execute(*args, **kwargs)
                def radius(self, *args, **kwargs):
                    """
                    Sets the radius for particle track (ribbon/cylinder only) cross-section.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/radius").execute(*args, **kwargs)
                def particle_skip(self, *args, **kwargs):
                    """
                    Specifies how many particle tracks should be displayed.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/particle_skip").execute(*args, **kwargs)
                def track_single_particle_stream(self, *args, **kwargs):
                    """
                    Specifies the stream ID to be tracked.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/track_single_particle_stream").execute(*args, **kwargs)
                def arrow_scale(self, *args, **kwargs):
                    """
                    Sets the scale factor for arrows drawn on particle tracks.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/arrow_scale").execute(*args, **kwargs)
                def coarsen_factor(self, *args, **kwargs):
                    """
                    Sets the coarsening factor for particle tracks.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/coarsen_factor").execute(*args, **kwargs)
                def history_filename(self, *args, **kwargs):
                    """
                    Specifies the name of the particle history file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/history_filename").execute(*args, **kwargs)
                def report_default_variables(self, *args, **kwargs):
                    """
                    Sets the report variables to default.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/report_default_variables").execute(*args, **kwargs)

                class vector_settings(TUIMenu):
                    """
                    Set vector specific input.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def scale_factor(self, *args, **kwargs):
                        """
                        Specifies a scale factor to enlarge/reduce the length of vectors.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/vector_settings/scale_factor").execute(*args, **kwargs)
                    def style(self, *args, **kwargs):
                        """
                        Enables and sets the display style for particle vectors (none/vector/centered-vector/centered-cylinder).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/vector_settings/style").execute(*args, **kwargs)
                    def vector_length(self, *args, **kwargs):
                        """
                        Specifies the length of constant vectors.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/vector_settings/vector_length").execute(*args, **kwargs)
                    def length_variable(self, *args, **kwargs):
                        """
                        Specifies whether the displayed vectors have length varying with another variable.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/vector_settings/length_variable").execute(*args, **kwargs)
                    def color_variable(self, *args, **kwargs):
                        """
                        Specifies whether the vectors should be colored by variable specified in /display/particle-track/particle-track (if false use a constant color).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/vector_settings/color_variable").execute(*args, **kwargs)
                    def length_to_head_ratio(self, *args, **kwargs):
                        """
                        Specifies ratio of length to head for vectors and length to diameter for cylinders.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/vector_settings/length_to_head_ratio").execute(*args, **kwargs)
                    def vector_variable(self, *args, **kwargs):
                        """
                        Selects a particle vector function to specify vector direction.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/vector_settings/vector_variable").execute(*args, **kwargs)
                    def vector_length_variable(self, *args, **kwargs):
                        """
                        Selects a particle variable to specify the length of vectors.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/vector_settings/vector_length_variable").execute(*args, **kwargs)
                    def constant_color(self, *args, **kwargs):
                        """
                        Specifies a constant color for the vectors.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/vector_settings/constant_color").execute(*args, **kwargs)

                class filter_settings(TUIMenu):
                    """
                    Set filter for particle display.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def minimum(self, *args, **kwargs):
                        """
                        Specifies the lower bound for the filter variable.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/filter_settings/minimum").execute(*args, **kwargs)
                    def filter_variable(self, *args, **kwargs):
                        """
                        Selects a variable used for filtering of particles.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/filter_settings/filter_variable").execute(*args, **kwargs)
                    def inside(self, *args, **kwargs):
                        """
                        Specifies whether filter variable must be inside min/max to be displayed (else outside min/max).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/filter_settings/inside").execute(*args, **kwargs)
                    def maximum(self, *args, **kwargs):
                        """
                        Specifies the upper bound for the filter variable.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/filter_settings/maximum").execute(*args, **kwargs)
                    def enable_filtering(self, *args, **kwargs):
                        """
                        Specifies whether particle display is filtered.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/filter_settings/enable_filtering").execute(*args, **kwargs)

                class sphere_settings(TUIMenu):
                    """
                    Provide sphere specific input.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def maximum(self, *args, **kwargs):
                        """
                        Sets the maximum value of the sphere to be displayed.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/sphere_settings/maximum").execute(*args, **kwargs)
                    def diameter(self, *args, **kwargs):
                        """
                        Diameter of the spheres whenvary-diameter is disabled.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/sphere_settings/diameter").execute(*args, **kwargs)
                    def minimum(self, *args, **kwargs):
                        """
                        Sets the minimum value of the sphere to be displayed.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/sphere_settings/minimum").execute(*args, **kwargs)
                    def scale_factor(self, *args, **kwargs):
                        """
                        Specifies a scale factor to enlarge/reduce the size of spheres.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/sphere_settings/scale_factor").execute(*args, **kwargs)
                    def vary_diameter(self, *args, **kwargs):
                        """
                        Specifies whether the spheres can vary with another variable.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/sphere_settings/vary_diameter").execute(*args, **kwargs)
                    def auto_range(self, *args, **kwargs):
                        """
                        Specifies whether displayed spheres should include auto range of variable to size spheres.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/sphere_settings/auto_range").execute(*args, **kwargs)
                    def size_variable(self, *args, **kwargs):
                        """
                        Selects a particle variable to size the spheres.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/sphere_settings/size_variable").execute(*args, **kwargs)
                    def smooth_parameter(self, *args, **kwargs):
                        """
                        Specifies number of slices to be used in drawing spheres.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/display/set/particle_tracks/sphere_settings/smooth_parameter").execute(*args, **kwargs)

            class rendering_options(TUIMenu):
                """
                Enter the rendering options menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def device_info(self, *args, **kwargs):
                    """
                    List information for the graphics device.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/rendering_options/device_info").execute(*args, **kwargs)
                def hidden_surface_method(self, *args, **kwargs):
                    """
                    Specify the method to perform hidden line and hidden surface rendering.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/rendering_options/hidden_surface_method").execute(*args, **kwargs)
                def surface_edge_visibility(self, *args, **kwargs):
                    """
                    Set edge visibility flags for surfaces.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/rendering_options/surface_edge_visibility").execute(*args, **kwargs)
                def show_colormap(self, *args, **kwargs):
                    """
                    Enable/Disable colormap.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/rendering_options/show_colormap").execute(*args, **kwargs)
                def driver(self, *args, **kwargs):
                    """
                    Change the current graphics driver.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/rendering_options/driver").execute(*args, **kwargs)
                def color_map_alignment(self, *args, **kwargs):
                    """
                    Set the color bar alignment.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/rendering_options/color_map_alignment").execute(*args, **kwargs)
                def outer_face_cull(self, *args, **kwargs):
                    """
                    Enable/disable discarding outer faces during display.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/rendering_options/outer_face_cull").execute(*args, **kwargs)
                def hidden_lines(self, *args, **kwargs):
                    """
                    Enable/disable hidden line removal.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/rendering_options/hidden_lines").execute(*args, **kwargs)
                def animation_option(self, *args, **kwargs):
                    """
                    Using Wireframe / All option during animation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/rendering_options/animation_option").execute(*args, **kwargs)
                def hidden_surfaces(self, *args, **kwargs):
                    """
                    Enable/disable hidden surface removal.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/rendering_options/hidden_surfaces").execute(*args, **kwargs)
                def hidden_line_method(self, *args, **kwargs):
                    """
                    Specify the method to perform hidden line rendering.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/rendering_options/hidden_line_method").execute(*args, **kwargs)
                def help_text_color(self, *args, **kwargs):
                    """
                    Set the color of screen help text.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/rendering_options/help_text_color").execute(*args, **kwargs)
                def set_rendering_options(self, *args, **kwargs):
                    """
                    Set the rendering options.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/rendering_options/set_rendering_options").execute(*args, **kwargs)
                def auto_spin(self, *args, **kwargs):
                    """
                    Enable/disable mouse view rotations to continue to spin the display after the button is released.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/rendering_options/auto_spin").execute(*args, **kwargs)
                def face_displacement(self, *args, **kwargs):
                    """
                    Set face displacement value in Z-buffer units along the Camera Z-axis.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/rendering_options/face_displacement").execute(*args, **kwargs)
                def double_buffering(self, *args, **kwargs):
                    """
                    Enable/disable double-buffering.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/rendering_options/double_buffering").execute(*args, **kwargs)

            class contours(TUIMenu):
                """
                Enters the contour options menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def line_contours(self, *args, **kwargs):
                    """
                    Turns the line contours option on/off (deselects filled-contours?).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/contours/line_contours").execute(*args, **kwargs)
                def global_range(self, *args, **kwargs):
                    """
                    Turns the global range for contours on/off.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/contours/global_range").execute(*args, **kwargs)
                def clip_to_range(self, *args, **kwargs):
                    """
                    Turns the clip to range option for filled contours on/off.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/contours/clip_to_range").execute(*args, **kwargs)
                def n_contour(self, *args, **kwargs):
                    """
                    Sets the number of contour levels.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/contours/n_contour").execute(*args, **kwargs)
                def node_values(self, *args, **kwargs):
                    """
                    Sets the option to use scalar field at nodes when computing the contours.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/contours/node_values").execute(*args, **kwargs)
                def auto_range(self, *args, **kwargs):
                    """
                    Enables/disables auto-computation of the contour range.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/contours/auto_range").execute(*args, **kwargs)
                def filled_contours(self, *args, **kwargs):
                    """
                    Turns the filled contours option on/off (deselects line-contours?).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/contours/filled_contours").execute(*args, **kwargs)
                def render_mesh(self, *args, **kwargs):
                    """
                    Determines whether or not to render the mesh on top of contours, vectors, and so on.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/contours/render_mesh").execute(*args, **kwargs)
                def coloring(self, *args, **kwargs):
                    """
                    Specifies whether contours are displayed in bands or with smooth transitions. Note that you can only display smooth contours if node-values are enabled.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/contours/coloring").execute(*args, **kwargs)
                def log_scale(self, *args, **kwargs):
                    """
                    Specifies a decimal or logarithmic color scale for contours.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/contours/log_scale").execute(*args, **kwargs)
                def surfaces(self, *args, **kwargs):
                    """
                    Sets the surfaces on which contours are drawn. You can include a wildcard (\\*) within the surface names.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/contours/surfaces").execute(*args, **kwargs)

            class path_lines(TUIMenu):
                """
                Sets parameters for display of pathlines.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def maximum_error(self, *args, **kwargs):
                    """
                    Sets the maximum error allowed while computing the pathlines.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/path_lines/maximum_error").execute(*args, **kwargs)
                def display_steps(self, *args, **kwargs):
                    """
                    Sets the display stepping for pathlines.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/path_lines/display_steps").execute(*args, **kwargs)
                def maximum_steps(self, *args, **kwargs):
                    """
                    Sets the maximum number of steps to take for pathlines.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/path_lines/maximum_steps").execute(*args, **kwargs)
                def arrow_space(self, *args, **kwargs):
                    """
                    Sets the spacing factor for arrows drawn on pathlines.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/path_lines/arrow_space").execute(*args, **kwargs)
                def relative_pathlines(self, *args, **kwargs):
                    """
                    Enables/disables the tracking of pathlines in a relative coordinate system.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/path_lines/relative_pathlines").execute(*args, **kwargs)
                def reverse(self, *args, **kwargs):
                    """
                    Sets direction of path tracking.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/path_lines/reverse").execute(*args, **kwargs)
                def marker_size(self, *args, **kwargs):
                    """
                    Sets the marker size for particle drawing.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/path_lines/marker_size").execute(*args, **kwargs)
                def error_control(self, *args, **kwargs):
                    """
                    Sets error control during pathline computation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/path_lines/error_control").execute(*args, **kwargs)
                def style(self, *args, **kwargs):
                    """
                    Selects the pathline style (line, point, ribbon, triangle, cylinder).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/path_lines/style").execute(*args, **kwargs)
                def track_in_phase(self, *args, **kwargs):
                    """
                    Selects the phase in which particle pathlines will be computed (Multiphase Eulerian Model only).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/path_lines/track_in_phase").execute(*args, **kwargs)
                def sphere_attrib(self, *args, **kwargs):
                    """
                    Specifies the size and number of slices to be used in drawing spheres.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/path_lines/sphere_attrib").execute(*args, **kwargs)
                def arrow_scale(self, *args, **kwargs):
                    """
                    Sets the scale factor for arrows drawn on pathlines.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/path_lines/arrow_scale").execute(*args, **kwargs)
                def step_size(self, *args, **kwargs):
                    """
                    Sets the step length between particle positions for pathlines.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/path_lines/step_size").execute(*args, **kwargs)
                def line_width(self, *args, **kwargs):
                    """
                    Sets the width for pathlines.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/path_lines/line_width").execute(*args, **kwargs)
                def twist_factor(self, *args, **kwargs):
                    """
                    Sets the scale factor for twisting (ribbons only).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/path_lines/twist_factor").execute(*args, **kwargs)
                def radius(self, *args, **kwargs):
                    """
                    Sets the radius for pathline (ribbons/cylinder only) cross-section.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/path_lines/radius").execute(*args, **kwargs)

            class velocity_vectors(TUIMenu):
                """
                Enters the menu to set parameters for display of velocity vectors.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def node_values(self, *args, **kwargs):
                    """
                    Enables/disables the plotting of node values. Cell values will be plotted if "no".
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/node_values").execute(*args, **kwargs)
                def component_y(self, *args, **kwargs):
                    """
                    Sets the option to use only the  component of the velocity vectors during display.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/component_y").execute(*args, **kwargs)
                def render_mesh(self, *args, **kwargs):
                    """
                    Enables/disables rendering the mesh on top of contours, vectors, and so on.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/render_mesh").execute(*args, **kwargs)
                def relative(self, *args, **kwargs):
                    """
                    Toggles the display of relative velocity vectors.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/relative").execute(*args, **kwargs)
                def scale_head(self, *args, **kwargs):
                    """
                    Sets the value by which the vector head will be scaled.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/scale_head").execute(*args, **kwargs)
                def color(self, *args, **kwargs):
                    """
                    Sets the color of all velocity vectors to the color specified. The color scale is ignored. This is useful when overlaying a vector plot over a contour plot.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/color").execute(*args, **kwargs)
                def scale(self, *args, **kwargs):
                    """
                    Sets the value by which the vector length will be scaled.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/scale").execute(*args, **kwargs)
                def color_levels(self, *args, **kwargs):
                    """
                    Sets the number of colors used from the colormap.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/color_levels").execute(*args, **kwargs)
                def style(self, *args, **kwargs):
                    """
                    Specifies the vector style that will be used when the vectors are displayed. You can choose from:3d arrow,3d arrowhead, cone,filled-arrow, arrow,harpoon, or headless.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/style").execute(*args, **kwargs)
                def auto_scale(self, *args, **kwargs):
                    """
                    Auto-scales all vectors so that vector overlap is minimal.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/auto_scale").execute(*args, **kwargs)
                def component_x(self, *args, **kwargs):
                    """
                    Sets the option to use only the  component of the velocity vectors during display.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/component_x").execute(*args, **kwargs)
                def constant_length(self, *args, **kwargs):
                    """
                    Sets the option to draw velocity vectors of constant length. This shows only the direction of the velocity vectors.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/constant_length").execute(*args, **kwargs)
                def global_range(self, *args, **kwargs):
                    """
                    Turns global range for vectors on/off.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/global_range").execute(*args, **kwargs)
                def log_scale(self, *args, **kwargs):
                    """
                    Toggles whether color scale is logarithmic or linear.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/log_scale").execute(*args, **kwargs)
                def component_z(self, *args, **kwargs):
                    """
                    Sets the option to use only the  component of the velocity vectors during display.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/component_z").execute(*args, **kwargs)
                def in_plane(self, *args, **kwargs):
                    """
                    Toggles the display of velocity vector components in the plane of the surface selected for display.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/in_plane").execute(*args, **kwargs)
                def surfaces(self, *args, **kwargs):
                    """
                    Sets surfaces on which vectors are drawn. You can include a wildcard (\\*) within the surface names.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/velocity_vectors/surfaces").execute(*args, **kwargs)

            class lights(TUIMenu):
                """
                Enter the lights menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def set_light(self, *args, **kwargs):
                    """
                    Add or modify a directional, colored light.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/lights/set_light").execute(*args, **kwargs)
                def lights_on(self, *args, **kwargs):
                    """
                    Turn all active lighting on/off.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/lights/lights_on").execute(*args, **kwargs)
                def lighting_interpolation(self, *args, **kwargs):
                    """
                    Set lighting interpolation method.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/lights/lighting_interpolation").execute(*args, **kwargs)
                def set_ambient_color(self, *args, **kwargs):
                    """
                    Set the ambient light color for the scene.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/lights/set_ambient_color").execute(*args, **kwargs)
                def headlight_on(self, *args, **kwargs):
                    """
                    Turn the light that moves with the camera on or off.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/lights/headlight_on").execute(*args, **kwargs)

            class titles(TUIMenu):
                """
                Set problem title.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def right_bottom(self, *args, **kwargs):
                    """
                    Set the title text for right bottom in title segment.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/titles/right_bottom").execute(*args, **kwargs)
                def left_bottom(self, *args, **kwargs):
                    """
                    Set the title text for left bottom in title segment.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/titles/left_bottom").execute(*args, **kwargs)
                def right_top(self, *args, **kwargs):
                    """
                    Set the title text for right top in title segment.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/titles/right_top").execute(*args, **kwargs)
                def left_top(self, *args, **kwargs):
                    """
                    Set the title text for left top in title segment.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/titles/left_top").execute(*args, **kwargs)
                def right_middle(self, *args, **kwargs):
                    """
                    Set the title text for right middle in title segment.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/set/titles/right_middle").execute(*args, **kwargs)

        class particle_tracks(TUIMenu):
            """
            Enters the particle tracks menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def plot_write_xy_plot(self, *args, **kwargs):
                """
                Plots or writes an XY plot of particle tracks.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/particle_tracks/plot_write_xy_plot").execute(*args, **kwargs)
            def particle_tracks(self, *args, **kwargs):
                """
                Calculates and displays particle tracks from defined injections.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/particle_tracks/particle_tracks").execute(*args, **kwargs)

        class define(TUIMenu):
            """
            Enter Display define menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.material = self.__class__.material(service, version, mode, path + ["material"])
                super().__init__(service, version, mode, path)

            class material(TUIMenu):
                """
                Add, Edit, Remove materials in case file.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def edit(self, *args, **kwargs):
                    """
                    Edit material.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/define/material/edit").execute(*args, **kwargs)
                def new(self, *args, **kwargs):
                    """
                    Create new material.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/define/material/new").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Remove  material.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/define/material/delete").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    Copy to new material.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/define/material/copy").execute(*args, **kwargs)

        class objects(TUIMenu):
            """
            Enter to add, edit, delete or display graphics objects.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def copy(self, *args, **kwargs):
                """
                Copy graphics object.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/objects/copy").execute(*args, **kwargs)
            def create(self, *args, **kwargs):
                """
                Create new graphics object.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/objects/create").execute(*args, **kwargs)
            def add_to_graphics(self, *args, **kwargs):
                """
                Add graphics object to existing graphics.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/objects/add_to_graphics").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit graphics object.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/objects/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete graphics object.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/objects/delete").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Display graphics object.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/objects/display").execute(*args, **kwargs)

        class flamelet_data(TUIMenu):
            """
            Displays flamelet data.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def draw_number_box(self, *args, **kwargs):
                """
                Enables/disables display of the numbers box.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/flamelet_data/draw_number_box").execute(*args, **kwargs)
            def carpet_plot(self, *args, **kwargs):
                """
                Enables/disables display of carpet plot of a property.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/flamelet_data/carpet_plot").execute(*args, **kwargs)
            def write_to_file(self, *args, **kwargs):
                """
                Enables/disables writing the 1D-slice to file instead of plot.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/flamelet_data/write_to_file").execute(*args, **kwargs)
            def plot_1d_slice(self, *args, **kwargs):
                """
                Enables/disables plot of the 1D-slice.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/flamelet_data/plot_1d_slice").execute(*args, **kwargs)

        class update_scene(TUIMenu):
            """
            Enter the scene options menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def iso_sweep(self, *args, **kwargs):
                """
                Change iso-sweep values.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/update_scene/iso_sweep").execute(*args, **kwargs)
            def transform(self, *args, **kwargs):
                """
                Apply transformation matrix on selected geometries.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/update_scene/transform").execute(*args, **kwargs)
            def set_frame(self, *args, **kwargs):
                """
                Change frame options.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/update_scene/set_frame").execute(*args, **kwargs)
            def select_geometry(self, *args, **kwargs):
                """
                Select geometry to be updated.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/update_scene/select_geometry").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Display selected geometries.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/update_scene/display").execute(*args, **kwargs)
            def draw_frame(self, *args, **kwargs):
                """
                Enable/disable drawing of the bounding frame.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/update_scene/draw_frame").execute(*args, **kwargs)
            def overlays(self, *args, **kwargs):
                """
                Enable/disable the overlays option.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/update_scene/overlays").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete selected geometries.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/update_scene/delete").execute(*args, **kwargs)
            def pathline(self, *args, **kwargs):
                """
                Change pathline attributes.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/update_scene/pathline").execute(*args, **kwargs)
            def time(self, *args, **kwargs):
                """
                Change time-step value.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/update_scene/time").execute(*args, **kwargs)

        class views(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.display_states = self.__class__.display_states(service, version, mode, path + ["display_states"])
                self.camera = self.__class__.camera(service, version, mode, path + ["camera"])
                super().__init__(service, version, mode, path)
            def write_views(self, *args, **kwargs):
                """
                Writes views to an external view file.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/views/write_views").execute(*args, **kwargs)
            def next_view(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/display/views/next_view").execute(*args, **kwargs)
            def last_view(self, *args, **kwargs):
                """
                Returns to the camera position before the last manipulation.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/views/last_view").execute(*args, **kwargs)
            def auto_scale(self, *args, **kwargs):
                """
                Scales and centers the current scene without changing its orientation.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/views/auto_scale").execute(*args, **kwargs)
            def default_view(self, *args, **kwargs):
                """
                Resets the view to front and center.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/views/default_view").execute(*args, **kwargs)
            def delete_view(self, *args, **kwargs):
                """
                Deletes a particular view from the list of stored views.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/views/delete_view").execute(*args, **kwargs)
            def list_views(self, *args, **kwargs):
                """
                Lists all predefined and saved views.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/views/list_views").execute(*args, **kwargs)
            def restore_view(self, *args, **kwargs):
                """
                Sets the current view to one of the stored views.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/views/restore_view").execute(*args, **kwargs)
            def save_view(self, *args, **kwargs):
                """
                Saves the currently displayed view into the list of stored views.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/views/save_view").execute(*args, **kwargs)
            def read_views(self, *args, **kwargs):
                """
                Reads views from an external view file.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/views/read_views").execute(*args, **kwargs)

            class display_states(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/display_states/list_properties").execute(*args, **kwargs)
                def read(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/display_states/read").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename display-states object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/display_states/rename").execute(*args, **kwargs)
                def new(self, *args, **kwargs):
                    """
                    Create a new display-states object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/display_states/new").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit display-states object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/display_states/edit").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/display_states/duplicate").execute(*args, **kwargs)
                def write(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/display_states/write").execute(*args, **kwargs)
                def restore_state(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/display_states/restore_state").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/display_states/list").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete display-states object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/display_states/delete").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/display_states/copy").execute(*args, **kwargs)
                def use_active(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/display_states/use_active").execute(*args, **kwargs)

            class camera(TUIMenu):
                """
                Contains commands to set the camera options.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def dolly_camera(self, *args, **kwargs):
                    """
                    Enables you to move the camera left, right, up, down, in, and out.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/camera/dolly_camera").execute(*args, **kwargs)
                def field(self, *args, **kwargs):
                    """
                    Enables you to set the field of view (width and height) of the scene.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/camera/field").execute(*args, **kwargs)
                def projection(self, *args, **kwargs):
                    """
                    Lets you switch between perspective and orthographic views.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/camera/projection").execute(*args, **kwargs)
                def pan_camera(self, *args, **kwargs):
                    """
                    Gives you the effect of sweeping the camera across the scene. The camera remains at its position but its target changes.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/camera/pan_camera").execute(*args, **kwargs)
                def zoom_camera(self, *args, **kwargs):
                    """
                    Adjusts the cameras field of view. This operation is similar to dollying the camera in or out of the scene. Dollying causes objects in front to move past you. Zooming changes the perspective effect in the scene (and can be disconcerting).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/camera/zoom_camera").execute(*args, **kwargs)
                def target(self, *args, **kwargs):
                    """
                    Sets the point the camera will look at.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/camera/target").execute(*args, **kwargs)
                def position(self, *args, **kwargs):
                    """
                    Sets the camera position.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/camera/position").execute(*args, **kwargs)
                def roll_camera(self, *args, **kwargs):
                    """
                    Lets you adjust the camera up-vector.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/camera/roll_camera").execute(*args, **kwargs)
                def up_vector(self, *args, **kwargs):
                    """
                    Sets the camera up-vector.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/camera/up_vector").execute(*args, **kwargs)
                def orbit_camera(self, *args, **kwargs):
                    """
                    Enables you to move the camera around the target. Gives the effect of circling around the target.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/display/views/camera/orbit_camera").execute(*args, **kwargs)

        class pdf_data(TUIMenu):
            """
            Enters the PDF data menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def plot_1d_slice(self, *args, **kwargs):
                """
                Enables/disables a plot of the 1D-slice.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/pdf_data/plot_1d_slice").execute(*args, **kwargs)
            def draw_number_box(self, *args, **kwargs):
                """
                Enables/disables the display of the numbers box.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/pdf_data/draw_number_box").execute(*args, **kwargs)
            def write_to_file(self, *args, **kwargs):
                """
                Enables/disables writing the 1D-slice to file instead of plot.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/pdf_data/write_to_file").execute(*args, **kwargs)
            def carpet_plot(self, *args, **kwargs):
                """
                Enables/disables the display of a carpet plot of a property.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/pdf_data/carpet_plot").execute(*args, **kwargs)

        class view_sync(TUIMenu):
            """
            Synchronize window views.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def stop(self, *args, **kwargs):
                """
                Stop view synchronization.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/view_sync/stop").execute(*args, **kwargs)
            def remove(self, *args, **kwargs):
                """
                Remove list of window ids from synchronization.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/view_sync/remove").execute(*args, **kwargs)
            def start(self, *args, **kwargs):
                """
                Start view synchronization.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/view_sync/start").execute(*args, **kwargs)
            def add_all(self, *args, **kwargs):
                """
                Synchronize all windows.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/view_sync/add_all").execute(*args, **kwargs)
            def remove_all(self, *args, **kwargs):
                """
                Unsynchronize all windows.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/view_sync/remove_all").execute(*args, **kwargs)
            def add(self, *args, **kwargs):
                """
                Add list of window ids for synchronization.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/view_sync/add").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                Print window ids of open windows.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/view_sync/list").execute(*args, **kwargs)

        class display_states(TUIMenu):
            """
            Enter the display state manipulation menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def edit(self, *args, **kwargs):
                """
                Edit a particular display state setting.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/display_states/edit").execute(*args, **kwargs)
            def read(self, *args, **kwargs):
                """
                Read display states from a file.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/display_states/read").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                Print the names of the available display states to the console.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/display_states/list").execute(*args, **kwargs)
            def copy(self, *args, **kwargs):
                """
                Create a new display state with settings copied from an existing display state.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/display_states/copy").execute(*args, **kwargs)
            def apply(self, *args, **kwargs):
                """
                Apply a display state to the active window.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/display_states/apply").execute(*args, **kwargs)
            def use_active(self, *args, **kwargs):
                """
                Update an existing display state's settings to match those of the active graphics window.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/display_states/use_active").execute(*args, **kwargs)
            def create(self, *args, **kwargs):
                """
                Create a new display state.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/display_states/create").execute(*args, **kwargs)
            def write(self, *args, **kwargs):
                """
                Write display states to a file.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/display_states/write").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete a display state.
                """
                return PyMenu(self._service, self._version, self._mode, "/display/display_states/delete").execute(*args, **kwargs)

    class results(TUIMenu):
        """
        .
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            self.surfaces = self.__class__.surfaces(service, version, mode, path + ["surfaces"])
            self.animations = self.__class__.animations(service, version, mode, path + ["animations"])
            self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
            self.scene = self.__class__.scene(service, version, mode, path + ["scene"])
            self.graphics = self.__class__.graphics(service, version, mode, path + ["graphics"])
            self.report = self.__class__.report(service, version, mode, path + ["report"])
            super().__init__(service, version, mode, path)

        class surfaces(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.line_surface = self.__class__.line_surface(service, version, mode, path + ["line_surface"])
                self.plane_surface = self.__class__.plane_surface(service, version, mode, path + ["plane_surface"])
                self.rake_surface = self.__class__.rake_surface(service, version, mode, path + ["rake_surface"])
                self.iso_surface = self.__class__.iso_surface(service, version, mode, path + ["iso_surface"])
                self.point_surface = self.__class__.point_surface(service, version, mode, path + ["point_surface"])
                super().__init__(service, version, mode, path)

            class line_surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def rename(self, *args, **kwargs):
                    """
                    Rename line-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/line_surface/rename").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/line_surface/list_properties").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete line-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/line_surface/delete").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/line_surface/duplicate").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit line-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/line_surface/edit").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/line_surface/list").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new line-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/line_surface/create").execute(*args, **kwargs)

            class plane_surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/plane_surface/duplicate").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit plane-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/plane_surface/edit").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/plane_surface/list_properties").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete plane-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/plane_surface/delete").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new plane-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/plane_surface/create").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename plane-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/plane_surface/rename").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/plane_surface/list").execute(*args, **kwargs)

            class rake_surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def rename(self, *args, **kwargs):
                    """
                    Rename rake-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/rake_surface/rename").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/rake_surface/list_properties").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new rake-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/rake_surface/create").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/rake_surface/duplicate").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit rake-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/rake_surface/edit").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/rake_surface/list").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete rake-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/rake_surface/delete").execute(*args, **kwargs)

            class iso_surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/iso_surface/list_properties").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new iso-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/iso_surface/create").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/iso_surface/duplicate").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename iso-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/iso_surface/rename").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/iso_surface/list").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit iso-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/iso_surface/edit").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete iso-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/iso_surface/delete").execute(*args, **kwargs)

            class point_surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def delete(self, *args, **kwargs):
                    """
                    Delete point-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/point_surface/delete").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename point-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/point_surface/rename").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit point-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/point_surface/edit").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/point_surface/list_properties").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/point_surface/duplicate").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new point-surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/point_surface/create").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/surfaces/point_surface/list").execute(*args, **kwargs)

        class animations(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.playback = self.__class__.playback(service, version, mode, path + ["playback"])
                super().__init__(service, version, mode, path)

            class playback(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.video = self.__class__.video(service, version, mode, path + ["video"])
                    self.set_custom_frames = self.__class__.set_custom_frames(service, version, mode, path + ["set_custom_frames"])
                    super().__init__(service, version, mode, path)
                def stored_view(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/stored_view").execute(*args, **kwargs)
                def write_animation(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/write_animation").execute(*args, **kwargs)
                def read_animation(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/read_animation").execute(*args, **kwargs)

                class video(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.advance_quality = self.__class__.advance_quality(service, version, mode, path + ["advance_quality"])
                        super().__init__(service, version, mode, path)
                    def quality(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/video/quality").execute(*args, **kwargs)
                    def scale(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/video/scale").execute(*args, **kwargs)
                    def format(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/video/format").execute(*args, **kwargs)
                    def height(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/video/height").execute(*args, **kwargs)
                    def name(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/video/name").execute(*args, **kwargs)
                    def width(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/video/width").execute(*args, **kwargs)
                    def set_standard_resolution(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/video/set_standard_resolution").execute(*args, **kwargs)
                    def fps(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/video/fps").execute(*args, **kwargs)
                    def use_original_resolution(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/video/use_original_resolution").execute(*args, **kwargs)

                    class advance_quality(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def keyframe(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/video/advance_quality/keyframe").execute(*args, **kwargs)
                        def bitrate_scale(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/video/advance_quality/bitrate_scale").execute(*args, **kwargs)
                        def bitrate(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/video/advance_quality/bitrate").execute(*args, **kwargs)
                        def enable_h264(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/video/advance_quality/enable_h264").execute(*args, **kwargs)
                        def compression_method(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/video/advance_quality/compression_method").execute(*args, **kwargs)

                class set_custom_frames(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def start_frame(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/set_custom_frames/start_frame").execute(*args, **kwargs)
                    def end_frame(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/set_custom_frames/end_frame").execute(*args, **kwargs)
                    def increment(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/animations/playback/set_custom_frames/increment").execute(*args, **kwargs)

        class plot(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.xy_plot = self.__class__.xy_plot(service, version, mode, path + ["xy_plot"])
                super().__init__(service, version, mode, path)

            class xy_plot(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def delete(self, *args, **kwargs):
                    """
                    Delete xy-plot object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/plot/xy_plot/delete").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/plot/xy_plot/list_properties").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/plot/xy_plot/duplicate").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new xy-plot object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/plot/xy_plot/create").execute(*args, **kwargs)
                def display(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/plot/xy_plot/display").execute(*args, **kwargs)
                def clear_history(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/plot/xy_plot/clear_history").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/plot/xy_plot/list").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename xy-plot object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/plot/xy_plot/rename").execute(*args, **kwargs)
                def add_to_graphics(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/plot/xy_plot/add_to_graphics").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit xy-plot object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/plot/xy_plot/edit").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/plot/xy_plot/copy").execute(*args, **kwargs)

        class scene(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def list_properties(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/results/scene/list_properties").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete scene object.
                """
                return PyMenu(self._service, self._version, self._mode, "/results/scene/delete").execute(*args, **kwargs)
            def add_to_graphics(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/results/scene/add_to_graphics").execute(*args, **kwargs)
            def copy(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/results/scene/copy").execute(*args, **kwargs)
            def rename(self, *args, **kwargs):
                """
                Rename scene object.
                """
                return PyMenu(self._service, self._version, self._mode, "/results/scene/rename").execute(*args, **kwargs)
            def clear_history(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/results/scene/clear_history").execute(*args, **kwargs)
            def create(self, *args, **kwargs):
                """
                Create a new scene object.
                """
                return PyMenu(self._service, self._version, self._mode, "/results/scene/create").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/results/scene/display").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit scene object.
                """
                return PyMenu(self._service, self._version, self._mode, "/results/scene/edit").execute(*args, **kwargs)
            def duplicate(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/results/scene/duplicate").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/results/scene/list").execute(*args, **kwargs)

        class graphics(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.lights = self.__class__.lights(service, version, mode, path + ["lights"])
                self.raytracing_options = self.__class__.raytracing_options(service, version, mode, path + ["raytracing_options"])
                self.picture = self.__class__.picture(service, version, mode, path + ["picture"])
                self.vector = self.__class__.vector(service, version, mode, path + ["vector"])
                self.pathline = self.__class__.pathline(service, version, mode, path + ["pathline"])
                self.particle_track = self.__class__.particle_track(service, version, mode, path + ["particle_track"])
                self.views = self.__class__.views(service, version, mode, path + ["views"])
                self.particle_tracks = self.__class__.particle_tracks(service, version, mode, path + ["particle_tracks"])
                self.mesh = self.__class__.mesh(service, version, mode, path + ["mesh"])
                self.colors = self.__class__.colors(service, version, mode, path + ["colors"])
                self.contours = self.__class__.contours(service, version, mode, path + ["contours"])
                self.contour = self.__class__.contour(service, version, mode, path + ["contour"])
                self.lic = self.__class__.lic(service, version, mode, path + ["lic"])
                self.windows = self.__class__.windows(service, version, mode, path + ["windows"])
                self.olic = self.__class__.olic(service, version, mode, path + ["olic"])
                super().__init__(service, version, mode, path)

            class lights(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def lighting_interpolation(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/lights/lighting_interpolation").execute(*args, **kwargs)
                def ambient_color(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/lights/ambient_color").execute(*args, **kwargs)
                def set_light(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/lights/set_light").execute(*args, **kwargs)
                def headlight_setting(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/lights/headlight_setting").execute(*args, **kwargs)
                def lights_on(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/lights/lights_on").execute(*args, **kwargs)

            class raytracing_options(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.rendering = self.__class__.rendering(service, version, mode, path + ["rendering"])
                    self.background = self.__class__.background(service, version, mode, path + ["background"])
                    super().__init__(service, version, mode, path)
                def display_live_preview(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/raytracing_options/display_live_preview").execute(*args, **kwargs)

                class rendering(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def denoiser(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/raytracing_options/rendering/denoiser").execute(*args, **kwargs)
                    def thread_count(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/raytracing_options/rendering/thread_count").execute(*args, **kwargs)
                    def quality(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/raytracing_options/rendering/quality").execute(*args, **kwargs)
                    def max_rendering_timeout(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/raytracing_options/rendering/max_rendering_timeout").execute(*args, **kwargs)

                class background(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def backplate_color(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/raytracing_options/background/backplate_color").execute(*args, **kwargs)
                    def show_backplate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/raytracing_options/background/show_backplate").execute(*args, **kwargs)
                    def hide_environment_keep_effects(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/raytracing_options/background/hide_environment_keep_effects").execute(*args, **kwargs)
                    def view_zoom(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/raytracing_options/background/view_zoom").execute(*args, **kwargs)
                    def longitude(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/raytracing_options/background/longitude").execute(*args, **kwargs)
                    def backplate_image(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/raytracing_options/background/backplate_image").execute(*args, **kwargs)
                    def environment_image(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/raytracing_options/background/environment_image").execute(*args, **kwargs)
                    def latitude(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/raytracing_options/background/latitude").execute(*args, **kwargs)

            class picture(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.driver_options = self.__class__.driver_options(service, version, mode, path + ["driver_options"])
                    super().__init__(service, version, mode, path)
                def list_color_mode(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/list_color_mode").execute(*args, **kwargs)
                def standard_resolution(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/standard_resolution").execute(*args, **kwargs)
                def preview(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/preview").execute(*args, **kwargs)
                def color_mode(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/color_mode").execute(*args, **kwargs)
                def y_resolution(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/y_resolution").execute(*args, **kwargs)
                def landscape(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/landscape").execute(*args, **kwargs)
                def save_picture(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/save_picture").execute(*args, **kwargs)
                def use_window_resolution(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/use_window_resolution").execute(*args, **kwargs)
                def invert_background(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/invert_background").execute(*args, **kwargs)
                def x_resolution(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/x_resolution").execute(*args, **kwargs)
                def raytracer_image(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/raytracer_image").execute(*args, **kwargs)
                def dpi(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/dpi").execute(*args, **kwargs)
                def jpeg_hardcopy_quality(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/jpeg_hardcopy_quality").execute(*args, **kwargs)

                class driver_options(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def hardcopy_format(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/driver_options/hardcopy_format").execute(*args, **kwargs)
                    def current_driver(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/driver_options/current_driver").execute(*args, **kwargs)
                    def window_dump_cmd(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/driver_options/window_dump_cmd").execute(*args, **kwargs)
                    def post_format(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/driver_options/post_format").execute(*args, **kwargs)
                    def hardcopy_options(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/picture/driver_options/hardcopy_options").execute(*args, **kwargs)

            class vector(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def edit(self, *args, **kwargs):
                    """
                    Edit vector object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/vector/edit").execute(*args, **kwargs)
                def clear_history(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/vector/clear_history").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/vector/duplicate").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename vector object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/vector/rename").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/vector/list").execute(*args, **kwargs)
                def add_to_graphics(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/vector/add_to_graphics").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/vector/list_properties").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/vector/copy").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete vector object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/vector/delete").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new vector object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/vector/create").execute(*args, **kwargs)
                def display(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/vector/display").execute(*args, **kwargs)

            class pathline(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def create(self, *args, **kwargs):
                    """
                    Create a new pathline object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/pathline/create").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/pathline/copy").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/pathline/duplicate").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/pathline/list_properties").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/pathline/list").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete pathline object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/pathline/delete").execute(*args, **kwargs)
                def display(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/pathline/display").execute(*args, **kwargs)
                def add_to_graphics(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/pathline/add_to_graphics").execute(*args, **kwargs)
                def clear_history(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/pathline/clear_history").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename pathline object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/pathline/rename").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit pathline object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/pathline/edit").execute(*args, **kwargs)

            class particle_track(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def add_to_graphics(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_track/add_to_graphics").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit particle-track object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_track/edit").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete particle-track object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_track/delete").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_track/list_properties").execute(*args, **kwargs)
                def clear_history(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_track/clear_history").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename particle-track object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_track/rename").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_track/list").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_track/duplicate").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_track/copy").execute(*args, **kwargs)
                def display(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_track/display").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new particle-track object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_track/create").execute(*args, **kwargs)

            class views(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.display_states = self.__class__.display_states(service, version, mode, path + ["display_states"])
                    self.camera = self.__class__.camera(service, version, mode, path + ["camera"])
                    super().__init__(service, version, mode, path)
                def write_views(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/write_views").execute(*args, **kwargs)
                def list_views(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/list_views").execute(*args, **kwargs)
                def delete_view(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/delete_view").execute(*args, **kwargs)
                def save_view(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/save_view").execute(*args, **kwargs)
                def read_views(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/read_views").execute(*args, **kwargs)
                def next_view(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/next_view").execute(*args, **kwargs)
                def last_view(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/last_view").execute(*args, **kwargs)
                def auto_scale(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/auto_scale").execute(*args, **kwargs)
                def reset_to_default_view(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/reset_to_default_view").execute(*args, **kwargs)
                def restore_view(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/restore_view").execute(*args, **kwargs)

                class display_states(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def read(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/display_states/read").execute(*args, **kwargs)
                    def use_active(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/display_states/use_active").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete display-states object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/display_states/delete").execute(*args, **kwargs)
                    def edit(self, *args, **kwargs):
                        """
                        Edit display-states object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/display_states/edit").execute(*args, **kwargs)
                    def list_properties(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/display_states/list_properties").execute(*args, **kwargs)
                    def copy(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/display_states/copy").execute(*args, **kwargs)
                    def create(self, *args, **kwargs):
                        """
                        Create a new display-states object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/display_states/create").execute(*args, **kwargs)
                    def rename(self, *args, **kwargs):
                        """
                        Rename display-states object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/display_states/rename").execute(*args, **kwargs)
                    def duplicate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/display_states/duplicate").execute(*args, **kwargs)
                    def restore_state(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/display_states/restore_state").execute(*args, **kwargs)
                    def write(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/display_states/write").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/display_states/list").execute(*args, **kwargs)

                class camera(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def zoom(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/camera/zoom").execute(*args, **kwargs)
                    def pan(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/camera/pan").execute(*args, **kwargs)
                    def up_vector(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/camera/up_vector").execute(*args, **kwargs)
                    def position(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/camera/position").execute(*args, **kwargs)
                    def projection(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/camera/projection").execute(*args, **kwargs)
                    def orbit(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/camera/orbit").execute(*args, **kwargs)
                    def field(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/camera/field").execute(*args, **kwargs)
                    def target(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/camera/target").execute(*args, **kwargs)
                    def dolly(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/camera/dolly").execute(*args, **kwargs)
                    def roll(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/views/camera/roll").execute(*args, **kwargs)

            class particle_tracks(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def arrow_space(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_tracks/arrow_space").execute(*args, **kwargs)
                def history_filename(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_tracks/history_filename").execute(*args, **kwargs)
                def track_single_particle_stream(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_tracks/track_single_particle_stream").execute(*args, **kwargs)
                def coarsen_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_tracks/coarsen_factor").execute(*args, **kwargs)
                def report_default_variables(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_tracks/report_default_variables").execute(*args, **kwargs)
                def display(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_tracks/display").execute(*args, **kwargs)
                def arrow_scale(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_tracks/arrow_scale").execute(*args, **kwargs)
                def line_width(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/particle_tracks/line_width").execute(*args, **kwargs)

            class mesh(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def clear_history(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/mesh/clear_history").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename mesh object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/mesh/rename").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new mesh object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/mesh/create").execute(*args, **kwargs)
                def display(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/mesh/display").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/mesh/list").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit mesh object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/mesh/edit").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete mesh object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/mesh/delete").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/mesh/copy").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/mesh/list_properties").execute(*args, **kwargs)
                def add_to_graphics(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/mesh/add_to_graphics").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/mesh/duplicate").execute(*args, **kwargs)

            class colors(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.by_type = self.__class__.by_type(service, version, mode, path + ["by_type"])
                    self.by_surface = self.__class__.by_surface(service, version, mode, path + ["by_surface"])
                    super().__init__(service, version, mode, path)
                def outlet_faces(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/outlet_faces").execute(*args, **kwargs)
                def axis_faces(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/axis_faces").execute(*args, **kwargs)
                def internal_faces(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/internal_faces").execute(*args, **kwargs)
                def interior_faces(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/interior_faces").execute(*args, **kwargs)
                def wall_faces(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/wall_faces").execute(*args, **kwargs)
                def interface_faces(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/interface_faces").execute(*args, **kwargs)
                def color_by_type(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/color_by_type").execute(*args, **kwargs)
                def far_field_faces(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/far_field_faces").execute(*args, **kwargs)
                def foreground(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/foreground").execute(*args, **kwargs)
                def overset_faces(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/overset_faces").execute(*args, **kwargs)
                def surface(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/surface").execute(*args, **kwargs)
                def free_surface_faces(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/free_surface_faces").execute(*args, **kwargs)
                def rans_les_interface_faces(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/rans_les_interface_faces").execute(*args, **kwargs)
                def reset_colors(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/reset_colors").execute(*args, **kwargs)
                def periodic_faces(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/periodic_faces").execute(*args, **kwargs)
                def traction_faces(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/traction_faces").execute(*args, **kwargs)
                def inlet_faces(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/inlet_faces").execute(*args, **kwargs)
                def list_colors(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/list_colors").execute(*args, **kwargs)
                def symmetry_faces(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/symmetry_faces").execute(*args, **kwargs)
                def background(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/background").execute(*args, **kwargs)
                def skip_label(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/skip_label").execute(*args, **kwargs)
                def automatic_skip(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/automatic_skip").execute(*args, **kwargs)

                class by_type(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def only_list_case_boundaries(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/by_type/only_list_case_boundaries").execute(*args, **kwargs)
                    def use_inherent_material_color(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/by_type/use_inherent_material_color").execute(*args, **kwargs)
                    def reset(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/by_type/reset").execute(*args, **kwargs)

                class by_surface(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def use_inherent_material_color(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/by_surface/use_inherent_material_color").execute(*args, **kwargs)
                    def reset(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/by_surface/reset").execute(*args, **kwargs)
                    def list_surfaces_by_color(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/by_surface/list_surfaces_by_color").execute(*args, **kwargs)
                    def list_surfaces_by_material(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/colors/by_surface/list_surfaces_by_material").execute(*args, **kwargs)

            class contours(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.coloring = self.__class__.coloring(service, version, mode, path + ["coloring"])
                    super().__init__(service, version, mode, path)
                def surfaces(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contours/surfaces").execute(*args, **kwargs)
                def auto_scale(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contours/auto_scale").execute(*args, **kwargs)
                def filled_contours(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contours/filled_contours").execute(*args, **kwargs)
                def log_scale(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contours/log_scale").execute(*args, **kwargs)
                def clip_to_range(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contours/clip_to_range").execute(*args, **kwargs)
                def node_values(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contours/node_values").execute(*args, **kwargs)
                def n_contour(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contours/n_contour").execute(*args, **kwargs)
                def global_range(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contours/global_range").execute(*args, **kwargs)
                def render_mesh(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contours/render_mesh").execute(*args, **kwargs)
                def line_contours(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contours/line_contours").execute(*args, **kwargs)

                class coloring(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def banded_coloring(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/contours/coloring/banded_coloring").execute(*args, **kwargs)
                    def number_of_bands(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/contours/coloring/number_of_bands").execute(*args, **kwargs)

            class contour(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def clear_history(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contour/clear_history").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit contour object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contour/edit").execute(*args, **kwargs)
                def display(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contour/display").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contour/copy").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename contour object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contour/rename").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contour/list_properties").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete contour object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contour/delete").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contour/list").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contour/duplicate").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new contour object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contour/create").execute(*args, **kwargs)
                def add_to_graphics(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/contour/add_to_graphics").execute(*args, **kwargs)

            class lic(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/lic/list").execute(*args, **kwargs)
                def clear_history(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/lic/clear_history").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/lic/copy").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/lic/list_properties").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/lic/duplicate").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename lic object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/lic/rename").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new lic object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/lic/create").execute(*args, **kwargs)
                def display(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/lic/display").execute(*args, **kwargs)
                def add_to_graphics(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/lic/add_to_graphics").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete lic object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/lic/delete").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit lic object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/lic/edit").execute(*args, **kwargs)

            class windows(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.main = self.__class__.main(service, version, mode, path + ["main"])
                    self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                    self.xy = self.__class__.xy(service, version, mode, path + ["xy"])
                    self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
                    self.video = self.__class__.video(service, version, mode, path + ["video"])
                    self.text = self.__class__.text(service, version, mode, path + ["text"])
                    super().__init__(service, version, mode, path)
                def ruler(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/ruler").execute(*args, **kwargs)
                def logo(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/logo").execute(*args, **kwargs)
                def logo_color(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/logo_color").execute(*args, **kwargs)
                def aspect_ratio(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/aspect_ratio").execute(*args, **kwargs)

                class main(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def top(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/main/top").execute(*args, **kwargs)
                    def left(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/main/left").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/main/bottom").execute(*args, **kwargs)
                    def border(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/main/border").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/main/right").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/main/visible").execute(*args, **kwargs)

                class axes(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def left(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/axes/left").execute(*args, **kwargs)
                    def border(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/axes/border").execute(*args, **kwargs)
                    def top(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/axes/top").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/axes/visible").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/axes/bottom").execute(*args, **kwargs)
                    def clear(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/axes/clear").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/axes/right").execute(*args, **kwargs)

                class xy(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def right(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/xy/right").execute(*args, **kwargs)
                    def top(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/xy/top").execute(*args, **kwargs)
                    def border(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/xy/border").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/xy/bottom").execute(*args, **kwargs)
                    def left(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/xy/left").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/xy/visible").execute(*args, **kwargs)

                class scale(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def clear(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/scale/clear").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/scale/visible").execute(*args, **kwargs)
                    def margin(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/scale/margin").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/scale/bottom").execute(*args, **kwargs)
                    def font_size(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/scale/font_size").execute(*args, **kwargs)
                    def border(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/scale/border").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/scale/right").execute(*args, **kwargs)
                    def left(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/scale/left").execute(*args, **kwargs)
                    def top(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/scale/top").execute(*args, **kwargs)
                    def format(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/scale/format").execute(*args, **kwargs)

                class video(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.pixel_size = self.__class__.pixel_size(service, version, mode, path + ["pixel_size"])
                        super().__init__(service, version, mode, path)
                    def foreground(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/video/foreground").execute(*args, **kwargs)
                    def on(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/video/on").execute(*args, **kwargs)
                    def background(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/video/background").execute(*args, **kwargs)
                    def color_filter(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/video/color_filter").execute(*args, **kwargs)

                    class pixel_size(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def width(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/video/pixel_size/width").execute(*args, **kwargs)
                        def height(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/video/pixel_size/height").execute(*args, **kwargs)
                        def margin(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/video/pixel_size/margin").execute(*args, **kwargs)

                class text(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def left(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/text/left").execute(*args, **kwargs)
                    def top(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/text/top").execute(*args, **kwargs)
                    def clear(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/text/clear").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/text/bottom").execute(*args, **kwargs)
                    def company(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/text/company").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/text/right").execute(*args, **kwargs)
                    def date(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/text/date").execute(*args, **kwargs)
                    def application(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/text/application").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/text/visible").execute(*args, **kwargs)
                    def alignment(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/text/alignment").execute(*args, **kwargs)
                    def border(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/graphics/windows/text/border").execute(*args, **kwargs)

            class olic(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def add_to_graphics(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/olic/add_to_graphics").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete olic object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/olic/delete").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/olic/copy").execute(*args, **kwargs)
                def clear_history(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/olic/clear_history").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/olic/duplicate").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/olic/list_properties").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit olic object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/olic/edit").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/olic/list").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new olic object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/olic/create").execute(*args, **kwargs)
                def display(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/olic/display").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename olic object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/graphics/olic/rename").execute(*args, **kwargs)

        class report(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.system = self.__class__.system(service, version, mode, path + ["system"])
                self.fluxes = self.__class__.fluxes(service, version, mode, path + ["fluxes"])
                self.modified_setting_options = self.__class__.modified_setting_options(service, version, mode, path + ["modified_setting_options"])
                self.heat_exchange = self.__class__.heat_exchange(service, version, mode, path + ["heat_exchange"])
                self.simulation_reports = self.__class__.simulation_reports(service, version, mode, path + ["simulation_reports"])
                self.flow = self.__class__.flow(service, version, mode, path + ["flow"])
                self.discrete_phase = self.__class__.discrete_phase(service, version, mode, path + ["discrete_phase"])
                self.population_balance = self.__class__.population_balance(service, version, mode, path + ["population_balance"])
                self.histogram = self.__class__.histogram(service, version, mode, path + ["histogram"])
                super().__init__(service, version, mode, path)
            def volume_integrals(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/results/report/volume_integrals").execute(*args, **kwargs)
            def aero_optical_distortions(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/results/report/aero_optical_distortions").execute(*args, **kwargs)
            def path_line_summary(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/results/report/path_line_summary").execute(*args, **kwargs)
            def summary(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/results/report/summary").execute(*args, **kwargs)
            def surface_integrals(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/results/report/surface_integrals").execute(*args, **kwargs)
            def forces(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/results/report/forces").execute(*args, **kwargs)
            def particle_summary(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/results/report/particle_summary").execute(*args, **kwargs)
            def projected_surface_area(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/results/report/projected_surface_area").execute(*args, **kwargs)
            def mphase_summary(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/results/report/mphase_summary").execute(*args, **kwargs)

            class system(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def sys_statistics(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/system/sys_statistics").execute(*args, **kwargs)
                def proc_statistics(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/system/proc_statistics").execute(*args, **kwargs)
                def time_statistics(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/system/time_statistics").execute(*args, **kwargs)
                def gpgpu_statistics(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/system/gpgpu_statistics").execute(*args, **kwargs)

            class fluxes(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def electric_current(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/fluxes/electric_current").execute(*args, **kwargs)
                def mass_flow(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/fluxes/mass_flow").execute(*args, **kwargs)
                def rad_heat_trans(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/fluxes/rad_heat_trans").execute(*args, **kwargs)
                def heat_transfer_sensible(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/fluxes/heat_transfer_sensible").execute(*args, **kwargs)
                def heat_transfer(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/fluxes/heat_transfer").execute(*args, **kwargs)
                def pressure_work(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/fluxes/pressure_work").execute(*args, **kwargs)
                def film_mass_flow(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/fluxes/film_mass_flow").execute(*args, **kwargs)
                def viscous_work(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/fluxes/viscous_work").execute(*args, **kwargs)
                def film_heat_transfer(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/fluxes/film_heat_transfer").execute(*args, **kwargs)

            class modified_setting_options(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def modified_setting(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/modified_setting_options/modified_setting").execute(*args, **kwargs)
                def write_user_setting(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/modified_setting_options/write_user_setting").execute(*args, **kwargs)

            class heat_exchange(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def inlet_temperature(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/heat_exchange/inlet_temperature").execute(*args, **kwargs)
                def mass_flow_rate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/heat_exchange/mass_flow_rate").execute(*args, **kwargs)
                def computed_heat_rejection(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/heat_exchange/computed_heat_rejection").execute(*args, **kwargs)
                def outlet_temperature(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/heat_exchange/outlet_temperature").execute(*args, **kwargs)
                def specific_heat(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/heat_exchange/specific_heat").execute(*args, **kwargs)

            class simulation_reports(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def duplicate_simulation_report(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/simulation_reports/duplicate_simulation_report").execute(*args, **kwargs)
                def generate_simulation_report(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/simulation_reports/generate_simulation_report").execute(*args, **kwargs)
                def read_simulation_report_template_file(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/simulation_reports/read_simulation_report_template_file").execute(*args, **kwargs)
                def export_simulation_report_as_pptx(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/simulation_reports/export_simulation_report_as_pptx").execute(*args, **kwargs)
                def export_simulation_report_as_html(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/simulation_reports/export_simulation_report_as_html").execute(*args, **kwargs)
                def list_simulation_reports(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/simulation_reports/list_simulation_reports").execute(*args, **kwargs)
                def rename_simulation_report(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/simulation_reports/rename_simulation_report").execute(*args, **kwargs)
                def reset_report_to_defaults(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/simulation_reports/reset_report_to_defaults").execute(*args, **kwargs)
                def write_simulation_report_template_file(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/simulation_reports/write_simulation_report_template_file").execute(*args, **kwargs)
                def export_simulation_report_as_pdf(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/simulation_reports/export_simulation_report_as_pdf").execute(*args, **kwargs)
                def delete_simulation_report(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/simulation_reports/delete_simulation_report").execute(*args, **kwargs)
                def view_simulation_report(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/simulation_reports/view_simulation_report").execute(*args, **kwargs)
                def write_simulation_report_names_to_file(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/simulation_reports/write_simulation_report_names_to_file").execute(*args, **kwargs)

            class flow(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def uds_flow(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/flow/uds_flow").execute(*args, **kwargs)
                def species_mass_flow(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/flow/species_mass_flow").execute(*args, **kwargs)
                def element_mass_flow(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/flow/element_mass_flow").execute(*args, **kwargs)

            class discrete_phase(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.histogram = self.__class__.histogram(service, version, mode, path + ["histogram"])
                    self.sample_trajectories = self.__class__.sample_trajectories(service, version, mode, path + ["sample_trajectories"])
                    super().__init__(service, version, mode, path)
                def extended_summary(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/extended_summary").execute(*args, **kwargs)
                def summary(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/summary").execute(*args, **kwargs)
                def zone_summaries_per_injection(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/zone_summaries_per_injection").execute(*args, **kwargs)

                class histogram(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.histogram_parameters = self.__class__.histogram_parameters(service, version, mode, path + ["histogram_parameters"])
                        self.plot_write_sample = self.__class__.plot_write_sample(service, version, mode, path + ["plot_write_sample"])
                        self.reduction = self.__class__.reduction(service, version, mode, path + ["reduction"])
                        self.histogram_options = self.__class__.histogram_options(service, version, mode, path + ["histogram_options"])
                        super().__init__(service, version, mode, path)
                    def delete_sample(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/delete_sample").execute(*args, **kwargs)
                    def compute_sample(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/compute_sample").execute(*args, **kwargs)
                    def read_sample_file(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/read_sample_file").execute(*args, **kwargs)
                    def list_samples(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/list_samples").execute(*args, **kwargs)
                    def dpm_sample_contour_plots(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/dpm_sample_contour_plots").execute(*args, **kwargs)

                    class histogram_parameters(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def division_val(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/histogram_parameters/division_val").execute(*args, **kwargs)
                        def minimum_val(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/histogram_parameters/minimum_val").execute(*args, **kwargs)
                        def maximum_val(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/histogram_parameters/maximum_val").execute(*args, **kwargs)

                    class plot_write_sample(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def plot_sample(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/plot_write_sample/plot_sample").execute(*args, **kwargs)
                        def write_sample(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/plot_write_sample/write_sample").execute(*args, **kwargs)

                    class reduction(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.setup_reduction = self.__class__.setup_reduction(service, version, mode, path + ["setup_reduction"])
                            super().__init__(service, version, mode, path)
                        def reduce_picked_sample(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/reduction/reduce_picked_sample").execute(*args, **kwargs)
                        def pick_sample_to_reduce(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/reduction/pick_sample_to_reduce").execute(*args, **kwargs)

                        class setup_reduction(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def reset_min_and_max(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/reduction/setup_reduction/reset_min_and_max").execute(*args, **kwargs)
                            def number_of_bins(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/reduction/setup_reduction/number_of_bins").execute(*args, **kwargs)
                            def use_logarithmic(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/reduction/setup_reduction/use_logarithmic").execute(*args, **kwargs)
                            def list_settings(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/reduction/setup_reduction/list_settings").execute(*args, **kwargs)
                            def make_steady_from_unsteady_file(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/reduction/setup_reduction/make_steady_from_unsteady_file").execute(*args, **kwargs)
                            def use_weighting(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/reduction/setup_reduction/use_weighting").execute(*args, **kwargs)
                            def set_minimum(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/reduction/setup_reduction/set_minimum").execute(*args, **kwargs)
                            def weighting_variable(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/reduction/setup_reduction/weighting_variable").execute(*args, **kwargs)
                            def set_maximum(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/reduction/setup_reduction/set_maximum").execute(*args, **kwargs)
                            def all_variables_number_of_bins(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/reduction/setup_reduction/all_variables_number_of_bins").execute(*args, **kwargs)

                    class histogram_options(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def percentage(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/histogram_options/percentage").execute(*args, **kwargs)
                        def variable_power_3(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/histogram_options/variable_power_3").execute(*args, **kwargs)
                        def correlation(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/histogram_options/correlation").execute(*args, **kwargs)
                        def histogram_mode(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/histogram_options/histogram_mode").execute(*args, **kwargs)
                        def auto_range(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/histogram_options/auto_range").execute(*args, **kwargs)
                        def logarithmic(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/histogram_options/logarithmic").execute(*args, **kwargs)
                        def weighting(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/histogram_options/weighting").execute(*args, **kwargs)
                        def diameter_statistics(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/histogram_options/diameter_statistics").execute(*args, **kwargs)
                        def cumulation_curve(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/histogram/histogram_options/cumulation_curve").execute(*args, **kwargs)

                class sample_trajectories(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def sort_sample_files(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/sample_trajectories/sort_sample_files").execute(*args, **kwargs)
                    def user_defined_functions(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/sample_trajectories/user_defined_functions").execute(*args, **kwargs)
                    def sample(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/results/report/discrete_phase/sample_trajectories/sample").execute(*args, **kwargs)

            class population_balance(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def moments(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/population_balance/moments").execute(*args, **kwargs)
                def number_density(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/population_balance/number_density").execute(*args, **kwargs)

            class histogram(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def print(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/histogram/print").execute(*args, **kwargs)
                def write(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/results/report/histogram/write").execute(*args, **kwargs)

    class adjoint(TUIMenu):
        """
        Adjoint.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            super().__init__(service, version, mode, path)
        def run(self, *args, **kwargs):
            """
            Menu to initialize and compute the adjoint solution.
            """
            return PyMenu(self._service, self._version, self._mode, "/adjoint/run").execute(*args, **kwargs)
        def reporting(self, *args, **kwargs):
            """
            Menu to report sensitivity data from the adjoint solution.
            """
            return PyMenu(self._service, self._version, self._mode, "/adjoint/reporting").execute(*args, **kwargs)
        def expert(self, *args, **kwargs):
            """
            Provides text commands that allow you to undo enhancements to the default adjoint solver behavior.
            """
            return PyMenu(self._service, self._version, self._mode, "/adjoint/expert").execute(*args, **kwargs)
        def utilities(self, *args, **kwargs):
            """
            Enters the utilities menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/adjoint/utilities").execute(*args, **kwargs)
        def monitors(self, *args, **kwargs):
            """
            Menu to configure monitors for the adjoint solver.
            """
            return PyMenu(self._service, self._version, self._mode, "/adjoint/monitors").execute(*args, **kwargs)
        def methods(self, *args, **kwargs):
            """
            Menu to configure adjoint solver settings.
            """
            return PyMenu(self._service, self._version, self._mode, "/adjoint/methods").execute(*args, **kwargs)
        def observable(self, *args, **kwargs):
            """
            Menu to create and configure observables of interest.
            """
            return PyMenu(self._service, self._version, self._mode, "/adjoint/observable").execute(*args, **kwargs)
        def postprocess_options(self, *args, **kwargs):
            """
            Postprocess options.
            """
            return PyMenu(self._service, self._version, self._mode, "/adjoint/postprocess_options").execute(*args, **kwargs)
        def controls(self, *args, **kwargs):
            """
            Menu to configure adjoint solver controls.
            """
            return PyMenu(self._service, self._version, self._mode, "/adjoint/controls").execute(*args, **kwargs)
        def optimizer(self, *args, **kwargs):
            """
            Enters the optimizer menu, where you can use a gradient-based optimizer to optimize the geometry to meet multiple goals for multiple observables at multiple operating conditions.
            """
            return PyMenu(self._service, self._version, self._mode, "/adjoint/optimizer").execute(*args, **kwargs)
        def multi_objective(self, *args, **kwargs):
            """
            Multi-Objective menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/adjoint/multi_objective").execute(*args, **kwargs)
        def design_tool(self, *args, **kwargs):
            """
            Enters the design-tool menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/adjoint/design_tool").execute(*args, **kwargs)
        def morphing(self, *args, **kwargs):
            """
            Morphing menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/adjoint/morphing").execute(*args, **kwargs)
        def geometry(self, *args, **kwargs):
            """
            Geometry menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/adjoint/geometry").execute(*args, **kwargs)

    class solution(TUIMenu):
        """
        .
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            self.monitor = self.__class__.monitor(service, version, mode, path + ["monitor"])
            self.cell_registers = self.__class__.cell_registers(service, version, mode, path + ["cell_registers"])
            self.report_definitions = self.__class__.report_definitions(service, version, mode, path + ["report_definitions"])
            self.calculation_activity = self.__class__.calculation_activity(service, version, mode, path + ["calculation_activity"])
            self.methods = self.__class__.methods(service, version, mode, path + ["methods"])
            self.run_calculation = self.__class__.run_calculation(service, version, mode, path + ["run_calculation"])
            self.initialization = self.__class__.initialization(service, version, mode, path + ["initialization"])
            self.controls = self.__class__.controls(service, version, mode, path + ["controls"])
            super().__init__(service, version, mode, path)

        class monitor(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.convergence_conditions = self.__class__.convergence_conditions(service, version, mode, path + ["convergence_conditions"])
                self.report_files = self.__class__.report_files(service, version, mode, path + ["report_files"])
                self.report_plots = self.__class__.report_plots(service, version, mode, path + ["report_plots"])
                super().__init__(service, version, mode, path)

            class convergence_conditions(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.convergence_reports = self.__class__.convergence_reports(service, version, mode, path + ["convergence_reports"])
                    super().__init__(service, version, mode, path)
                def check_for(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/convergence_conditions/check_for").execute(*args, **kwargs)
                def condition(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/convergence_conditions/condition").execute(*args, **kwargs)
                def frequency(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/convergence_conditions/frequency").execute(*args, **kwargs)

                class convergence_reports(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def list_properties(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/monitor/convergence_conditions/convergence_reports/list_properties").execute(*args, **kwargs)
                    def edit(self, *args, **kwargs):
                        """
                        Edit convergence-reports object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/monitor/convergence_conditions/convergence_reports/edit").execute(*args, **kwargs)
                    def rename(self, *args, **kwargs):
                        """
                        Rename convergence-reports object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/monitor/convergence_conditions/convergence_reports/rename").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete convergence-reports object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/monitor/convergence_conditions/convergence_reports/delete").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/monitor/convergence_conditions/convergence_reports/list").execute(*args, **kwargs)
                    def create(self, *args, **kwargs):
                        """
                        Create a new convergence-reports object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/monitor/convergence_conditions/convergence_reports/create").execute(*args, **kwargs)
                    def duplicate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/monitor/convergence_conditions/convergence_reports/duplicate").execute(*args, **kwargs)

            class report_files(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def rename(self, *args, **kwargs):
                    """
                    Rename report-files object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/report_files/rename").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/report_files/list").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/report_files/duplicate").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete report-files object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/report_files/delete").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/report_files/list_properties").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new report-files object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/report_files/create").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit report-files object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/report_files/edit").execute(*args, **kwargs)

            class report_plots(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def delete(self, *args, **kwargs):
                    """
                    Delete report-plots object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/report_plots/delete").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/report_plots/list").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/report_plots/list_properties").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/report_plots/duplicate").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit report-plots object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/report_plots/edit").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename report-plots object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/report_plots/rename").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new report-plots object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/monitor/report_plots/create").execute(*args, **kwargs)

        class cell_registers(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def edit(self, *args, **kwargs):
                """
                Edit cell-registers object.
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/cell_registers/edit").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/cell_registers/list").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/cell_registers/list_properties").execute(*args, **kwargs)
            def create(self, *args, **kwargs):
                """
                Create a new cell-registers object.
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/cell_registers/create").execute(*args, **kwargs)
            def rename(self, *args, **kwargs):
                """
                Rename cell-registers object.
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/cell_registers/rename").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete cell-registers object.
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/cell_registers/delete").execute(*args, **kwargs)
            def duplicate(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/cell_registers/duplicate").execute(*args, **kwargs)

        class report_definitions(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.flux = self.__class__.flux(service, version, mode, path + ["flux"])
                self.mesh = self.__class__.mesh(service, version, mode, path + ["mesh"])
                self.force = self.__class__.force(service, version, mode, path + ["force"])
                self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                self.user_defined = self.__class__.user_defined(service, version, mode, path + ["user_defined"])
                self.custom = self.__class__.custom(service, version, mode, path + ["custom"])
                self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
                self.volume = self.__class__.volume(service, version, mode, path + ["volume"])
                self.icing = self.__class__.icing(service, version, mode, path + ["icing"])
                self.injection = self.__class__.injection(service, version, mode, path + ["injection"])
                self.aeromechanics = self.__class__.aeromechanics(service, version, mode, path + ["aeromechanics"])
                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                self.moment = self.__class__.moment(service, version, mode, path + ["moment"])
                self.single_val_expression = self.__class__.single_val_expression(service, version, mode, path + ["single_val_expression"])
                self.expression = self.__class__.expression(service, version, mode, path + ["expression"])
                super().__init__(service, version, mode, path)
            def copy(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/copy").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/list").execute(*args, **kwargs)
            def compute(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/compute").execute(*args, **kwargs)

            class flux(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def rename(self, *args, **kwargs):
                    """
                    Rename flux object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/flux/rename").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new flux object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/flux/create").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit flux object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/flux/edit").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/flux/list_properties").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete flux object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/flux/delete").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/flux/duplicate").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/flux/list").execute(*args, **kwargs)

            class mesh(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/mesh/duplicate").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit mesh object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/mesh/edit").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/mesh/list").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new mesh object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/mesh/create").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/mesh/list_properties").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete mesh object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/mesh/delete").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename mesh object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/mesh/rename").execute(*args, **kwargs)

            class force(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/force/list_properties").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/force/duplicate").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/force/list").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit force object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/force/edit").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete force object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/force/delete").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new force object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/force/create").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename force object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/force/rename").execute(*args, **kwargs)

            class drag(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/drag/list_properties").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit drag object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/drag/edit").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new drag object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/drag/create").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/drag/list").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/drag/duplicate").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename drag object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/drag/rename").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete drag object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/drag/delete").execute(*args, **kwargs)

            class user_defined(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/user_defined/list_properties").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit user-defined object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/user_defined/edit").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/user_defined/duplicate").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/user_defined/list").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new user-defined object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/user_defined/create").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename user-defined object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/user_defined/rename").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete user-defined object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/user_defined/delete").execute(*args, **kwargs)

            class custom(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def create(self, *args, **kwargs):
                    """
                    Create a new custom object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/custom/create").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename custom object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/custom/rename").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/custom/duplicate").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit custom object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/custom/edit").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/custom/list_properties").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/custom/list").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete custom object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/custom/delete").execute(*args, **kwargs)

            class surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def rename(self, *args, **kwargs):
                    """
                    Rename surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/surface/rename").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/surface/list_properties").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/surface/edit").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/surface/list").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/surface/delete").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/surface/duplicate").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new surface object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/surface/create").execute(*args, **kwargs)

            class volume(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def rename(self, *args, **kwargs):
                    """
                    Rename volume object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/volume/rename").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete volume object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/volume/delete").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/volume/list").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit volume object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/volume/edit").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new volume object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/volume/create").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/volume/duplicate").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/volume/list_properties").execute(*args, **kwargs)

            class icing(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def edit(self, *args, **kwargs):
                    """
                    Edit icing object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/icing/edit").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/icing/duplicate").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename icing object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/icing/rename").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new icing object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/icing/create").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/icing/list").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete icing object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/icing/delete").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/icing/list_properties").execute(*args, **kwargs)

            class injection(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def delete(self, *args, **kwargs):
                    """
                    Delete injection object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/injection/delete").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new injection object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/injection/create").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit injection object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/injection/edit").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/injection/duplicate").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/injection/list_properties").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/injection/list").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename injection object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/injection/rename").execute(*args, **kwargs)

            class aeromechanics(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/aeromechanics/duplicate").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/aeromechanics/list").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete aeromechanics object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/aeromechanics/delete").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename aeromechanics object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/aeromechanics/rename").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new aeromechanics object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/aeromechanics/create").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/aeromechanics/list_properties").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit aeromechanics object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/aeromechanics/edit").execute(*args, **kwargs)

            class lift(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/lift/duplicate").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit lift object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/lift/edit").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename lift object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/lift/rename").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/lift/list_properties").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/lift/list").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new lift object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/lift/create").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete lift object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/lift/delete").execute(*args, **kwargs)

            class moment(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def delete(self, *args, **kwargs):
                    """
                    Delete moment object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/moment/delete").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/moment/list").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/moment/list_properties").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit moment object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/moment/edit").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/moment/duplicate").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename moment object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/moment/rename").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new moment object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/moment/create").execute(*args, **kwargs)

            class single_val_expression(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/single_val_expression/list_properties").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename single-val-expression object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/single_val_expression/rename").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/single_val_expression/duplicate").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit single-val-expression object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/single_val_expression/edit").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new single-val-expression object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/single_val_expression/create").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/single_val_expression/list").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete single-val-expression object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/single_val_expression/delete").execute(*args, **kwargs)

            class expression(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def edit(self, *args, **kwargs):
                    """
                    Edit expression object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/expression/edit").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/expression/duplicate").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete expression object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/expression/delete").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/expression/list_properties").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/expression/list").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename expression object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/expression/rename").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new expression object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/report_definitions/expression/create").execute(*args, **kwargs)

        class calculation_activity(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.execute_commands = self.__class__.execute_commands(service, version, mode, path + ["execute_commands"])
                self.solution_animations = self.__class__.solution_animations(service, version, mode, path + ["solution_animations"])
                self.poor_mesh_numerics = self.__class__.poor_mesh_numerics(service, version, mode, path + ["poor_mesh_numerics"])
                super().__init__(service, version, mode, path)
            def import_modifications(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/import_modifications").execute(*args, **kwargs)
            def disable_modification(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/disable_modification").execute(*args, **kwargs)
            def enable_modification(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/enable_modification").execute(*args, **kwargs)
            def continue_strategy_execution(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/continue_strategy_execution").execute(*args, **kwargs)
            def delete_modification(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/delete_modification").execute(*args, **kwargs)
            def export_modifications(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/export_modifications").execute(*args, **kwargs)
            def copy_modification(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/copy_modification").execute(*args, **kwargs)
            def enable_strategy(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/enable_strategy").execute(*args, **kwargs)

            class execute_commands(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def enable(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/execute_commands/enable").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/execute_commands/copy").execute(*args, **kwargs)
                def export(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/execute_commands/export").execute(*args, **kwargs)
                def import_(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/execute_commands/import_").execute(*args, **kwargs)
                def disable(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/execute_commands/disable").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/execute_commands/delete").execute(*args, **kwargs)

            class solution_animations(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def create(self, *args, **kwargs):
                    """
                    Create a new solution-animations object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/solution_animations/create").execute(*args, **kwargs)
                def clear_history(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/solution_animations/clear_history").execute(*args, **kwargs)
                def display(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/solution_animations/display").execute(*args, **kwargs)
                def add_to_graphics(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/solution_animations/add_to_graphics").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/solution_animations/list").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename solution-animations object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/solution_animations/rename").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/solution_animations/duplicate").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/solution_animations/copy").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete solution-animations object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/solution_animations/delete").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/solution_animations/list_properties").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit solution-animations object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/solution_animations/edit").execute(*args, **kwargs)

            class poor_mesh_numerics(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.register_based = self.__class__.register_based(service, version, mode, path + ["register_based"])
                    super().__init__(service, version, mode, path)

                class register_based(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def edit(self, *args, **kwargs):
                        """
                        Edit a definition for poor mesh numerics.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/poor_mesh_numerics/register_based/edit").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete a definition for poor mesh numerics.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/poor_mesh_numerics/register_based/delete").execute(*args, **kwargs)
                    def duplicate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/poor_mesh_numerics/register_based/duplicate").execute(*args, **kwargs)
                    def rename(self, *args, **kwargs):
                        """
                        Rename register-based object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/poor_mesh_numerics/register_based/rename").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/poor_mesh_numerics/register_based/list").execute(*args, **kwargs)
                    def set(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/poor_mesh_numerics/register_based/set").execute(*args, **kwargs)
                    def create(self, *args, **kwargs):
                        """
                        Add a new definition for poor mesh numerics.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/poor_mesh_numerics/register_based/create").execute(*args, **kwargs)
                    def list_properties(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/calculation_activity/poor_mesh_numerics/register_based/list_properties").execute(*args, **kwargs)

        class methods(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.vof_numerics = self.__class__.vof_numerics(service, version, mode, path + ["vof_numerics"])
                self.reduced_rank_extrapolation_options = self.__class__.reduced_rank_extrapolation_options(service, version, mode, path + ["reduced_rank_extrapolation_options"])
                self.warped_face_gradient_correction = self.__class__.warped_face_gradient_correction(service, version, mode, path + ["warped_face_gradient_correction"])
                self.residual_smoothing = self.__class__.residual_smoothing(service, version, mode, path + ["residual_smoothing"])
                self.flux_type = self.__class__.flux_type(service, version, mode, path + ["flux_type"])
                self.phase_based_vof_discretization = self.__class__.phase_based_vof_discretization(service, version, mode, path + ["phase_based_vof_discretization"])
                self.high_order_term_relaxation = self.__class__.high_order_term_relaxation(service, version, mode, path + ["high_order_term_relaxation"])
                self.discretization_scheme = self.__class__.discretization_scheme(service, version, mode, path + ["discretization_scheme"])
                self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                self.convergence_acceleration_for_stretched_meshes = self.__class__.convergence_acceleration_for_stretched_meshes(service, version, mode, path + ["convergence_acceleration_for_stretched_meshes"])
                self.multiphase_numerics = self.__class__.multiphase_numerics(service, version, mode, path + ["multiphase_numerics"])
                self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                self.nita_expert_controls = self.__class__.nita_expert_controls(service, version, mode, path + ["nita_expert_controls"])
                self.nb_gradient_boundary_option = self.__class__.nb_gradient_boundary_option(service, version, mode, path + ["nb_gradient_boundary_option"])
                self.pseudo_time_method = self.__class__.pseudo_time_method(service, version, mode, path + ["pseudo_time_method"])
                self.p_v_coupling = self.__class__.p_v_coupling(service, version, mode, path + ["p_v_coupling"])
                super().__init__(service, version, mode, path)
            def set_solution_methods_to_default(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/methods/set_solution_methods_to_default").execute(*args, **kwargs)
            def unsteady_1st_order(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/methods/unsteady_1st_order").execute(*args, **kwargs)
            def unsteady_global_time(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/methods/unsteady_global_time").execute(*args, **kwargs)
            def frozen_flux(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/methods/frozen_flux").execute(*args, **kwargs)
            def unsteady_2nd_order_bounded(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/methods/unsteady_2nd_order_bounded").execute(*args, **kwargs)
            def accelerated_non_iterative_time_marching(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/methods/accelerated_non_iterative_time_marching").execute(*args, **kwargs)
            def unsteady_2nd_order(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/methods/unsteady_2nd_order").execute(*args, **kwargs)
            def gradient_scheme(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/methods/gradient_scheme").execute(*args, **kwargs)
            def reduced_rank_extrapolation(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/methods/reduced_rank_extrapolation").execute(*args, **kwargs)
            def nita(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/methods/nita").execute(*args, **kwargs)

            class vof_numerics(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def new_framework_for_vof_specific_node_based_treatment(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/vof_numerics/new_framework_for_vof_specific_node_based_treatment").execute(*args, **kwargs)
                def unstructured_var_presto_scheme(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/vof_numerics/unstructured_var_presto_scheme").execute(*args, **kwargs)
                def high_order_rc_hybrid_treatment(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/vof_numerics/high_order_rc_hybrid_treatment").execute(*args, **kwargs)
                def high_order_rc(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/vof_numerics/high_order_rc").execute(*args, **kwargs)
                def force_treatment_of_unsteady_rc(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/vof_numerics/force_treatment_of_unsteady_rc").execute(*args, **kwargs)

            class reduced_rank_extrapolation_options(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def subspace_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/reduced_rank_extrapolation_options/subspace_size").execute(*args, **kwargs)
                def skip_iter_count(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/reduced_rank_extrapolation_options/skip_iter_count").execute(*args, **kwargs)

            class warped_face_gradient_correction(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def turbulence_options(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/warped_face_gradient_correction/turbulence_options").execute(*args, **kwargs)
                def enable(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/warped_face_gradient_correction/enable").execute(*args, **kwargs)

            class residual_smoothing(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def residual_smoothing_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/residual_smoothing/residual_smoothing_factor").execute(*args, **kwargs)
                def residual_smoothing_iter_count(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/residual_smoothing/residual_smoothing_iter_count").execute(*args, **kwargs)

            class flux_type(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.dbns_cases = self.__class__.dbns_cases(service, version, mode, path + ["dbns_cases"])
                    self.pbns_cases = self.__class__.pbns_cases(service, version, mode, path + ["pbns_cases"])
                    super().__init__(service, version, mode, path)

                class dbns_cases(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def flux_type(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/flux_type/dbns_cases/flux_type").execute(*args, **kwargs)

                class pbns_cases(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def flux_auto_select(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/flux_type/pbns_cases/flux_auto_select").execute(*args, **kwargs)
                    def flux_type(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/flux_type/pbns_cases/flux_type").execute(*args, **kwargs)

            class phase_based_vof_discretization(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def rename(self, *args, **kwargs):
                    """
                    Rename phase-based-vof-discretization object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/phase_based_vof_discretization/rename").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/phase_based_vof_discretization/list").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new phase-based-vof-discretization object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/phase_based_vof_discretization/create").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete phase-based-vof-discretization object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/phase_based_vof_discretization/delete").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/phase_based_vof_discretization/duplicate").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/phase_based_vof_discretization/list_properties").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit phase-based-vof-discretization object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/phase_based_vof_discretization/edit").execute(*args, **kwargs)

            class high_order_term_relaxation(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.options = self.__class__.options(service, version, mode, path + ["options"])
                    super().__init__(service, version, mode, path)
                def enable(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/high_order_term_relaxation/enable").execute(*args, **kwargs)

                class options(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def type(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/high_order_term_relaxation/options/type").execute(*args, **kwargs)
                    def relaxation_factor(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/high_order_term_relaxation/options/relaxation_factor").execute(*args, **kwargs)
                    def select_variables(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/high_order_term_relaxation/options/select_variables").execute(*args, **kwargs)

            class discretization_scheme(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/discretization_scheme/list").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename discretization-scheme object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/discretization_scheme/rename").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete discretization-scheme object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/discretization_scheme/delete").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/discretization_scheme/list_properties").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new discretization-scheme object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/discretization_scheme/create").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit discretization-scheme object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/discretization_scheme/edit").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/discretization_scheme/duplicate").execute(*args, **kwargs)

            class overset(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    super().__init__(service, version, mode, path)
                def orphan_cell_treatment(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/overset/orphan_cell_treatment").execute(*args, **kwargs)
                def high_order_pressure(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/overset/high_order_pressure").execute(*args, **kwargs)
                def interpolation_method(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/overset/interpolation_method").execute(*args, **kwargs)

                class expert(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def hybrid_mode_selection(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/overset/expert/hybrid_mode_selection").execute(*args, **kwargs)
                    def mass_flux_correction_method(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/overset/expert/mass_flux_correction_method").execute(*args, **kwargs)

            class convergence_acceleration_for_stretched_meshes(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def convergence_acceleration_type(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/convergence_acceleration_for_stretched_meshes/convergence_acceleration_type").execute(*args, **kwargs)
                def casm_cutoff_multiplier(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/convergence_acceleration_for_stretched_meshes/casm_cutoff_multiplier").execute(*args, **kwargs)

            class multiphase_numerics(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.porous_media = self.__class__.porous_media(service, version, mode, path + ["porous_media"])
                    self.compressible_flow = self.__class__.compressible_flow(service, version, mode, path + ["compressible_flow"])
                    self.advanced_stability_controls = self.__class__.advanced_stability_controls(service, version, mode, path + ["advanced_stability_controls"])
                    self.heat_mass_transfer = self.__class__.heat_mass_transfer(service, version, mode, path + ["heat_mass_transfer"])
                    self.boiling_parameters = self.__class__.boiling_parameters(service, version, mode, path + ["boiling_parameters"])
                    self.face_pressure_controls = self.__class__.face_pressure_controls(service, version, mode, path + ["face_pressure_controls"])
                    self.default_controls = self.__class__.default_controls(service, version, mode, path + ["default_controls"])
                    self.solution_stabilization = self.__class__.solution_stabilization(service, version, mode, path + ["solution_stabilization"])
                    self.viscous_flow = self.__class__.viscous_flow(service, version, mode, path + ["viscous_flow"])
                    super().__init__(service, version, mode, path)

                class porous_media(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def relative_permeability(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/porous_media/relative_permeability").execute(*args, **kwargs)
                    def capillary_pressure_as_diffusion(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/porous_media/capillary_pressure_as_diffusion").execute(*args, **kwargs)

                class compressible_flow(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def analytical_thermodynamic_derivatives(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/compressible_flow/analytical_thermodynamic_derivatives").execute(*args, **kwargs)
                    def alternate_bc_formulation(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/compressible_flow/alternate_bc_formulation").execute(*args, **kwargs)
                    def enhanced_numerics(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/compressible_flow/enhanced_numerics").execute(*args, **kwargs)

                class advanced_stability_controls(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.pseudo_transient = self.__class__.pseudo_transient(service, version, mode, path + ["pseudo_transient"])
                        self.anti_diffusion = self.__class__.anti_diffusion(service, version, mode, path + ["anti_diffusion"])
                        self.hybrid_nita = self.__class__.hybrid_nita(service, version, mode, path + ["hybrid_nita"])
                        self.p_v_coupling = self.__class__.p_v_coupling(service, version, mode, path + ["p_v_coupling"])
                        self.equation_order = self.__class__.equation_order(service, version, mode, path + ["equation_order"])
                        super().__init__(service, version, mode, path)

                    class pseudo_transient(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.auto_dt_advanced_controls = self.__class__.auto_dt_advanced_controls(service, version, mode, path + ["auto_dt_advanced_controls"])
                            super().__init__(service, version, mode, path)
                        def false_time_step_linearization(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_transient/false_time_step_linearization").execute(*args, **kwargs)
                        def smoothed_density_stabilization_method(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_transient/smoothed_density_stabilization_method").execute(*args, **kwargs)
                        def num_of_density_smoothing(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_transient/num_of_density_smoothing").execute(*args, **kwargs)

                        class auto_dt_advanced_controls(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def dt_init_limit(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_transient/auto_dt_advanced_controls/dt_init_limit").execute(*args, **kwargs)
                            def dt_factor_max(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_transient/auto_dt_advanced_controls/dt_factor_max").execute(*args, **kwargs)
                            def dt_factor_min(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_transient/auto_dt_advanced_controls/dt_factor_min").execute(*args, **kwargs)
                            def dt_max(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_transient/auto_dt_advanced_controls/dt_max").execute(*args, **kwargs)
                            def enable(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_transient/auto_dt_advanced_controls/enable").execute(*args, **kwargs)
                            def max_velocity_ratio(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_transient/auto_dt_advanced_controls/max_velocity_ratio").execute(*args, **kwargs)

                    class anti_diffusion(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def set_maximum_dynamic_strength(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/anti_diffusion/set_maximum_dynamic_strength").execute(*args, **kwargs)
                        def set_dynamic_strength_exponent(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/anti_diffusion/set_dynamic_strength_exponent").execute(*args, **kwargs)
                        def enable_dynamic_strength(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/anti_diffusion/enable_dynamic_strength").execute(*args, **kwargs)

                    class hybrid_nita(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.instability_detector = self.__class__.instability_detector(service, version, mode, path + ["instability_detector"])
                            self.initial_outer_iterations = self.__class__.initial_outer_iterations(service, version, mode, path + ["initial_outer_iterations"])
                            super().__init__(service, version, mode, path)
                        def outer_iterations(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/hybrid_nita/outer_iterations").execute(*args, **kwargs)

                        class instability_detector(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def unstable_event_outer_iterations(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/unstable_event_outer_iterations").execute(*args, **kwargs)
                            def set_cfl_type(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/set_cfl_type").execute(*args, **kwargs)
                            def enable_instability_detector(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/enable_instability_detector").execute(*args, **kwargs)
                            def set_velocity_limit(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/set_velocity_limit").execute(*args, **kwargs)
                            def set_cfl_limit(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/set_cfl_limit").execute(*args, **kwargs)

                        class initial_outer_iterations(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def initial_time_steps(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/hybrid_nita/initial_outer_iterations/initial_time_steps").execute(*args, **kwargs)
                            def initial_outer_iter(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/hybrid_nita/initial_outer_iterations/initial_outer_iter").execute(*args, **kwargs)

                    class p_v_coupling(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.skewness_correction = self.__class__.skewness_correction(service, version, mode, path + ["skewness_correction"])
                            self.rhie_chow_flux = self.__class__.rhie_chow_flux(service, version, mode, path + ["rhie_chow_flux"])
                            self.coupled_vof = self.__class__.coupled_vof(service, version, mode, path + ["coupled_vof"])
                            super().__init__(service, version, mode, path)

                        class skewness_correction(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def limit_pressure_correction_gradient(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/p_v_coupling/skewness_correction/limit_pressure_correction_gradient").execute(*args, **kwargs)

                        class rhie_chow_flux(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def low_order_rhie_chow(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/p_v_coupling/rhie_chow_flux/low_order_rhie_chow").execute(*args, **kwargs)

                        class coupled_vof(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def blended_treatment_for_buoyancy_forces(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/p_v_coupling/coupled_vof/blended_treatment_for_buoyancy_forces").execute(*args, **kwargs)
                            def buoyancy_force_linearization(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/p_v_coupling/coupled_vof/buoyancy_force_linearization").execute(*args, **kwargs)

                    class equation_order(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def solve_flow_last(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/equation_order/solve_flow_last").execute(*args, **kwargs)
                        def solve_exp_vof_at_end(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/advanced_stability_controls/equation_order/solve_exp_vof_at_end").execute(*args, **kwargs)

                class heat_mass_transfer(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.area_density = self.__class__.area_density(service, version, mode, path + ["area_density"])
                        self.boiling = self.__class__.boiling(service, version, mode, path + ["boiling"])
                        self.evaporation_condensation = self.__class__.evaporation_condensation(service, version, mode, path + ["evaporation_condensation"])
                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                        super().__init__(service, version, mode, path)
                    def alternative_energy_treatment(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/alternative_energy_treatment").execute(*args, **kwargs)

                    class area_density(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def vof_min_seeding(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/area_density/vof_min_seeding").execute(*args, **kwargs)
                        def ia_grad_sym(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/area_density/ia_grad_sym").execute(*args, **kwargs)

                    class boiling(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def heat_flux_relaxation_factor(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/boiling/heat_flux_relaxation_factor").execute(*args, **kwargs)
                        def show_expert_options(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/boiling/show_expert_options").execute(*args, **kwargs)
                        def two_resistance_boiling_framework(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/boiling/two_resistance_boiling_framework").execute(*args, **kwargs)

                    class evaporation_condensation(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def vof_to_min_limit(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/evaporation_condensation/vof_to_min_limit").execute(*args, **kwargs)
                        def vof_from_min_limit(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/evaporation_condensation/vof_from_min_limit").execute(*args, **kwargs)
                        def vof_to_max_limit(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/evaporation_condensation/vof_to_max_limit").execute(*args, **kwargs)
                        def max_rel_humidity(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/evaporation_condensation/max_rel_humidity").execute(*args, **kwargs)
                        def ia_norm_min_limit(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/evaporation_condensation/ia_norm_min_limit").execute(*args, **kwargs)
                        def vof_from_max_limit(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/evaporation_condensation/vof_from_max_limit").execute(*args, **kwargs)

                    class cavitation(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def min_vapor_pressure(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/cavitation/min_vapor_pressure").execute(*args, **kwargs)
                        def turbulent_diffusion(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/cavitation/turbulent_diffusion").execute(*args, **kwargs)
                        def schnerr_cond_coeff(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/cavitation/schnerr_cond_coeff").execute(*args, **kwargs)
                        def old_treatment_for_turbulent_diffusion(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/cavitation/old_treatment_for_turbulent_diffusion").execute(*args, **kwargs)
                        def display_clipped_pressure(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/cavitation/display_clipped_pressure").execute(*args, **kwargs)
                        def max_vapor_pressure_ratio(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/cavitation/max_vapor_pressure_ratio").execute(*args, **kwargs)
                        def schnerr_evap_coeff(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/heat_mass_transfer/cavitation/schnerr_evap_coeff").execute(*args, **kwargs)

                class boiling_parameters(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def thin_film(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/boiling_parameters/thin_film").execute(*args, **kwargs)
                    def liquid_vof_factor(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/boiling_parameters/liquid_vof_factor").execute(*args, **kwargs)

                class face_pressure_controls(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.face_pressure_options = self.__class__.face_pressure_options(service, version, mode, path + ["face_pressure_options"])
                        super().__init__(service, version, mode, path)

                    class face_pressure_options(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def face_pressure_calculation_method(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/face_pressure_controls/face_pressure_options/face_pressure_calculation_method").execute(*args, **kwargs)
                        def pressure_corr_grad(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/face_pressure_controls/face_pressure_options/pressure_corr_grad").execute(*args, **kwargs)
                        def exclude_transient_term_in_face_pressure_calc(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/face_pressure_controls/face_pressure_options/exclude_transient_term_in_face_pressure_calc").execute(*args, **kwargs)

                class default_controls(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.revert_to_pre_r20_point_1_default_settings = self.__class__.revert_to_pre_r20_point_1_default_settings(service, version, mode, path + ["revert_to_pre_r20_point_1_default_settings"])
                        super().__init__(service, version, mode, path)
                    def recommended_defaults_for_existing_cases(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/default_controls/recommended_defaults_for_existing_cases").execute(*args, **kwargs)

                    class revert_to_pre_r20_point_1_default_settings(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def old_default_of_volume_fraction_smoothing(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/default_controls/revert_to_pre_r20_point_1_default_settings/old_default_of_volume_fraction_smoothing").execute(*args, **kwargs)
                        def old_variant_of_pesto_for_cases_using_structured_mesh(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/default_controls/revert_to_pre_r20_point_1_default_settings/old_variant_of_pesto_for_cases_using_structured_mesh").execute(*args, **kwargs)
                        def old_default_of_operating_density_method(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/default_controls/revert_to_pre_r20_point_1_default_settings/old_default_of_operating_density_method").execute(*args, **kwargs)

                class solution_stabilization(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.additional_stabilization_controls = self.__class__.additional_stabilization_controls(service, version, mode, path + ["additional_stabilization_controls"])
                        self.velocity_limiting_treatment = self.__class__.velocity_limiting_treatment(service, version, mode, path + ["velocity_limiting_treatment"])
                        super().__init__(service, version, mode, path)
                    def execute_advanced_stabilization(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/execute_advanced_stabilization").execute(*args, **kwargs)
                    def execute_settings_optimization(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/execute_settings_optimization").execute(*args, **kwargs)
                    def execute_additional_stability_controls(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/execute_additional_stability_controls").execute(*args, **kwargs)

                    class additional_stabilization_controls(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def blended_compressive_scheme(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/additional_stabilization_controls/blended_compressive_scheme").execute(*args, **kwargs)
                        def pseudo_time_stabilization(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/additional_stabilization_controls/pseudo_time_stabilization").execute(*args, **kwargs)

                    class velocity_limiting_treatment(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.set_velocity_and_vof_cutoffs = self.__class__.set_velocity_and_vof_cutoffs(service, version, mode, path + ["set_velocity_and_vof_cutoffs"])
                            self.set_damping_strengths = self.__class__.set_damping_strengths(service, version, mode, path + ["set_damping_strengths"])
                            super().__init__(service, version, mode, path)
                        def set_velocity_cutoff(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_velocity_cutoff").execute(*args, **kwargs)
                        def verbosity(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/verbosity").execute(*args, **kwargs)
                        def set_damping_strength(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_damping_strength").execute(*args, **kwargs)
                        def enable_velocity_limiting(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/enable_velocity_limiting").execute(*args, **kwargs)

                        class set_velocity_and_vof_cutoffs(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def edit(self, *args, **kwargs):
                                """
                                Edit set-velocity-and-vof-cutoffs object.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_velocity_and_vof_cutoffs/edit").execute(*args, **kwargs)
                            def duplicate(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_velocity_and_vof_cutoffs/duplicate").execute(*args, **kwargs)
                            def delete(self, *args, **kwargs):
                                """
                                Delete set-velocity-and-vof-cutoffs object.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_velocity_and_vof_cutoffs/delete").execute(*args, **kwargs)
                            def list_properties(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_velocity_and_vof_cutoffs/list_properties").execute(*args, **kwargs)
                            def list(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_velocity_and_vof_cutoffs/list").execute(*args, **kwargs)
                            def rename(self, *args, **kwargs):
                                """
                                Rename set-velocity-and-vof-cutoffs object.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_velocity_and_vof_cutoffs/rename").execute(*args, **kwargs)
                            def create(self, *args, **kwargs):
                                """
                                Create a new set-velocity-and-vof-cutoffs object.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_velocity_and_vof_cutoffs/create").execute(*args, **kwargs)

                        class set_damping_strengths(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def duplicate(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_damping_strengths/duplicate").execute(*args, **kwargs)
                            def rename(self, *args, **kwargs):
                                """
                                Rename set-damping-strengths object.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_damping_strengths/rename").execute(*args, **kwargs)
                            def delete(self, *args, **kwargs):
                                """
                                Delete set-damping-strengths object.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_damping_strengths/delete").execute(*args, **kwargs)
                            def create(self, *args, **kwargs):
                                """
                                Create a new set-damping-strengths object.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_damping_strengths/create").execute(*args, **kwargs)
                            def edit(self, *args, **kwargs):
                                """
                                Edit set-damping-strengths object.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_damping_strengths/edit").execute(*args, **kwargs)
                            def list(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_damping_strengths/list").execute(*args, **kwargs)
                            def list_properties(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_damping_strengths/list_properties").execute(*args, **kwargs)

                class viscous_flow(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.interfacial_artificial_viscosity = self.__class__.interfacial_artificial_viscosity(service, version, mode, path + ["interfacial_artificial_viscosity"])
                        super().__init__(service, version, mode, path)
                    def density_func_expo(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/viscous_flow/density_func_expo").execute(*args, **kwargs)
                    def viscosity_averaging(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/viscous_flow/viscosity_averaging").execute(*args, **kwargs)
                    def density_ratio_cutoff(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/viscous_flow/density_ratio_cutoff").execute(*args, **kwargs)
                    def turb_visc_based_damping(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/viscous_flow/turb_visc_based_damping").execute(*args, **kwargs)

                    class interfacial_artificial_viscosity(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def boundry_treatment(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/viscous_flow/interfacial_artificial_viscosity/boundry_treatment").execute(*args, **kwargs)
                        def exponent_density_func(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/viscous_flow/interfacial_artificial_viscosity/exponent_density_func").execute(*args, **kwargs)
                        def viscous_func_options(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/viscous_flow/interfacial_artificial_viscosity/viscous_func_options").execute(*args, **kwargs)
                        def exponent_smoothing_func(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/viscous_flow/interfacial_artificial_viscosity/exponent_smoothing_func").execute(*args, **kwargs)
                        def n_smooth_for_interfacial_regims(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/viscous_flow/interfacial_artificial_viscosity/n_smooth_for_interfacial_regims").execute(*args, **kwargs)
                        def sm_relax_factor(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/viscous_flow/interfacial_artificial_viscosity/sm_relax_factor").execute(*args, **kwargs)
                        def density_func_options(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/viscous_flow/interfacial_artificial_viscosity/density_func_options").execute(*args, **kwargs)
                        def near_wall_treatment(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/multiphase_numerics/viscous_flow/interfacial_artificial_viscosity/near_wall_treatment").execute(*args, **kwargs)

            class expert(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.numerics_dbns = self.__class__.numerics_dbns(service, version, mode, path + ["numerics_dbns"])
                    self.numerics_pbns = self.__class__.numerics_pbns(service, version, mode, path + ["numerics_pbns"])
                    super().__init__(service, version, mode, path)
                def reaction_source_term_relaxation_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/expert/reaction_source_term_relaxation_factor").execute(*args, **kwargs)
                def reactions(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/expert/reactions").execute(*args, **kwargs)

                class numerics_dbns(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def first_to_second_order_blending_dbns(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/expert/numerics_dbns/first_to_second_order_blending_dbns").execute(*args, **kwargs)

                class numerics_pbns(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def presto_pressure_scheme(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/expert/numerics_pbns/presto_pressure_scheme").execute(*args, **kwargs)
                    def first_to_second_order_blending(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/expert/numerics_pbns/first_to_second_order_blending").execute(*args, **kwargs)
                    def implicit_bodyforce_treatment(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/expert/numerics_pbns/implicit_bodyforce_treatment").execute(*args, **kwargs)
                    def physical_velocity_formulation(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/expert/numerics_pbns/physical_velocity_formulation").execute(*args, **kwargs)
                    def disable_rhie_chow_flux(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/expert/numerics_pbns/disable_rhie_chow_flux").execute(*args, **kwargs)
                    def velocity_formulation(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/expert/numerics_pbns/velocity_formulation").execute(*args, **kwargs)
                    def alternate_diffusion_for_porous_region_solids(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/expert/numerics_pbns/alternate_diffusion_for_porous_region_solids").execute(*args, **kwargs)

            class nita_expert_controls(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.hybrid_nita_settings = self.__class__.hybrid_nita_settings(service, version, mode, path + ["hybrid_nita_settings"])
                    super().__init__(service, version, mode, path)
                def verbosity(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/nita_expert_controls/verbosity").execute(*args, **kwargs)
                def skewness_neighbor_coupling(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/nita_expert_controls/skewness_neighbor_coupling").execute(*args, **kwargs)

                class hybrid_nita_settings(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.multi_phase_setting = self.__class__.multi_phase_setting(service, version, mode, path + ["multi_phase_setting"])
                        super().__init__(service, version, mode, path)
                    def single_phase_setting(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/nita_expert_controls/hybrid_nita_settings/single_phase_setting").execute(*args, **kwargs)

                    class multi_phase_setting(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def enable(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/nita_expert_controls/hybrid_nita_settings/multi_phase_setting/enable").execute(*args, **kwargs)
                        def options(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/methods/nita_expert_controls/hybrid_nita_settings/multi_phase_setting/options").execute(*args, **kwargs)

            class nb_gradient_boundary_option(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def nb_gradient(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/nb_gradient_boundary_option/nb_gradient").execute(*args, **kwargs)
                def nb_gradient_dbns(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/nb_gradient_boundary_option/nb_gradient_dbns").execute(*args, **kwargs)

            class pseudo_time_method(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.formulation = self.__class__.formulation(service, version, mode, path + ["formulation"])
                    self.convergence_acceleration_for_stretched_meshes = self.__class__.convergence_acceleration_for_stretched_meshes(service, version, mode, path + ["convergence_acceleration_for_stretched_meshes"])
                    super().__init__(service, version, mode, path)
                def relaxation_method(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/pseudo_time_method/relaxation_method").execute(*args, **kwargs)
                def relaxation_bounds(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/pseudo_time_method/relaxation_bounds").execute(*args, **kwargs)

                class formulation(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def density_based_solver(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/pseudo_time_method/formulation/density_based_solver").execute(*args, **kwargs)
                    def coupled_solver(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/pseudo_time_method/formulation/coupled_solver").execute(*args, **kwargs)
                    def segregated_solver(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/pseudo_time_method/formulation/segregated_solver").execute(*args, **kwargs)

                class convergence_acceleration_for_stretched_meshes(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def casm_cutoff_multiplier(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/pseudo_time_method/convergence_acceleration_for_stretched_meshes/casm_cutoff_multiplier").execute(*args, **kwargs)
                    def convergence_acceleration_type(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/methods/pseudo_time_method/convergence_acceleration_for_stretched_meshes/convergence_acceleration_type").execute(*args, **kwargs)

            class p_v_coupling(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def coupled_form(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/p_v_coupling/coupled_form").execute(*args, **kwargs)
                def flow_scheme(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/p_v_coupling/flow_scheme").execute(*args, **kwargs)
                def solve_n_phase(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/methods/p_v_coupling/solve_n_phase").execute(*args, **kwargs)

        class run_calculation(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.data_sampling = self.__class__.data_sampling(service, version, mode, path + ["data_sampling"])
                self.adaptive_time_stepping = self.__class__.adaptive_time_stepping(service, version, mode, path + ["adaptive_time_stepping"])
                self.transient_controls = self.__class__.transient_controls(service, version, mode, path + ["transient_controls"])
                self.pseudo_time_settings = self.__class__.pseudo_time_settings(service, version, mode, path + ["pseudo_time_settings"])
                self.cfl_based_adaptive_time_stepping = self.__class__.cfl_based_adaptive_time_stepping(service, version, mode, path + ["cfl_based_adaptive_time_stepping"])
                self.data_sampling_options = self.__class__.data_sampling_options(service, version, mode, path + ["data_sampling_options"])
                super().__init__(service, version, mode, path)
            def calculate(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/calculate").execute(*args, **kwargs)
            def iterate(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/iterate").execute(*args, **kwargs)
            def dual_time_iterate(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/dual_time_iterate").execute(*args, **kwargs)
            def residual_verbosity(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/residual_verbosity").execute(*args, **kwargs)
            def interrupt(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/interrupt").execute(*args, **kwargs)
            def time_step_count(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/time_step_count").execute(*args, **kwargs)
            def iter_count(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/iter_count").execute(*args, **kwargs)
            def reporting_interval(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/reporting_interval").execute(*args, **kwargs)

            class data_sampling(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def time_statistics_dpm(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/data_sampling/time_statistics_dpm").execute(*args, **kwargs)
                def save_cff_unsteady_statistics(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/data_sampling/save_cff_unsteady_statistics").execute(*args, **kwargs)
                def statistics_heat_flux(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/data_sampling/statistics_heat_flux").execute(*args, **kwargs)
                def statistics_reaction_progress(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/data_sampling/statistics_reaction_progress").execute(*args, **kwargs)
                def species_list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/data_sampling/species_list").execute(*args, **kwargs)
                def statistics_shear_stress(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/data_sampling/statistics_shear_stress").execute(*args, **kwargs)
                def udf_cf_names(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/data_sampling/udf_cf_names").execute(*args, **kwargs)
                def data_sampling(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/data_sampling/data_sampling").execute(*args, **kwargs)
                def sampling_interval(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/data_sampling/sampling_interval").execute(*args, **kwargs)
                def wall_statistics(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/data_sampling/wall_statistics").execute(*args, **kwargs)
                def statistics_mixture_fraction(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/data_sampling/statistics_mixture_fraction").execute(*args, **kwargs)
                def force_statistics(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/data_sampling/force_statistics").execute(*args, **kwargs)

            class adaptive_time_stepping(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def min_step_change_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/adaptive_time_stepping/min_step_change_factor").execute(*args, **kwargs)
                def max_step_change_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/adaptive_time_stepping/max_step_change_factor").execute(*args, **kwargs)
                def error_tolerance(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/adaptive_time_stepping/error_tolerance").execute(*args, **kwargs)
                def min_time_step(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/adaptive_time_stepping/min_time_step").execute(*args, **kwargs)
                def max_time_step(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/adaptive_time_stepping/max_time_step").execute(*args, **kwargs)
                def time_end(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/adaptive_time_stepping/time_end").execute(*args, **kwargs)
                def enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/adaptive_time_stepping/enabled").execute(*args, **kwargs)
                def fixed_time_step_count(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/adaptive_time_stepping/fixed_time_step_count").execute(*args, **kwargs)
                def user_defined_timestep(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/adaptive_time_stepping/user_defined_timestep").execute(*args, **kwargs)

            class transient_controls(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.mp_specific_time_stepping = self.__class__.mp_specific_time_stepping(service, version, mode, path + ["mp_specific_time_stepping"])
                    self.cfl_based_time_stepping = self.__class__.cfl_based_time_stepping(service, version, mode, path + ["cfl_based_time_stepping"])
                    self.solid_time_step_size = self.__class__.solid_time_step_size(service, version, mode, path + ["solid_time_step_size"])
                    self.multiphase_specific_time_constraints = self.__class__.multiphase_specific_time_constraints(service, version, mode, path + ["multiphase_specific_time_constraints"])
                    self.extrapolate_eqn_vars = self.__class__.extrapolate_eqn_vars(service, version, mode, path + ["extrapolate_eqn_vars"])
                    self.error_based_time_stepping = self.__class__.error_based_time_stepping(service, version, mode, path + ["error_based_time_stepping"])
                    self.fixed_periodic = self.__class__.fixed_periodic(service, version, mode, path + ["fixed_periodic"])
                    super().__init__(service, version, mode, path)
                def solution_status(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/solution_status").execute(*args, **kwargs)
                def incremental_time(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/incremental_time").execute(*args, **kwargs)
                def time_step_size_for_acoustic_export(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/time_step_size_for_acoustic_export").execute(*args, **kwargs)
                def type(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/type").execute(*args, **kwargs)
                def undo_timestep(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/undo_timestep").execute(*args, **kwargs)
                def total_time(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/total_time").execute(*args, **kwargs)
                def use_average_cfl(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/use_average_cfl").execute(*args, **kwargs)
                def total_time_step_count(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/total_time_step_count").execute(*args, **kwargs)
                def time_step_count(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/time_step_count").execute(*args, **kwargs)
                def time_step_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/time_step_size").execute(*args, **kwargs)
                def specified_time_step(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/specified_time_step").execute(*args, **kwargs)
                def max_iter_per_time_step(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/max_iter_per_time_step").execute(*args, **kwargs)
                def predict_next(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/predict_next").execute(*args, **kwargs)
                def cfl_type(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/cfl_type").execute(*args, **kwargs)
                def method(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/method").execute(*args, **kwargs)
                def duration_specification_method(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/duration_specification_method").execute(*args, **kwargs)
                def rotating_mesh_flow_predictor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/rotating_mesh_flow_predictor").execute(*args, **kwargs)
                def max_flow_time(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/max_flow_time").execute(*args, **kwargs)
                def control_time_step_size_variation(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/control_time_step_size_variation").execute(*args, **kwargs)
                def udf_hook(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/udf_hook").execute(*args, **kwargs)
                def extrapolate_vars(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/extrapolate_vars").execute(*args, **kwargs)

                class mp_specific_time_stepping(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def global_courant_number(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/mp_specific_time_stepping/global_courant_number").execute(*args, **kwargs)
                    def min_step_change_factor(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/mp_specific_time_stepping/min_step_change_factor").execute(*args, **kwargs)
                    def update_interval(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/mp_specific_time_stepping/update_interval").execute(*args, **kwargs)
                    def max_time_step_size(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/mp_specific_time_stepping/max_time_step_size").execute(*args, **kwargs)
                    def min_time_step_size(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/mp_specific_time_stepping/min_time_step_size").execute(*args, **kwargs)
                    def initial_time_step_size(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/mp_specific_time_stepping/initial_time_step_size").execute(*args, **kwargs)
                    def fixed_time_step_size(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/mp_specific_time_stepping/fixed_time_step_size").execute(*args, **kwargs)
                    def max_step_change_factor(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/mp_specific_time_stepping/max_step_change_factor").execute(*args, **kwargs)
                    def enabled(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/mp_specific_time_stepping/enabled").execute(*args, **kwargs)

                class cfl_based_time_stepping(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def min_time_step_size(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/cfl_based_time_stepping/min_time_step_size").execute(*args, **kwargs)
                    def courant_number(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/cfl_based_time_stepping/courant_number").execute(*args, **kwargs)
                    def max_step_change_factor(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/cfl_based_time_stepping/max_step_change_factor").execute(*args, **kwargs)
                    def fixed_time_step_size(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/cfl_based_time_stepping/fixed_time_step_size").execute(*args, **kwargs)
                    def max_time_step_size(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/cfl_based_time_stepping/max_time_step_size").execute(*args, **kwargs)
                    def initial_time_step_size(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/cfl_based_time_stepping/initial_time_step_size").execute(*args, **kwargs)
                    def min_step_change_factor(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/cfl_based_time_stepping/min_step_change_factor").execute(*args, **kwargs)
                    def update_interval(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/cfl_based_time_stepping/update_interval").execute(*args, **kwargs)

                class solid_time_step_size(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def time_step_size(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/solid_time_step_size/time_step_size").execute(*args, **kwargs)
                    def enable_solid_time_step(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/solid_time_step_size/enable_solid_time_step").execute(*args, **kwargs)
                    def choose_auto_time_stepping(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/solid_time_step_size/choose_auto_time_stepping").execute(*args, **kwargs)

                class multiphase_specific_time_constraints(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.time_scale_options = self.__class__.time_scale_options(service, version, mode, path + ["time_scale_options"])
                        self.moving_mesh_cfl_constraint = self.__class__.moving_mesh_cfl_constraint(service, version, mode, path + ["moving_mesh_cfl_constraint"])
                        super().__init__(service, version, mode, path)
                    def verbosity(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/multiphase_specific_time_constraints/verbosity").execute(*args, **kwargs)
                    def physics_based_constraint(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/multiphase_specific_time_constraints/physics_based_constraint").execute(*args, **kwargs)

                    class time_scale_options(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def acoustic_scale(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/multiphase_specific_time_constraints/time_scale_options/acoustic_scale").execute(*args, **kwargs)
                        def surface_tension_scale(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/multiphase_specific_time_constraints/time_scale_options/surface_tension_scale").execute(*args, **kwargs)
                        def viscous_scale(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/multiphase_specific_time_constraints/time_scale_options/viscous_scale").execute(*args, **kwargs)
                        def gravity_scale(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/multiphase_specific_time_constraints/time_scale_options/gravity_scale").execute(*args, **kwargs)

                    class moving_mesh_cfl_constraint(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def moving_mesh_constraint(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/multiphase_specific_time_constraints/moving_mesh_cfl_constraint/moving_mesh_constraint").execute(*args, **kwargs)
                        def mesh_courant_number(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/multiphase_specific_time_constraints/moving_mesh_cfl_constraint/mesh_courant_number").execute(*args, **kwargs)

                class extrapolate_eqn_vars(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def duplicate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/extrapolate_eqn_vars/duplicate").execute(*args, **kwargs)
                    def create(self, *args, **kwargs):
                        """
                        Create a new extrapolate-eqn-vars object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/extrapolate_eqn_vars/create").execute(*args, **kwargs)
                    def edit(self, *args, **kwargs):
                        """
                        Edit extrapolate-eqn-vars object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/extrapolate_eqn_vars/edit").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete extrapolate-eqn-vars object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/extrapolate_eqn_vars/delete").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/extrapolate_eqn_vars/list").execute(*args, **kwargs)
                    def list_properties(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/extrapolate_eqn_vars/list_properties").execute(*args, **kwargs)
                    def rename(self, *args, **kwargs):
                        """
                        Rename extrapolate-eqn-vars object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/extrapolate_eqn_vars/rename").execute(*args, **kwargs)

                class error_based_time_stepping(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def fixed_time_step_size(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/error_based_time_stepping/fixed_time_step_size").execute(*args, **kwargs)
                    def error_tolerance(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/error_based_time_stepping/error_tolerance").execute(*args, **kwargs)
                    def max_step_change_factor(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/error_based_time_stepping/max_step_change_factor").execute(*args, **kwargs)
                    def initial_time_step_size(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/error_based_time_stepping/initial_time_step_size").execute(*args, **kwargs)
                    def min_step_change_factor(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/error_based_time_stepping/min_step_change_factor").execute(*args, **kwargs)
                    def min_time_step_size(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/error_based_time_stepping/min_time_step_size").execute(*args, **kwargs)
                    def update_interval(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/error_based_time_stepping/update_interval").execute(*args, **kwargs)
                    def max_time_step_size(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/error_based_time_stepping/max_time_step_size").execute(*args, **kwargs)

                class fixed_periodic(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def fixed_periodic_type_value(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/fixed_periodic/fixed_periodic_type_value").execute(*args, **kwargs)
                    def fixed_periodic_type(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/fixed_periodic/fixed_periodic_type").execute(*args, **kwargs)
                    def total_period_run(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/fixed_periodic/total_period_run").execute(*args, **kwargs)
                    def fixed_periodic(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/fixed_periodic/fixed_periodic").execute(*args, **kwargs)
                    def times_step_periods(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/transient_controls/fixed_periodic/times_step_periods").execute(*args, **kwargs)

            class pseudo_time_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.time_step_method = self.__class__.time_step_method(service, version, mode, path + ["time_step_method"])
                    super().__init__(service, version, mode, path)
                def verbosity(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/pseudo_time_settings/verbosity").execute(*args, **kwargs)

                class time_step_method(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def time_step_size_scale_factor(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/pseudo_time_settings/time_step_method/time_step_size_scale_factor").execute(*args, **kwargs)
                    def length_scale(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/pseudo_time_settings/time_step_method/length_scale").execute(*args, **kwargs)
                    def time_step_size_for_solid_zone(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/pseudo_time_settings/time_step_method/time_step_size_for_solid_zone").execute(*args, **kwargs)
                    def length_scale_methods(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/pseudo_time_settings/time_step_method/length_scale_methods").execute(*args, **kwargs)
                    def auto_time_size_calc_solid_zone(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/pseudo_time_settings/time_step_method/auto_time_size_calc_solid_zone").execute(*args, **kwargs)
                    def pseudo_time_step_size(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/pseudo_time_settings/time_step_method/pseudo_time_step_size").execute(*args, **kwargs)
                    def time_solid_scale_factor(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/pseudo_time_settings/time_step_method/time_solid_scale_factor").execute(*args, **kwargs)
                    def time_step_method(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/pseudo_time_settings/time_step_method/time_step_method").execute(*args, **kwargs)

            class cfl_based_adaptive_time_stepping(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def max_fixed_time_step(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/cfl_based_adaptive_time_stepping/max_fixed_time_step").execute(*args, **kwargs)
                def min_step_change_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/cfl_based_adaptive_time_stepping/min_step_change_factor").execute(*args, **kwargs)
                def update_interval_time_step_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/cfl_based_adaptive_time_stepping/update_interval_time_step_size").execute(*args, **kwargs)
                def time_end(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/cfl_based_adaptive_time_stepping/time_end").execute(*args, **kwargs)
                def desired_cfl(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/cfl_based_adaptive_time_stepping/desired_cfl").execute(*args, **kwargs)
                def min_time_step(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/cfl_based_adaptive_time_stepping/min_time_step").execute(*args, **kwargs)
                def max_step_change_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/cfl_based_adaptive_time_stepping/max_step_change_factor").execute(*args, **kwargs)
                def max_time_step(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/cfl_based_adaptive_time_stepping/max_time_step").execute(*args, **kwargs)
                def user_defined_timestep(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/cfl_based_adaptive_time_stepping/user_defined_timestep").execute(*args, **kwargs)
                def initial_time_step(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/cfl_based_adaptive_time_stepping/initial_time_step").execute(*args, **kwargs)
                def enalbled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/cfl_based_adaptive_time_stepping/enalbled").execute(*args, **kwargs)

            class data_sampling_options(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def list_datasets(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/data_sampling_options/list_datasets").execute(*args, **kwargs)
                def remove_dataset(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/run_calculation/data_sampling_options/remove_dataset").execute(*args, **kwargs)

        class initialization(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.localized_turb_init = self.__class__.localized_turb_init(service, version, mode, path + ["localized_turb_init"])
                self.fmg_initialization = self.__class__.fmg_initialization(service, version, mode, path + ["fmg_initialization"])
                self.fmg_options = self.__class__.fmg_options(service, version, mode, path + ["fmg_options"])
                self.open_channel_auto_init = self.__class__.open_channel_auto_init(service, version, mode, path + ["open_channel_auto_init"])
                self.patch = self.__class__.patch(service, version, mode, path + ["patch"])
                self.defaults = self.__class__.defaults(service, version, mode, path + ["defaults"])
                self.hybrid_init_options = self.__class__.hybrid_init_options(service, version, mode, path + ["hybrid_init_options"])
                super().__init__(service, version, mode, path)
            def show_time_sampled(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/initialization/show_time_sampled").execute(*args, **kwargs)
            def init_flow_statistics(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/initialization/init_flow_statistics").execute(*args, **kwargs)
            def compute_defaults(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/initialization/compute_defaults").execute(*args, **kwargs)
            def reference_frame(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/initialization/reference_frame").execute(*args, **kwargs)
            def hybrid_initialize(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_initialize").execute(*args, **kwargs)
            def init_turb_vel_fluctuations(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/initialization/init_turb_vel_fluctuations").execute(*args, **kwargs)
            def levelset_auto_init(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/initialization/levelset_auto_init").execute(*args, **kwargs)
            def lwf_reset(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/initialization/lwf_reset").execute(*args, **kwargs)
            def show_iterations_sampled(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/initialization/show_iterations_sampled").execute(*args, **kwargs)
            def init_acoustics_options(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/initialization/init_acoustics_options").execute(*args, **kwargs)
            def dpm_reset(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/initialization/dpm_reset").execute(*args, **kwargs)
            def initialize(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/initialization/initialize").execute(*args, **kwargs)
            def list_defaults(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/initialization/list_defaults").execute(*args, **kwargs)
            def fmg_initialize(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/initialization/fmg_initialize").execute(*args, **kwargs)
            def initialization_type(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/initialization/initialization_type").execute(*args, **kwargs)
            def standard_initialize(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/initialization/standard_initialize").execute(*args, **kwargs)

            class localized_turb_init(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/localized_turb_init/enabled").execute(*args, **kwargs)
                def turbulent_viscosity_ratio(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/localized_turb_init/turbulent_viscosity_ratio").execute(*args, **kwargs)
                def turbulent_intensity(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/localized_turb_init/turbulent_intensity").execute(*args, **kwargs)

            class fmg_initialization(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def fmg_courant_number(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/fmg_initialization/fmg_courant_number").execute(*args, **kwargs)
                def customize_fmg_initialization(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/fmg_initialization/customize_fmg_initialization").execute(*args, **kwargs)
                def enable_fmg_verbose(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/fmg_initialization/enable_fmg_verbose").execute(*args, **kwargs)

            class fmg_options(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def viscous_terms(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/fmg_options/viscous_terms").execute(*args, **kwargs)
                def reset_to_defaults(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/fmg_options/reset_to_defaults").execute(*args, **kwargs)
                def species_reactions(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/fmg_options/species_reactions").execute(*args, **kwargs)
                def set_turbulent_viscosity_ratio(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/fmg_options/set_turbulent_viscosity_ratio").execute(*args, **kwargs)

            class open_channel_auto_init(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def boundary_thread(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/open_channel_auto_init/boundary_thread").execute(*args, **kwargs)
                def flat_init(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/open_channel_auto_init/flat_init").execute(*args, **kwargs)
                def wavy_surface_init(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/open_channel_auto_init/wavy_surface_init").execute(*args, **kwargs)

            class patch(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.vof_smooth_options = self.__class__.vof_smooth_options(service, version, mode, path + ["vof_smooth_options"])
                    super().__init__(service, version, mode, path)
                def calculate_patch(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/patch/calculate_patch").execute(*args, **kwargs)

                class vof_smooth_options(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def use_volumetric_smoothing(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/initialization/patch/vof_smooth_options/use_volumetric_smoothing").execute(*args, **kwargs)
                    def patch_reconstructed_interface(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/initialization/patch/vof_smooth_options/patch_reconstructed_interface").execute(*args, **kwargs)
                    def execute_smoothing(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/initialization/patch/vof_smooth_options/execute_smoothing").execute(*args, **kwargs)
                    def smoothing_relaxation_factor(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/initialization/patch/vof_smooth_options/smoothing_relaxation_factor").execute(*args, **kwargs)

            class defaults(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def delete(self, *args, **kwargs):
                    """
                    Delete defaults object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/defaults/delete").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/defaults/duplicate").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/defaults/list").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/defaults/list_properties").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new defaults object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/defaults/create").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename defaults object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/defaults/rename").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit defaults object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/initialization/defaults/edit").execute(*args, **kwargs)

            class hybrid_init_options(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.general_settings = self.__class__.general_settings(service, version, mode, path + ["general_settings"])
                    self.turbulent_setting = self.__class__.turbulent_setting(service, version, mode, path + ["turbulent_setting"])
                    self.species_setting = self.__class__.species_setting(service, version, mode, path + ["species_setting"])
                    super().__init__(service, version, mode, path)

                class general_settings(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def initial_pressure(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/general_settings/initial_pressure").execute(*args, **kwargs)
                    def reference_frame(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/general_settings/reference_frame").execute(*args, **kwargs)
                    def explicit_urf(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/general_settings/explicit_urf").execute(*args, **kwargs)
                    def external_aero(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/general_settings/external_aero").execute(*args, **kwargs)
                    def iter_count(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/general_settings/iter_count").execute(*args, **kwargs)
                    def const_velocity(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/general_settings/const_velocity").execute(*args, **kwargs)

                class turbulent_setting(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def averaged_turbulent_parameters(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/turbulent_setting/averaged_turbulent_parameters").execute(*args, **kwargs)
                    def turbulent_intensity(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/turbulent_setting/turbulent_intensity").execute(*args, **kwargs)
                    def viscosity_ratio(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/turbulent_setting/viscosity_ratio").execute(*args, **kwargs)

                class species_setting(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.species = self.__class__.species(service, version, mode, path + ["species"])
                        super().__init__(service, version, mode, path)
                    def user_specified_species(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/species_setting/user_specified_species").execute(*args, **kwargs)

                    class species(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def edit(self, *args, **kwargs):
                            """
                            Edit species object.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/species_setting/species/edit").execute(*args, **kwargs)
                        def list(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/species_setting/species/list").execute(*args, **kwargs)
                        def rename(self, *args, **kwargs):
                            """
                            Rename species object.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/species_setting/species/rename").execute(*args, **kwargs)
                        def duplicate(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/species_setting/species/duplicate").execute(*args, **kwargs)
                        def list_properties(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/species_setting/species/list_properties").execute(*args, **kwargs)
                        def create(self, *args, **kwargs):
                            """
                            Create a new species object.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/species_setting/species/create").execute(*args, **kwargs)
                        def delete(self, *args, **kwargs):
                            """
                            Delete species object.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/initialization/hybrid_init_options/species_setting/species/delete").execute(*args, **kwargs)

        class controls(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.under_relaxation = self.__class__.under_relaxation(service, version, mode, path + ["under_relaxation"])
                self.p_v_controls = self.__class__.p_v_controls(service, version, mode, path + ["p_v_controls"])
                self.pseudo_time_method_local_time_step = self.__class__.pseudo_time_method_local_time_step(service, version, mode, path + ["pseudo_time_method_local_time_step"])
                self.contact_solution_controls = self.__class__.contact_solution_controls(service, version, mode, path + ["contact_solution_controls"])
                self.acoustics_wave_eqn_controls = self.__class__.acoustics_wave_eqn_controls(service, version, mode, path + ["acoustics_wave_eqn_controls"])
                self.pseudo_time_explicit_relaxation_factor = self.__class__.pseudo_time_explicit_relaxation_factor(service, version, mode, path + ["pseudo_time_explicit_relaxation_factor"])
                self.relaxation_factor = self.__class__.relaxation_factor(service, version, mode, path + ["relaxation_factor"])
                self.limits = self.__class__.limits(service, version, mode, path + ["limits"])
                self.equations = self.__class__.equations(service, version, mode, path + ["equations"])
                self.advanced = self.__class__.advanced(service, version, mode, path + ["advanced"])
                super().__init__(service, version, mode, path)
            def reset_multi_stage_parameters(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/controls/reset_multi_stage_parameters").execute(*args, **kwargs)
            def reset_solution_controls(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/controls/reset_solution_controls").execute(*args, **kwargs)
            def reset_pseudo_time_method_scale_factors(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/controls/reset_pseudo_time_method_scale_factors").execute(*args, **kwargs)
            def reset_pseudo_time_method_generic(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/controls/reset_pseudo_time_method_generic").execute(*args, **kwargs)
            def reset_limits(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/controls/reset_limits").execute(*args, **kwargs)
            def reset_amg_controls(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/controls/reset_amg_controls").execute(*args, **kwargs)
            def courant_number(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/controls/courant_number").execute(*args, **kwargs)
            def reset_pseudo_time_method_relaxations(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/controls/reset_pseudo_time_method_relaxations").execute(*args, **kwargs)
            def reset_pseudo_time_method_equations(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/solution/controls/reset_pseudo_time_method_equations").execute(*args, **kwargs)

            class under_relaxation(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def delete(self, *args, **kwargs):
                    """
                    Delete under-relaxation object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/under_relaxation/delete").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/under_relaxation/list_properties").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/under_relaxation/duplicate").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/under_relaxation/list").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename under-relaxation object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/under_relaxation/rename").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new under-relaxation object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/under_relaxation/create").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit under-relaxation object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/under_relaxation/edit").execute(*args, **kwargs)

            class p_v_controls(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def neighbor_correction_itr_count(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/p_v_controls/neighbor_correction_itr_count").execute(*args, **kwargs)
                def skewness_neighbor_coupling(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/p_v_controls/skewness_neighbor_coupling").execute(*args, **kwargs)
                def explicit_pressure_under_relaxation(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/p_v_controls/explicit_pressure_under_relaxation").execute(*args, **kwargs)
                def explicit_volume_fraction_under_relaxation(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/p_v_controls/explicit_volume_fraction_under_relaxation").execute(*args, **kwargs)
                def explicit_momentum_under_relaxation(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/p_v_controls/explicit_momentum_under_relaxation").execute(*args, **kwargs)
                def vof_correction_itr_count(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/p_v_controls/vof_correction_itr_count").execute(*args, **kwargs)
                def flow_courant_number(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/p_v_controls/flow_courant_number").execute(*args, **kwargs)
                def skewness_correction_itr_count(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/p_v_controls/skewness_correction_itr_count").execute(*args, **kwargs)
                def volume_fraction_courant_number(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/p_v_controls/volume_fraction_courant_number").execute(*args, **kwargs)

            class pseudo_time_method_local_time_step(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def pseudo_time_courant_number(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_method_local_time_step/pseudo_time_courant_number").execute(*args, **kwargs)
                def pseudo_time_step_method_solid_zone(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_method_local_time_step/pseudo_time_step_method_solid_zone").execute(*args, **kwargs)
                def time_step_size_scale_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_method_local_time_step/time_step_size_scale_factor").execute(*args, **kwargs)

            class contact_solution_controls(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.models = self.__class__.models(service, version, mode, path + ["models"])
                    self.parameters = self.__class__.parameters(service, version, mode, path + ["parameters"])
                    self.transient = self.__class__.transient(service, version, mode, path + ["transient"])
                    self.amg = self.__class__.amg(service, version, mode, path + ["amg"])
                    self.methods = self.__class__.methods(service, version, mode, path + ["methods"])
                    self.miscellaneous = self.__class__.miscellaneous(service, version, mode, path + ["miscellaneous"])
                    self.spatial = self.__class__.spatial(service, version, mode, path + ["spatial"])
                    super().__init__(service, version, mode, path)
                def set_settings_to_default(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/set_settings_to_default").execute(*args, **kwargs)
                def solution_stabilization(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/solution_stabilization").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/verbosity").execute(*args, **kwargs)

                class models(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def model_ramping(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/models/model_ramping").execute(*args, **kwargs)
                    def ramp_scalars(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/models/ramp_scalars").execute(*args, **kwargs)
                    def ramp_turbulence(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/models/ramp_turbulence").execute(*args, **kwargs)
                    def ramp_flow(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/models/ramp_flow").execute(*args, **kwargs)

                class parameters(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def persistence_fixed_duration(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/parameters/persistence_fixed_duration").execute(*args, **kwargs)
                    def persistence_fixed_time_steps(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/parameters/persistence_fixed_time_steps").execute(*args, **kwargs)
                    def solution_stabilization_persistence(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/parameters/solution_stabilization_persistence").execute(*args, **kwargs)
                    def extrapolation_method(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/parameters/extrapolation_method").execute(*args, **kwargs)
                    def iter_count(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/parameters/iter_count").execute(*args, **kwargs)

                class transient(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def transient_parameters_specify(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/transient/transient_parameters_specify").execute(*args, **kwargs)
                    def time_scale_modification_factor(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/transient/time_scale_modification_factor").execute(*args, **kwargs)
                    def transient_scheme(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/transient/transient_scheme").execute(*args, **kwargs)
                    def time_scale_modification_method(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/transient/time_scale_modification_method").execute(*args, **kwargs)

                class amg(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def enforce_laplace_coarsening(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/amg/enforce_laplace_coarsening").execute(*args, **kwargs)
                    def increase_pre_sweeps(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/amg/increase_pre_sweeps").execute(*args, **kwargs)
                    def pre_sweeps(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/amg/pre_sweeps").execute(*args, **kwargs)
                    def specify_coarsening_rate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/amg/specify_coarsening_rate").execute(*args, **kwargs)
                    def coarsen_rate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/amg/coarsen_rate").execute(*args, **kwargs)

                class methods(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def pv_coupling_method(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/methods/pv_coupling_method").execute(*args, **kwargs)
                    def specify_gradient_method(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/methods/specify_gradient_method").execute(*args, **kwargs)
                    def pv_coupling_controls(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/methods/pv_coupling_controls").execute(*args, **kwargs)
                    def gradient_controls(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/methods/gradient_controls").execute(*args, **kwargs)

                class miscellaneous(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def statistics_level(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/miscellaneous/statistics_level").execute(*args, **kwargs)
                    def compute_statistics(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/miscellaneous/compute_statistics").execute(*args, **kwargs)

                class spatial(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def rhie_chow_flux_specify(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/spatial/rhie_chow_flux_specify").execute(*args, **kwargs)
                    def first_to_second_order_blending(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/spatial/first_to_second_order_blending").execute(*args, **kwargs)
                    def rhie_chow_method(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/spatial/rhie_chow_method").execute(*args, **kwargs)
                    def first_to_second_order_blending_list(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/spatial/first_to_second_order_blending_list").execute(*args, **kwargs)
                    def scalars_skew_diffusion_exclude(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/spatial/scalars_skew_diffusion_exclude").execute(*args, **kwargs)
                    def scheme(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/spatial/scheme").execute(*args, **kwargs)
                    def flow_skew_diffusion_exclude(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/contact_solution_controls/spatial/flow_skew_diffusion_exclude").execute(*args, **kwargs)

            class acoustics_wave_eqn_controls(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    super().__init__(service, version, mode, path)
                def relative_convergence_criterion(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/acoustics_wave_eqn_controls/relative_convergence_criterion").execute(*args, **kwargs)
                def max_iter_per_timestep_count(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/acoustics_wave_eqn_controls/max_iter_per_timestep_count").execute(*args, **kwargs)

                class expert(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def explicit_relaxation_factor(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/acoustics_wave_eqn_controls/expert/explicit_relaxation_factor").execute(*args, **kwargs)
                    def under_relaxation_factor(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/acoustics_wave_eqn_controls/expert/under_relaxation_factor").execute(*args, **kwargs)

            class pseudo_time_explicit_relaxation_factor(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.local_dt_dualts_relax = self.__class__.local_dt_dualts_relax(service, version, mode, path + ["local_dt_dualts_relax"])
                    self.global_dt_pseudo_relax = self.__class__.global_dt_pseudo_relax(service, version, mode, path + ["global_dt_pseudo_relax"])
                    super().__init__(service, version, mode, path)

                class local_dt_dualts_relax(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def list(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_explicit_relaxation_factor/local_dt_dualts_relax/list").execute(*args, **kwargs)
                    def create(self, *args, **kwargs):
                        """
                        Create a new local-dt-dualts-relax object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_explicit_relaxation_factor/local_dt_dualts_relax/create").execute(*args, **kwargs)
                    def list_properties(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_explicit_relaxation_factor/local_dt_dualts_relax/list_properties").execute(*args, **kwargs)
                    def rename(self, *args, **kwargs):
                        """
                        Rename local-dt-dualts-relax object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_explicit_relaxation_factor/local_dt_dualts_relax/rename").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete local-dt-dualts-relax object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_explicit_relaxation_factor/local_dt_dualts_relax/delete").execute(*args, **kwargs)
                    def duplicate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_explicit_relaxation_factor/local_dt_dualts_relax/duplicate").execute(*args, **kwargs)
                    def edit(self, *args, **kwargs):
                        """
                        Edit local-dt-dualts-relax object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_explicit_relaxation_factor/local_dt_dualts_relax/edit").execute(*args, **kwargs)

                class global_dt_pseudo_relax(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def list(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_explicit_relaxation_factor/global_dt_pseudo_relax/list").execute(*args, **kwargs)
                    def list_properties(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_explicit_relaxation_factor/global_dt_pseudo_relax/list_properties").execute(*args, **kwargs)
                    def create(self, *args, **kwargs):
                        """
                        Create a new global-dt-pseudo-relax object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_explicit_relaxation_factor/global_dt_pseudo_relax/create").execute(*args, **kwargs)
                    def edit(self, *args, **kwargs):
                        """
                        Edit global-dt-pseudo-relax object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_explicit_relaxation_factor/global_dt_pseudo_relax/edit").execute(*args, **kwargs)
                    def rename(self, *args, **kwargs):
                        """
                        Rename global-dt-pseudo-relax object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_explicit_relaxation_factor/global_dt_pseudo_relax/rename").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete global-dt-pseudo-relax object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_explicit_relaxation_factor/global_dt_pseudo_relax/delete").execute(*args, **kwargs)
                    def duplicate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/pseudo_time_explicit_relaxation_factor/global_dt_pseudo_relax/duplicate").execute(*args, **kwargs)

            class relaxation_factor(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def edit(self, *args, **kwargs):
                    """
                    Edit relaxation-factor object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/relaxation_factor/edit").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename relaxation-factor object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/relaxation_factor/rename").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/relaxation_factor/duplicate").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/relaxation_factor/list").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete relaxation-factor object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/relaxation_factor/delete").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/relaxation_factor/list_properties").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new relaxation-factor object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/relaxation_factor/create").execute(*args, **kwargs)

            class limits(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def min_vel_var_scale(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/min_vel_var_scale").execute(*args, **kwargs)
                def min_epsilon(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/min_epsilon").execute(*args, **kwargs)
                def min_des_omega(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/min_des_omega").execute(*args, **kwargs)
                def min_v2f_epsilon(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/min_v2f_epsilon").execute(*args, **kwargs)
                def max_pressure(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/max_pressure").execute(*args, **kwargs)
                def positivity_rate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/positivity_rate").execute(*args, **kwargs)
                def min_des_tke(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/min_des_tke").execute(*args, **kwargs)
                def min_lam_tke(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/min_lam_tke").execute(*args, **kwargs)
                def min_pressure(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/min_pressure").execute(*args, **kwargs)
                def min_des_epsilon(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/min_des_epsilon").execute(*args, **kwargs)
                def min_v2f_tke(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/min_v2f_tke").execute(*args, **kwargs)
                def min_elliptic_relax_func(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/min_elliptic_relax_func").execute(*args, **kwargs)
                def max_temperature(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/max_temperature").execute(*args, **kwargs)
                def min_omega(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/min_omega").execute(*args, **kwargs)
                def min_vol_frac_for_matrix_sol(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/min_vol_frac_for_matrix_sol").execute(*args, **kwargs)
                def min_tke(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/min_tke").execute(*args, **kwargs)
                def min_temperature(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/min_temperature").execute(*args, **kwargs)
                def max_turb_visc_ratio(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/limits/max_turb_visc_ratio").execute(*args, **kwargs)

            class equations(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def list(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/equations/list").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete equations object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/equations/delete").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit equations object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/equations/edit").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename equations object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/equations/rename").execute(*args, **kwargs)
                def duplicate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/equations/duplicate").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/equations/list_properties").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new equations object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/equations/create").execute(*args, **kwargs)

            class advanced(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.multi_stage = self.__class__.multi_stage(service, version, mode, path + ["multi_stage"])
                    self.fast_transient_settings = self.__class__.fast_transient_settings(service, version, mode, path + ["fast_transient_settings"])
                    self.anisotropic_solid_heat_transfer = self.__class__.anisotropic_solid_heat_transfer(service, version, mode, path + ["anisotropic_solid_heat_transfer"])
                    self.correction_tolerance = self.__class__.correction_tolerance(service, version, mode, path + ["correction_tolerance"])
                    self.multi_grid = self.__class__.multi_grid(service, version, mode, path + ["multi_grid"])
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    super().__init__(service, version, mode, path)
                def relaxation_method(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/relaxation_method").execute(*args, **kwargs)

                class multi_stage(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def number_of_objects(self, *args, **kwargs):
                        """
                        Set number of objects for multi-stage.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_stage/number_of_objects").execute(*args, **kwargs)
                    def edit(self, *args, **kwargs):
                        """
                        Edit multi-stage object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_stage/edit").execute(*args, **kwargs)
                    def list_properties(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_stage/list_properties").execute(*args, **kwargs)

                class fast_transient_settings(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.runge_kutta = self.__class__.runge_kutta(service, version, mode, path + ["runge_kutta"])
                        super().__init__(service, version, mode, path)

                    class runge_kutta(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def two_stage(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/fast_transient_settings/runge_kutta/two_stage").execute(*args, **kwargs)
                        def default_multi_stage(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/fast_transient_settings/runge_kutta/default_multi_stage").execute(*args, **kwargs)

                class anisotropic_solid_heat_transfer(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def gradient(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/anisotropic_solid_heat_transfer/gradient").execute(*args, **kwargs)
                    def flux(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/anisotropic_solid_heat_transfer/flux").execute(*args, **kwargs)

                class correction_tolerance(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def list(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/correction_tolerance/list").execute(*args, **kwargs)
                    def create(self, *args, **kwargs):
                        """
                        Create a new correction-tolerance object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/correction_tolerance/create").execute(*args, **kwargs)
                    def duplicate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/correction_tolerance/duplicate").execute(*args, **kwargs)
                    def rename(self, *args, **kwargs):
                        """
                        Rename correction-tolerance object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/correction_tolerance/rename").execute(*args, **kwargs)
                    def edit(self, *args, **kwargs):
                        """
                        Edit correction-tolerance object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/correction_tolerance/edit").execute(*args, **kwargs)
                    def list_properties(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/correction_tolerance/list_properties").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete correction-tolerance object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/correction_tolerance/delete").execute(*args, **kwargs)

                class multi_grid(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.mg_controls = self.__class__.mg_controls(service, version, mode, path + ["mg_controls"])
                        self.fas_mg_controls = self.__class__.fas_mg_controls(service, version, mode, path + ["fas_mg_controls"])
                        self.amg_gpgpu_options = self.__class__.amg_gpgpu_options(service, version, mode, path + ["amg_gpgpu_options"])
                        self.amg_controls = self.__class__.amg_controls(service, version, mode, path + ["amg_controls"])
                        super().__init__(service, version, mode, path)

                    class mg_controls(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def delete(self, *args, **kwargs):
                            """
                            Delete mg-controls object.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/mg_controls/delete").execute(*args, **kwargs)
                        def edit(self, *args, **kwargs):
                            """
                            Edit mg-controls object.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/mg_controls/edit").execute(*args, **kwargs)
                        def rename(self, *args, **kwargs):
                            """
                            Rename mg-controls object.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/mg_controls/rename").execute(*args, **kwargs)
                        def list_properties(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/mg_controls/list_properties").execute(*args, **kwargs)
                        def duplicate(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/mg_controls/duplicate").execute(*args, **kwargs)
                        def create(self, *args, **kwargs):
                            """
                            Create a new mg-controls object.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/mg_controls/create").execute(*args, **kwargs)
                        def list(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/mg_controls/list").execute(*args, **kwargs)

                    class fas_mg_controls(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.fixed_cycle_parameters = self.__class__.fixed_cycle_parameters(service, version, mode, path + ["fixed_cycle_parameters"])
                            self.options = self.__class__.options(service, version, mode, path + ["options"])
                            self.relaxation_factor = self.__class__.relaxation_factor(service, version, mode, path + ["relaxation_factor"])
                            self.coarsening_parameters = self.__class__.coarsening_parameters(service, version, mode, path + ["coarsening_parameters"])
                            super().__init__(service, version, mode, path)

                        class fixed_cycle_parameters(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def post_sweeps(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/fas_mg_controls/fixed_cycle_parameters/post_sweeps").execute(*args, **kwargs)
                            def pre_sweeps(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/fas_mg_controls/fixed_cycle_parameters/pre_sweeps").execute(*args, **kwargs)

                        class options(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def verbosity(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/fas_mg_controls/options/verbosity").execute(*args, **kwargs)

                        class relaxation_factor(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def courant_number_reduction(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/fas_mg_controls/relaxation_factor/courant_number_reduction").execute(*args, **kwargs)
                            def species_correction_reduction(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/fas_mg_controls/relaxation_factor/species_correction_reduction").execute(*args, **kwargs)
                            def correction_smoothing(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/fas_mg_controls/relaxation_factor/correction_smoothing").execute(*args, **kwargs)
                            def correction_reduction(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/fas_mg_controls/relaxation_factor/correction_reduction").execute(*args, **kwargs)

                        class coarsening_parameters(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def max_coarse_levels(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/fas_mg_controls/coarsening_parameters/max_coarse_levels").execute(*args, **kwargs)
                            def coarsen_by_interval(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/fas_mg_controls/coarsening_parameters/coarsen_by_interval").execute(*args, **kwargs)

                    class amg_gpgpu_options(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def duplicate(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_gpgpu_options/duplicate").execute(*args, **kwargs)
                        def delete(self, *args, **kwargs):
                            """
                            Delete amg-gpgpu-options object.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_gpgpu_options/delete").execute(*args, **kwargs)
                        def rename(self, *args, **kwargs):
                            """
                            Rename amg-gpgpu-options object.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_gpgpu_options/rename").execute(*args, **kwargs)
                        def list_properties(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_gpgpu_options/list_properties").execute(*args, **kwargs)
                        def list(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_gpgpu_options/list").execute(*args, **kwargs)
                        def create(self, *args, **kwargs):
                            """
                            Create a new amg-gpgpu-options object.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_gpgpu_options/create").execute(*args, **kwargs)
                        def edit(self, *args, **kwargs):
                            """
                            Edit amg-gpgpu-options object.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_gpgpu_options/edit").execute(*args, **kwargs)

                    class amg_controls(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.flexible_cycle_parameters = self.__class__.flexible_cycle_parameters(service, version, mode, path + ["flexible_cycle_parameters"])
                            self.scalar_parameters = self.__class__.scalar_parameters(service, version, mode, path + ["scalar_parameters"])
                            self.coupled_parameters = self.__class__.coupled_parameters(service, version, mode, path + ["coupled_parameters"])
                            self.options = self.__class__.options(service, version, mode, path + ["options"])
                            super().__init__(service, version, mode, path)

                        class flexible_cycle_parameters(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def max_coarse_relaxations(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/flexible_cycle_parameters/max_coarse_relaxations").execute(*args, **kwargs)
                            def max_fine_relaxations(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/flexible_cycle_parameters/max_fine_relaxations").execute(*args, **kwargs)

                        class scalar_parameters(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                self.coarsening_parameters = self.__class__.coarsening_parameters(service, version, mode, path + ["coarsening_parameters"])
                                self.fixed_cycle_parameters = self.__class__.fixed_cycle_parameters(service, version, mode, path + ["fixed_cycle_parameters"])
                                super().__init__(service, version, mode, path)
                            def smoother_type(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/scalar_parameters/smoother_type").execute(*args, **kwargs)

                            class coarsening_parameters(TUIMenu):
                                """
                                .
                                """
                                def __init__(self, service, version, mode, path):
                                    self._service = service
                                    self._version = version
                                    self._mode = mode
                                    self._path = path
                                    super().__init__(service, version, mode, path)
                                def laplace_coarsening(self, *args, **kwargs):
                                    """
                                    .
                                    """
                                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/scalar_parameters/coarsening_parameters/laplace_coarsening").execute(*args, **kwargs)
                                def max_coarse_levels(self, *args, **kwargs):
                                    """
                                    .
                                    """
                                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/scalar_parameters/coarsening_parameters/max_coarse_levels").execute(*args, **kwargs)
                                def coarsen_by_interval(self, *args, **kwargs):
                                    """
                                    .
                                    """
                                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/scalar_parameters/coarsening_parameters/coarsen_by_interval").execute(*args, **kwargs)
                                def aggressive_coarsening(self, *args, **kwargs):
                                    """
                                    .
                                    """
                                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/scalar_parameters/coarsening_parameters/aggressive_coarsening").execute(*args, **kwargs)
                                def conservative_coarsening(self, *args, **kwargs):
                                    """
                                    .
                                    """
                                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/scalar_parameters/coarsening_parameters/conservative_coarsening").execute(*args, **kwargs)

                            class fixed_cycle_parameters(TUIMenu):
                                """
                                .
                                """
                                def __init__(self, service, version, mode, path):
                                    self._service = service
                                    self._version = version
                                    self._mode = mode
                                    self._path = path
                                    super().__init__(service, version, mode, path)
                                def post_sweeps(self, *args, **kwargs):
                                    """
                                    .
                                    """
                                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/scalar_parameters/fixed_cycle_parameters/post_sweeps").execute(*args, **kwargs)
                                def max_cycle(self, *args, **kwargs):
                                    """
                                    .
                                    """
                                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/scalar_parameters/fixed_cycle_parameters/max_cycle").execute(*args, **kwargs)
                                def pre_sweeps(self, *args, **kwargs):
                                    """
                                    .
                                    """
                                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/scalar_parameters/fixed_cycle_parameters/pre_sweeps").execute(*args, **kwargs)

                        class coupled_parameters(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                self.fixed_cycle_parameters = self.__class__.fixed_cycle_parameters(service, version, mode, path + ["fixed_cycle_parameters"])
                                self.coarsening_parameters = self.__class__.coarsening_parameters(service, version, mode, path + ["coarsening_parameters"])
                                super().__init__(service, version, mode, path)
                            def smoother_type(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/coupled_parameters/smoother_type").execute(*args, **kwargs)

                            class fixed_cycle_parameters(TUIMenu):
                                """
                                .
                                """
                                def __init__(self, service, version, mode, path):
                                    self._service = service
                                    self._version = version
                                    self._mode = mode
                                    self._path = path
                                    super().__init__(service, version, mode, path)
                                def max_cycle(self, *args, **kwargs):
                                    """
                                    .
                                    """
                                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/coupled_parameters/fixed_cycle_parameters/max_cycle").execute(*args, **kwargs)
                                def post_sweeps(self, *args, **kwargs):
                                    """
                                    .
                                    """
                                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/coupled_parameters/fixed_cycle_parameters/post_sweeps").execute(*args, **kwargs)
                                def pre_sweeps(self, *args, **kwargs):
                                    """
                                    .
                                    """
                                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/coupled_parameters/fixed_cycle_parameters/pre_sweeps").execute(*args, **kwargs)

                            class coarsening_parameters(TUIMenu):
                                """
                                .
                                """
                                def __init__(self, service, version, mode, path):
                                    self._service = service
                                    self._version = version
                                    self._mode = mode
                                    self._path = path
                                    super().__init__(service, version, mode, path)
                                def coarsen_by_interval(self, *args, **kwargs):
                                    """
                                    .
                                    """
                                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/coupled_parameters/coarsening_parameters/coarsen_by_interval").execute(*args, **kwargs)
                                def aggressive_coarsening(self, *args, **kwargs):
                                    """
                                    .
                                    """
                                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/coupled_parameters/coarsening_parameters/aggressive_coarsening").execute(*args, **kwargs)
                                def laplace_coarsening(self, *args, **kwargs):
                                    """
                                    .
                                    """
                                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/coupled_parameters/coarsening_parameters/laplace_coarsening").execute(*args, **kwargs)
                                def max_coarse_levels(self, *args, **kwargs):
                                    """
                                    .
                                    """
                                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/coupled_parameters/coarsening_parameters/max_coarse_levels").execute(*args, **kwargs)
                                def conservative_coarsening(self, *args, **kwargs):
                                    """
                                    .
                                    """
                                    return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/coupled_parameters/coarsening_parameters/conservative_coarsening").execute(*args, **kwargs)

                        class options(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def verbosity(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/multi_grid/amg_controls/options/verbosity").execute(*args, **kwargs)

                class expert(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.spatial_discretization_limiter = self.__class__.spatial_discretization_limiter(service, version, mode, path + ["spatial_discretization_limiter"])
                        self.pseudo_time_method_usage = self.__class__.pseudo_time_method_usage(service, version, mode, path + ["pseudo_time_method_usage"])
                        super().__init__(service, version, mode, path)

                    class spatial_discretization_limiter(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def limiter_filter(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/spatial_discretization_limiter/limiter_filter").execute(*args, **kwargs)
                        def limiter_type(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/spatial_discretization_limiter/limiter_type").execute(*args, **kwargs)
                        def cell_to_limiting(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/spatial_discretization_limiter/cell_to_limiting").execute(*args, **kwargs)

                    class pseudo_time_method_usage(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.global_dt = self.__class__.global_dt(service, version, mode, path + ["global_dt"])
                            self.local_dt = self.__class__.local_dt(service, version, mode, path + ["local_dt"])
                            super().__init__(service, version, mode, path)

                        class global_dt(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def list(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/pseudo_time_method_usage/global_dt/list").execute(*args, **kwargs)
                            def delete(self, *args, **kwargs):
                                """
                                Delete global-dt object.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/pseudo_time_method_usage/global_dt/delete").execute(*args, **kwargs)
                            def duplicate(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/pseudo_time_method_usage/global_dt/duplicate").execute(*args, **kwargs)
                            def edit(self, *args, **kwargs):
                                """
                                Edit global-dt object.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/pseudo_time_method_usage/global_dt/edit").execute(*args, **kwargs)
                            def list_properties(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/pseudo_time_method_usage/global_dt/list_properties").execute(*args, **kwargs)
                            def rename(self, *args, **kwargs):
                                """
                                Rename global-dt object.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/pseudo_time_method_usage/global_dt/rename").execute(*args, **kwargs)
                            def create(self, *args, **kwargs):
                                """
                                Create a new global-dt object.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/pseudo_time_method_usage/global_dt/create").execute(*args, **kwargs)

                        class local_dt(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def list_properties(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/pseudo_time_method_usage/local_dt/list_properties").execute(*args, **kwargs)
                            def edit(self, *args, **kwargs):
                                """
                                Edit local-dt object.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/pseudo_time_method_usage/local_dt/edit").execute(*args, **kwargs)
                            def list(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/pseudo_time_method_usage/local_dt/list").execute(*args, **kwargs)
                            def create(self, *args, **kwargs):
                                """
                                Create a new local-dt object.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/pseudo_time_method_usage/local_dt/create").execute(*args, **kwargs)
                            def delete(self, *args, **kwargs):
                                """
                                Delete local-dt object.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/pseudo_time_method_usage/local_dt/delete").execute(*args, **kwargs)
                            def duplicate(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/pseudo_time_method_usage/local_dt/duplicate").execute(*args, **kwargs)
                            def rename(self, *args, **kwargs):
                                """
                                Rename local-dt object.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solution/controls/advanced/expert/pseudo_time_method_usage/local_dt/rename").execute(*args, **kwargs)

    class setup(TUIMenu):
        """
        Enter setup menu.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            self.boundary_conditions = self.__class__.boundary_conditions(service, version, mode, path + ["boundary_conditions"])
            super().__init__(service, version, mode, path)

        class boundary_conditions(TUIMenu):
            """
            Enter the boudary conditions menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.query = self.__class__.query(service, version, mode, path + ["query"])
                super().__init__(service, version, mode, path)
            def porous_jump(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/porous_jump").execute(*args, **kwargs)
            def outflow(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/outflow").execute(*args, **kwargs)
            def shadow(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/shadow").execute(*args, **kwargs)
            def pressure_outlet(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/pressure_outlet").execute(*args, **kwargs)
            def pressure_far_field(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/pressure_far_field").execute(*args, **kwargs)
            def mass_flow_inlet(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/mass_flow_inlet").execute(*args, **kwargs)
            def exhaust_fan(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/exhaust_fan").execute(*args, **kwargs)
            def axis(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/axis").execute(*args, **kwargs)
            def interior(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/interior").execute(*args, **kwargs)
            def radiator(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/radiator").execute(*args, **kwargs)
            def mass_flow_outlet(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/mass_flow_outlet").execute(*args, **kwargs)
            def outlet_vent(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/outlet_vent").execute(*args, **kwargs)
            def fluid(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/fluid").execute(*args, **kwargs)
            def interface(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/interface").execute(*args, **kwargs)
            def network(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/network").execute(*args, **kwargs)
            def wall(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/wall").execute(*args, **kwargs)
            def intake_fan(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/intake_fan").execute(*args, **kwargs)
            def network_end(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/network_end").execute(*args, **kwargs)
            def recirculation_outlet(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/recirculation_outlet").execute(*args, **kwargs)
            def fan(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/fan").execute(*args, **kwargs)
            def solid(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/solid").execute(*args, **kwargs)
            def pressure_inlet(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/pressure_inlet").execute(*args, **kwargs)
            def degassing(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/degassing").execute(*args, **kwargs)
            def rans_les_interface(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/rans_les_interface").execute(*args, **kwargs)
            def symmetry(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/symmetry").execute(*args, **kwargs)
            def geometry(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/geometry").execute(*args, **kwargs)
            def inlet_vent(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/inlet_vent").execute(*args, **kwargs)
            def periodic(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/periodic").execute(*args, **kwargs)
            def velocity_inlet(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/velocity_inlet").execute(*args, **kwargs)
            def recirculation_inlet(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/recirculation_inlet").execute(*args, **kwargs)
            def overset(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/overset").execute(*args, **kwargs)

            class query(TUIMenu):
                """
                Enter zone query menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def geometry(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/geometry").execute(*args, **kwargs)
                def wall(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/wall").execute(*args, **kwargs)
                def interface(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/interface").execute(*args, **kwargs)
                def outflow(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/outflow").execute(*args, **kwargs)
                def overset(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/overset").execute(*args, **kwargs)
                def list_named_selection(self, *args, **kwargs):
                    """
                    List named selection of zone type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/list_named_selection").execute(*args, **kwargs)
                def solid(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/solid").execute(*args, **kwargs)
                def list_cell_zone_conditions(self, *args, **kwargs):
                    """
                    List cell zone conditions.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/list_cell_zone_conditions").execute(*args, **kwargs)
                def list_boundary_conditions(self, *args, **kwargs):
                    """
                    List boundary conditions.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/list_boundary_conditions").execute(*args, **kwargs)
                def delete_query(self, *args, **kwargs):
                    """
                    Delete saved query.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/delete_query").execute(*args, **kwargs)
                def recirculation_inlet(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/recirculation_inlet").execute(*args, **kwargs)
                def porous_jump(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/porous_jump").execute(*args, **kwargs)
                def exhaust_fan(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/exhaust_fan").execute(*args, **kwargs)
                def list_queries(self, *args, **kwargs):
                    """
                    List all saved queries.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/list_queries").execute(*args, **kwargs)
                def fan(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/fan").execute(*args, **kwargs)
                def network_end(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/network_end").execute(*args, **kwargs)
                def intake_fan(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/intake_fan").execute(*args, **kwargs)
                def fluid(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/fluid").execute(*args, **kwargs)
                def axis(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/axis").execute(*args, **kwargs)
                def radiator(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/radiator").execute(*args, **kwargs)
                def pressure_outlet(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/pressure_outlet").execute(*args, **kwargs)
                def velocity_inlet(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/velocity_inlet").execute(*args, **kwargs)
                def recirculation_outlet(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/recirculation_outlet").execute(*args, **kwargs)
                def outlet_vent(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/outlet_vent").execute(*args, **kwargs)
                def degassing(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/degassing").execute(*args, **kwargs)
                def named_zone_list(self, *args, **kwargs):
                    """
                    Create named list of zones.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/named_zone_list").execute(*args, **kwargs)
                def periodic(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/periodic").execute(*args, **kwargs)
                def pressure_far_field(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/pressure_far_field").execute(*args, **kwargs)
                def pressure_inlet(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/pressure_inlet").execute(*args, **kwargs)
                def network(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/network").execute(*args, **kwargs)
                def rans_les_interface(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/rans_les_interface").execute(*args, **kwargs)
                def shadow(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/shadow").execute(*args, **kwargs)
                def inlet_vent(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/inlet_vent").execute(*args, **kwargs)
                def mass_flow_outlet(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/mass_flow_outlet").execute(*args, **kwargs)
                def symmetry(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/symmetry").execute(*args, **kwargs)
                def mass_flow_inlet(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/mass_flow_inlet").execute(*args, **kwargs)
                def interior(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/setup/boundary_conditions/query/interior").execute(*args, **kwargs)

    class preferences(TUIMenu):
        """
        Set preferences.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            self.mat_pro_app = self.__class__.mat_pro_app(service, version, mode, path + ["mat_pro_app"])
            self.simulation = self.__class__.simulation(service, version, mode, path + ["simulation"])
            self.parametric_study = self.__class__.parametric_study(service, version, mode, path + ["parametric_study"])
            self.gpuapp = self.__class__.gpuapp(service, version, mode, path + ["gpuapp"])
            self.meshing_workflow = self.__class__.meshing_workflow(service, version, mode, path + ["meshing_workflow"])
            self.general = self.__class__.general(service, version, mode, path + ["general"])
            self.graphics = self.__class__.graphics(service, version, mode, path + ["graphics"])
            self.turbo_workflow = self.__class__.turbo_workflow(service, version, mode, path + ["turbo_workflow"])
            self.appearance = self.__class__.appearance(service, version, mode, path + ["appearance"])
            self.navigation = self.__class__.navigation(service, version, mode, path + ["navigation"])
            super().__init__(service, version, mode, path)

        class mat_pro_app(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.check_expression = self.__class__.check_expression(service, version, mode, path + ["check_expression"])
                super().__init__(service, version, mode, path)
            def warning(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/mat_pro_app/warning").execute(*args, **kwargs)
            def mesh_naming(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/mat_pro_app/mesh_naming").execute(*args, **kwargs)
            def beta_features(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/mat_pro_app/beta_features").execute(*args, **kwargs)
            def focus(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/mat_pro_app/focus").execute(*args, **kwargs)

            class check_expression(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def pressure(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/mat_pro_app/check_expression/pressure").execute(*args, **kwargs)
                def coordinates(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/mat_pro_app/check_expression/coordinates").execute(*args, **kwargs)
                def vorticity(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/mat_pro_app/check_expression/vorticity").execute(*args, **kwargs)
                def gdot(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/mat_pro_app/check_expression/gdot").execute(*args, **kwargs)
                def giesekus(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/mat_pro_app/check_expression/giesekus").execute(*args, **kwargs)
                def velocities(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/mat_pro_app/check_expression/velocities").execute(*args, **kwargs)
                def time(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/mat_pro_app/check_expression/time").execute(*args, **kwargs)
                def cdot(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/mat_pro_app/check_expression/cdot").execute(*args, **kwargs)
                def temperature(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/mat_pro_app/check_expression/temperature").execute(*args, **kwargs)
                def edot(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/mat_pro_app/check_expression/edot").execute(*args, **kwargs)
                def dvv(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/mat_pro_app/check_expression/dvv").execute(*args, **kwargs)
                def species(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/mat_pro_app/check_expression/species").execute(*args, **kwargs)

        class simulation(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.report_definitions = self.__class__.report_definitions(service, version, mode, path + ["report_definitions"])
                super().__init__(service, version, mode, path)
            def flow_model(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/simulation/flow_model").execute(*args, **kwargs)
            def pdf_combustion_robust_numerics(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/simulation/pdf_combustion_robust_numerics").execute(*args, **kwargs)
            def local_residual_scaling(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/simulation/local_residual_scaling").execute(*args, **kwargs)

            class report_definitions(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def report_plot_history_data_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/simulation/report_definitions/report_plot_history_data_size").execute(*args, **kwargs)
                def automatic_plot_file(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/simulation/report_definitions/automatic_plot_file").execute(*args, **kwargs)

        class parametric_study(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.layout_options = self.__class__.layout_options(service, version, mode, path + ["layout_options"])
                self.update_options = self.__class__.update_options(service, version, mode, path + ["update_options"])
                super().__init__(service, version, mode, path)

            class layout_options(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def parametric_study_tree(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/parametric_study/layout_options/parametric_study_tree").execute(*args, **kwargs)
                def current_case_parameters(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/parametric_study/layout_options/current_case_parameters").execute(*args, **kwargs)

            class update_options(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def auto_refresh_time(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/parametric_study/update_options/auto_refresh_time").execute(*args, **kwargs)
                def capture_sim_report_data(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/parametric_study/update_options/capture_sim_report_data").execute(*args, **kwargs)
                def write_data(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/parametric_study/update_options/write_data").execute(*args, **kwargs)
                def save_project_after_dpupdate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/parametric_study/update_options/save_project_after_dpupdate").execute(*args, **kwargs)
                def enable_auto_refresh(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/parametric_study/update_options/enable_auto_refresh").execute(*args, **kwargs)

        class gpuapp(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def alpha_features(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/gpuapp/alpha_features").execute(*args, **kwargs)

        class meshing_workflow(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.draw_settings = self.__class__.draw_settings(service, version, mode, path + ["draw_settings"])
                super().__init__(service, version, mode, path)
            def temp_folder(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/meshing_workflow/temp_folder").execute(*args, **kwargs)
            def verbosity(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/meshing_workflow/verbosity").execute(*args, **kwargs)
            def templates_folder(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/meshing_workflow/templates_folder").execute(*args, **kwargs)
            def save_checkpoint_files(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/meshing_workflow/save_checkpoint_files").execute(*args, **kwargs)
            def checkpointing_option(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/meshing_workflow/checkpointing_option").execute(*args, **kwargs)

            class draw_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def face_zone_limit(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/meshing_workflow/draw_settings/face_zone_limit").execute(*args, **kwargs)
                def facet_limit(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/meshing_workflow/draw_settings/facet_limit").execute(*args, **kwargs)
                def auto_draw(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/meshing_workflow/draw_settings/auto_draw").execute(*args, **kwargs)

        class general(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def automatic_transcript(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/general/automatic_transcript").execute(*args, **kwargs)
            def idle_timeout(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/general/idle_timeout").execute(*args, **kwargs)
            def skip_creation_of_groups_pointing_to_single_entity(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/general/skip_creation_of_groups_pointing_to_single_entity").execute(*args, **kwargs)
            def advanced_partition(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/general/advanced_partition").execute(*args, **kwargs)
            def key_behavioral_changes_message(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/general/key_behavioral_changes_message").execute(*args, **kwargs)
            def initial_physics_volume_definitions(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/general/initial_physics_volume_definitions").execute(*args, **kwargs)
            def default_ioformat(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/general/default_ioformat").execute(*args, **kwargs)
            def qaservice_message(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/general/qaservice_message").execute(*args, **kwargs)
            def dock_editor(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/general/dock_editor").execute(*args, **kwargs)
            def utlmode(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/general/utlmode").execute(*args, **kwargs)
            def flow_model(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/general/flow_model").execute(*args, **kwargs)
            def import_physics_volume_definitions(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/general/import_physics_volume_definitions").execute(*args, **kwargs)
            def utlcreate_physics_on_mode_change(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/general/utlcreate_physics_on_mode_change").execute(*args, **kwargs)

        class graphics(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.material_effects = self.__class__.material_effects(service, version, mode, path + ["material_effects"])
                self.embedded_windows = self.__class__.embedded_windows(service, version, mode, path + ["embedded_windows"])
                self.lighting = self.__class__.lighting(service, version, mode, path + ["lighting"])
                self.boundary_markers = self.__class__.boundary_markers(service, version, mode, path + ["boundary_markers"])
                self.meshing_mode = self.__class__.meshing_mode(service, version, mode, path + ["meshing_mode"])
                self.export_video_settings = self.__class__.export_video_settings(service, version, mode, path + ["export_video_settings"])
                self.vector_settings = self.__class__.vector_settings(service, version, mode, path + ["vector_settings"])
                self.transparency = self.__class__.transparency(service, version, mode, path + ["transparency"])
                self.manage_hoops_memory = self.__class__.manage_hoops_memory(service, version, mode, path + ["manage_hoops_memory"])
                self.graphics_effects = self.__class__.graphics_effects(service, version, mode, path + ["graphics_effects"])
                self.colormap_settings = self.__class__.colormap_settings(service, version, mode, path + ["colormap_settings"])
                self.performance = self.__class__.performance(service, version, mode, path + ["performance"])
                self.hardcopy_settings = self.__class__.hardcopy_settings(service, version, mode, path + ["hardcopy_settings"])
                super().__init__(service, version, mode, path)
            def event_poll_timeout(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/event_poll_timeout").execute(*args, **kwargs)
            def plot_legend_margin(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/plot_legend_margin").execute(*args, **kwargs)
            def point_tool_size(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/point_tool_size").execute(*args, **kwargs)
            def rotation_centerpoint_visible(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/rotation_centerpoint_visible").execute(*args, **kwargs)
            def animation_option(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/animation_option").execute(*args, **kwargs)
            def show_hidden_lines(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/show_hidden_lines").execute(*args, **kwargs)
            def set_camera_normal_to_surface_increments(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/set_camera_normal_to_surface_increments").execute(*args, **kwargs)
            def event_poll_interval(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/event_poll_interval").execute(*args, **kwargs)
            def max_graphics_text_size(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/max_graphics_text_size").execute(*args, **kwargs)
            def min_graphics_text_size(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/min_graphics_text_size").execute(*args, **kwargs)
            def scroll_wheel_event_end_timer(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/scroll_wheel_event_end_timer").execute(*args, **kwargs)
            def test_use_external_function(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/test_use_external_function").execute(*args, **kwargs)
            def higher_resolution_graphics_window_line_width(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/higher_resolution_graphics_window_line_width").execute(*args, **kwargs)
            def hidden_surface_removal_method(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/hidden_surface_removal_method").execute(*args, **kwargs)
            def force_key_frame_animation_markers_to_off(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/force_key_frame_animation_markers_to_off").execute(*args, **kwargs)
            def text_window_line_width(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/text_window_line_width").execute(*args, **kwargs)
            def lower_resolution_graphics_window_line_width(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/lower_resolution_graphics_window_line_width").execute(*args, **kwargs)
            def show_hidden_surfaces(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/show_hidden_surfaces").execute(*args, **kwargs)
            def remove_partition_lines(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/remove_partition_lines").execute(*args, **kwargs)
            def switch_to_open_glfor_remote_visualization(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/switch_to_open_glfor_remote_visualization").execute(*args, **kwargs)
            def enable_non_object_based_workflow(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/enable_non_object_based_workflow").execute(*args, **kwargs)
            def double_buffering(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/double_buffering").execute(*args, **kwargs)
            def marker_drawing_mode(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/marker_drawing_mode").execute(*args, **kwargs)
            def graphics_window_point_symbol(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_window_point_symbol").execute(*args, **kwargs)
            def remove_partition_lines_tolerance(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/remove_partition_lines_tolerance").execute(*args, **kwargs)
            def backface_cull(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/backface_cull").execute(*args, **kwargs)
            def surface_general_displacement(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/surface_general_displacement").execute(*args, **kwargs)
            def graphics_window_line_width(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_window_line_width").execute(*args, **kwargs)

            class material_effects(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def decimation_filter(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/material_effects/decimation_filter").execute(*args, **kwargs)
                def parameterization_source(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/material_effects/parameterization_source").execute(*args, **kwargs)
                def tiling_style(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/material_effects/tiling_style").execute(*args, **kwargs)

            class embedded_windows(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def save_embedded_window_layout(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/embedded_windows/save_embedded_window_layout").execute(*args, **kwargs)
                def show_border_for_embedded_window(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/embedded_windows/show_border_for_embedded_window").execute(*args, **kwargs)
                def default_embedded_mesh_windows_view(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/embedded_windows/default_embedded_mesh_windows_view").execute(*args, **kwargs)
                def default_embedded_windows_view(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/embedded_windows/default_embedded_windows_view").execute(*args, **kwargs)

            class lighting(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def headlight_intensity(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/lighting/headlight_intensity").execute(*args, **kwargs)
                def headlight(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/lighting/headlight").execute(*args, **kwargs)
                def lighting_method(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/lighting/lighting_method").execute(*args, **kwargs)
                def ambient_light_intensity(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/lighting/ambient_light_intensity").execute(*args, **kwargs)

            class boundary_markers(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def show_outlet_markers(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/boundary_markers/show_outlet_markers").execute(*args, **kwargs)
                def outlet_color(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/boundary_markers/outlet_color").execute(*args, **kwargs)
                def enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/boundary_markers/enabled").execute(*args, **kwargs)
                def show_inlet_markers(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/boundary_markers/show_inlet_markers").execute(*args, **kwargs)
                def markers_limit(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/boundary_markers/markers_limit").execute(*args, **kwargs)
                def marker_fraction(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/boundary_markers/marker_fraction").execute(*args, **kwargs)
                def color_option(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/boundary_markers/color_option").execute(*args, **kwargs)
                def inlet_color(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/boundary_markers/inlet_color").execute(*args, **kwargs)
                def marker_size_limiting_scale_multiplier(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/boundary_markers/marker_size_limiting_scale_multiplier").execute(*args, **kwargs)
                def exclude_from_bounding(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/boundary_markers/exclude_from_bounding").execute(*args, **kwargs)
                def scale_marker(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/boundary_markers/scale_marker").execute(*args, **kwargs)

            class meshing_mode(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def graphics_window_display_timeout(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/meshing_mode/graphics_window_display_timeout").execute(*args, **kwargs)
                def graphics_window_display_timeout_value(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/meshing_mode/graphics_window_display_timeout_value").execute(*args, **kwargs)

            class export_video_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.advanced_video_quality_options = self.__class__.advanced_video_quality_options(service, version, mode, path + ["advanced_video_quality_options"])
                    super().__init__(service, version, mode, path)
                def video_scale(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/export_video_settings/video_scale").execute(*args, **kwargs)
                def video_fps(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/export_video_settings/video_fps").execute(*args, **kwargs)
                def video_smooth_scaling(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/export_video_settings/video_smooth_scaling").execute(*args, **kwargs)
                def video_resoution_y(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/export_video_settings/video_resoution_y").execute(*args, **kwargs)
                def video_format(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/export_video_settings/video_format").execute(*args, **kwargs)
                def video_resoution_x(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/export_video_settings/video_resoution_x").execute(*args, **kwargs)
                def video_use_frame_resolution(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/export_video_settings/video_use_frame_resolution").execute(*args, **kwargs)
                def video_quality(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/export_video_settings/video_quality").execute(*args, **kwargs)

                class advanced_video_quality_options(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def enable_h264(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/export_video_settings/advanced_video_quality_options/enable_h264").execute(*args, **kwargs)
                    def bit_rate_quality(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/export_video_settings/advanced_video_quality_options/bit_rate_quality").execute(*args, **kwargs)
                    def compression_method(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/export_video_settings/advanced_video_quality_options/compression_method").execute(*args, **kwargs)
                    def bitrate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/export_video_settings/advanced_video_quality_options/bitrate").execute(*args, **kwargs)

            class vector_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def arrow3_dradius2_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/vector_settings/arrow3_dradius2_factor").execute(*args, **kwargs)
                def arrowhead3_dradius1_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/vector_settings/arrowhead3_dradius1_factor").execute(*args, **kwargs)
                def line_arrow3_dperpendicular_radius(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/vector_settings/line_arrow3_dperpendicular_radius").execute(*args, **kwargs)
                def arrow3_dradius1_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/vector_settings/arrow3_dradius1_factor").execute(*args, **kwargs)

            class transparency(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def depth_peeling_preference(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/transparency/depth_peeling_preference").execute(*args, **kwargs)
                def quick_moves(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/transparency/quick_moves").execute(*args, **kwargs)
                def depth_peeling_layers(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/transparency/depth_peeling_layers").execute(*args, **kwargs)
                def algorithm_for_modern_drivers(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/transparency/algorithm_for_modern_drivers").execute(*args, **kwargs)
                def zsort_options(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/transparency/zsort_options").execute(*args, **kwargs)

            class manage_hoops_memory(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def hsfimport_limit(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/manage_hoops_memory/hsfimport_limit").execute(*args, **kwargs)
                def enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/manage_hoops_memory/enabled").execute(*args, **kwargs)

            class graphics_effects(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def bloom_strength(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/bloom_strength").execute(*args, **kwargs)
                def grid_plane_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/grid_plane_enabled").execute(*args, **kwargs)
                def grid_color(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/grid_color").execute(*args, **kwargs)
                def bloom_blur(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/bloom_blur").execute(*args, **kwargs)
                def ambient_occlusion_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/ambient_occlusion_enabled").execute(*args, **kwargs)
                def ambient_occlusion_strength(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/ambient_occlusion_strength").execute(*args, **kwargs)
                def show_marker_reflections(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/show_marker_reflections").execute(*args, **kwargs)
                def grid_plane_count(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/grid_plane_count").execute(*args, **kwargs)
                def bloom_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/bloom_enabled").execute(*args, **kwargs)
                def ambient_occlusion_quality(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/ambient_occlusion_quality").execute(*args, **kwargs)
                def anti_aliasing(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/anti_aliasing").execute(*args, **kwargs)
                def update_after_mouse_release(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/update_after_mouse_release").execute(*args, **kwargs)
                def plane_direction(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/plane_direction").execute(*args, **kwargs)
                def simple_shadows_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/simple_shadows_enabled").execute(*args, **kwargs)
                def reflections_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/reflections_enabled").execute(*args, **kwargs)
                def show_edge_reflections(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/show_edge_reflections").execute(*args, **kwargs)
                def grid_plane_offset(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/grid_plane_offset").execute(*args, **kwargs)
                def grid_plane_size_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/grid_plane_size_factor").execute(*args, **kwargs)
                def shadow_map_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/graphics_effects/shadow_map_enabled").execute(*args, **kwargs)

            class colormap_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def alignment(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/alignment").execute(*args, **kwargs)
                def labels(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/labels").execute(*args, **kwargs)
                def preserve_aspect_ratio_for_hardcopy(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/preserve_aspect_ratio_for_hardcopy").execute(*args, **kwargs)
                def show_colormap(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/show_colormap").execute(*args, **kwargs)
                def text_font_automatic_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/text_font_automatic_size").execute(*args, **kwargs)
                def text_font_fixed_vertical_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/text_font_fixed_vertical_size").execute(*args, **kwargs)
                def aspect_ratio_when_horizontal(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/aspect_ratio_when_horizontal").execute(*args, **kwargs)
                def type(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/type").execute(*args, **kwargs)
                def auto_refit_on_resize(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/auto_refit_on_resize").execute(*args, **kwargs)
                def text_font_fixed_horizontal_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/text_font_fixed_horizontal_size").execute(*args, **kwargs)
                def aspect_ratio_when_vertical(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/aspect_ratio_when_vertical").execute(*args, **kwargs)
                def colormap(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/colormap").execute(*args, **kwargs)
                def text_font_automatic_vertical_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/text_font_automatic_vertical_size").execute(*args, **kwargs)
                def text_font_automatic_units(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/text_font_automatic_units").execute(*args, **kwargs)
                def automatic_resize(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/automatic_resize").execute(*args, **kwargs)
                def use_no_sub_windows(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/use_no_sub_windows").execute(*args, **kwargs)
                def text_behavior(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/text_behavior").execute(*args, **kwargs)
                def text_truncation_limit_for_horizontal_colormaps(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/text_truncation_limit_for_horizontal_colormaps").execute(*args, **kwargs)
                def major_length_to_screen_ratio_when_vertical(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/major_length_to_screen_ratio_when_vertical").execute(*args, **kwargs)
                def text_truncation_limit_for_vertical_colormaps(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/text_truncation_limit_for_vertical_colormaps").execute(*args, **kwargs)
                def levels(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/levels").execute(*args, **kwargs)
                def max_size_scale_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/max_size_scale_factor").execute(*args, **kwargs)
                def min_size_scale_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/min_size_scale_factor").execute(*args, **kwargs)
                def log_scale(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/log_scale").execute(*args, **kwargs)
                def border_style(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/border_style").execute(*args, **kwargs)
                def text_font_name(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/text_font_name").execute(*args, **kwargs)
                def isolines_position_offset(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/isolines_position_offset").execute(*args, **kwargs)
                def margin_from_edge_to_screen_ratio(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/margin_from_edge_to_screen_ratio").execute(*args, **kwargs)
                def number_format_type(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/number_format_type").execute(*args, **kwargs)
                def number_format_precision(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/number_format_precision").execute(*args, **kwargs)
                def major_length_to_screen_ratio_when_horizontal(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/major_length_to_screen_ratio_when_horizontal").execute(*args, **kwargs)
                def text_font_automatic_horizontal_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/text_font_automatic_horizontal_size").execute(*args, **kwargs)
                def text_font_fixed_units(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/text_font_fixed_units").execute(*args, **kwargs)
                def skip_value(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/skip_value").execute(*args, **kwargs)
                def text_font_fixed_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/colormap_settings/text_font_fixed_size").execute(*args, **kwargs)

            class performance(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.fast_display_mode = self.__class__.fast_display_mode(service, version, mode, path + ["fast_display_mode"])
                    self.minimum_frame_rate = self.__class__.minimum_frame_rate(service, version, mode, path + ["minimum_frame_rate"])
                    super().__init__(service, version, mode, path)
                def ratio_of_target_frame_rate_to_classify_heavy_geometry(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/ratio_of_target_frame_rate_to_classify_heavy_geometry").execute(*args, **kwargs)
                def ratio_of_target_frame_rate_to_declassify_heavy_geometry(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/ratio_of_target_frame_rate_to_declassify_heavy_geometry").execute(*args, **kwargs)
                def optimize_for(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/optimize_for").execute(*args, **kwargs)

                class fast_display_mode(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def culling(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/fast_display_mode/culling").execute(*args, **kwargs)
                    def nodes_shown(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/fast_display_mode/nodes_shown").execute(*args, **kwargs)
                    def silhouette_shown(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/fast_display_mode/silhouette_shown").execute(*args, **kwargs)
                    def markers_decimation(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/fast_display_mode/markers_decimation").execute(*args, **kwargs)
                    def transparency(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/fast_display_mode/transparency").execute(*args, **kwargs)
                    def perimeter_edges_shown(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/fast_display_mode/perimeter_edges_shown").execute(*args, **kwargs)
                    def faces_shown(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/fast_display_mode/faces_shown").execute(*args, **kwargs)
                    def status(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/fast_display_mode/status").execute(*args, **kwargs)

                class minimum_frame_rate(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def fixed_culling_value(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/minimum_frame_rate/fixed_culling_value").execute(*args, **kwargs)
                    def target_fps(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/minimum_frame_rate/target_fps").execute(*args, **kwargs)
                    def maximum_culling_threshold(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/minimum_frame_rate/maximum_culling_threshold").execute(*args, **kwargs)
                    def dynamic_adjustment(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/minimum_frame_rate/dynamic_adjustment").execute(*args, **kwargs)
                    def enabled(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/minimum_frame_rate/enabled").execute(*args, **kwargs)
                    def minimum_culling_threshold(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/performance/minimum_frame_rate/minimum_culling_threshold").execute(*args, **kwargs)

            class hardcopy_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def hardcopy_line_width(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/hardcopy_settings/hardcopy_line_width").execute(*args, **kwargs)
                def post_script_permission_override(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/hardcopy_settings/post_script_permission_override").execute(*args, **kwargs)
                def hardcopy_driver(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/hardcopy_settings/hardcopy_driver").execute(*args, **kwargs)
                def save_embedded_windows_in_hardcopy(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/hardcopy_settings/save_embedded_windows_in_hardcopy").execute(*args, **kwargs)
                def hardware_image_accel(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/hardcopy_settings/hardware_image_accel").execute(*args, **kwargs)
                def transparent_embedded_windows(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/hardcopy_settings/transparent_embedded_windows").execute(*args, **kwargs)
                def save_embedded_hardcopies_separately(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/hardcopy_settings/save_embedded_hardcopies_separately").execute(*args, **kwargs)
                def export_edges_for_avz(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/graphics/hardcopy_settings/export_edges_for_avz").execute(*args, **kwargs)

        class turbo_workflow(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.face_zone_settings = self.__class__.face_zone_settings(service, version, mode, path + ["face_zone_settings"])
                self.graphics_settings = self.__class__.graphics_settings(service, version, mode, path + ["graphics_settings"])
                super().__init__(service, version, mode, path)
            def save_checkpoint_files(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/turbo_workflow/save_checkpoint_files").execute(*args, **kwargs)
            def checkpointing_option(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/turbo_workflow/checkpointing_option").execute(*args, **kwargs)

            class face_zone_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def symmetry_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/turbo_workflow/face_zone_settings/symmetry_region").execute(*args, **kwargs)
                def interior_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/turbo_workflow/face_zone_settings/interior_region").execute(*args, **kwargs)
                def periodic2_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/turbo_workflow/face_zone_settings/periodic2_region").execute(*args, **kwargs)
                def inlet_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/turbo_workflow/face_zone_settings/inlet_region").execute(*args, **kwargs)
                def shroud_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/turbo_workflow/face_zone_settings/shroud_region").execute(*args, **kwargs)
                def periodic1_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/turbo_workflow/face_zone_settings/periodic1_region").execute(*args, **kwargs)
                def blade_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/turbo_workflow/face_zone_settings/blade_region").execute(*args, **kwargs)
                def hub_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/turbo_workflow/face_zone_settings/hub_region").execute(*args, **kwargs)
                def outlet_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/turbo_workflow/face_zone_settings/outlet_region").execute(*args, **kwargs)
                def tip2_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/turbo_workflow/face_zone_settings/tip2_region").execute(*args, **kwargs)
                def tip1_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/turbo_workflow/face_zone_settings/tip1_region").execute(*args, **kwargs)
                def fzsearch_order(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/turbo_workflow/face_zone_settings/fzsearch_order").execute(*args, **kwargs)

            class graphics_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def auto_draw(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/turbo_workflow/graphics_settings/auto_draw").execute(*args, **kwargs)

        class appearance(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.selections = self.__class__.selections(service, version, mode, path + ["selections"])
                self.charts = self.__class__.charts(service, version, mode, path + ["charts"])
                self.ansys_logo = self.__class__.ansys_logo(service, version, mode, path + ["ansys_logo"])
                super().__init__(service, version, mode, path)
            def show_interface_children_zone(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/show_interface_children_zone").execute(*args, **kwargs)
            def graphics_background_color2(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/graphics_background_color2").execute(*args, **kwargs)
            def show_model_edges(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/show_model_edges").execute(*args, **kwargs)
            def pastel_color_value(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/pastel_color_value").execute(*args, **kwargs)
            def quick_property_view(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/quick_property_view").execute(*args, **kwargs)
            def number_of_files_recently_used(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/number_of_files_recently_used").execute(*args, **kwargs)
            def group_by_tree_view(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/group_by_tree_view").execute(*args, **kwargs)
            def pastel_color_saturation(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/pastel_color_saturation").execute(*args, **kwargs)
            def surface_emissivity(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/surface_emissivity").execute(*args, **kwargs)
            def graphics_background_style(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/graphics_background_style").execute(*args, **kwargs)
            def graphics_edge_color(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/graphics_edge_color").execute(*args, **kwargs)
            def titles_border_offset(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/titles_border_offset").execute(*args, **kwargs)
            def graphics_view(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/graphics_view").execute(*args, **kwargs)
            def graphics_color_theme(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/graphics_color_theme").execute(*args, **kwargs)
            def graphics_surface_color(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/graphics_surface_color").execute(*args, **kwargs)
            def show_enabled_models(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/show_enabled_models").execute(*args, **kwargs)
            def graphics_foreground_color(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/graphics_foreground_color").execute(*args, **kwargs)
            def graphics_background_color1(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/graphics_background_color1").execute(*args, **kwargs)
            def graphics_wall_face_color(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/graphics_wall_face_color").execute(*args, **kwargs)
            def solution_mode_edge_color_in_meshing_mode(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/solution_mode_edge_color_in_meshing_mode").execute(*args, **kwargs)
            def number_of_pastel_colors(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/number_of_pastel_colors").execute(*args, **kwargs)
            def ruler(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/ruler").execute(*args, **kwargs)
            def graphics_default_manual_node_color(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/graphics_default_manual_node_color").execute(*args, **kwargs)
            def surface_specularity_for_contours(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/surface_specularity_for_contours").execute(*args, **kwargs)
            def default_view(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/default_view").execute(*args, **kwargs)
            def graphics_partition_boundary_color(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/graphics_partition_boundary_color").execute(*args, **kwargs)
            def completer(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/completer").execute(*args, **kwargs)
            def application_font_size(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/application_font_size").execute(*args, **kwargs)
            def titles(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/titles").execute(*args, **kwargs)
            def model_color_scheme(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/model_color_scheme").execute(*args, **kwargs)
            def custom_title_bar(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/custom_title_bar").execute(*args, **kwargs)
            def axis_triad(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/axis_triad").execute(*args, **kwargs)
            def graphics_default_manual_face_color(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/graphics_default_manual_face_color").execute(*args, **kwargs)
            def color_theme(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/color_theme").execute(*args, **kwargs)
            def surface_specularity(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/surface_specularity").execute(*args, **kwargs)
            def graphics_title_window_framecolor(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/graphics_title_window_framecolor").execute(*args, **kwargs)

            class selections(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def highlight_transparency(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/selections/highlight_transparency").execute(*args, **kwargs)
                def highlight_edge_weight(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/selections/highlight_edge_weight").execute(*args, **kwargs)
                def probe_tooltip_hide_delay_timer(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/selections/probe_tooltip_hide_delay_timer").execute(*args, **kwargs)
                def general_displacement(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/selections/general_displacement").execute(*args, **kwargs)
                def highlight_face_color(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/selections/highlight_face_color").execute(*args, **kwargs)
                def mouse_over_highlight_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/selections/mouse_over_highlight_enabled").execute(*args, **kwargs)
                def highlight_specular_component(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/selections/highlight_specular_component").execute(*args, **kwargs)
                def highlight_gloss(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/selections/highlight_gloss").execute(*args, **kwargs)
                def mouse_hover_probe_values_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/selections/mouse_hover_probe_values_enabled").execute(*args, **kwargs)
                def highlight_edge_color(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/selections/highlight_edge_color").execute(*args, **kwargs)
                def probe_tooltip_show_delay_timer(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/selections/probe_tooltip_show_delay_timer").execute(*args, **kwargs)

            class charts(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.text_color = self.__class__.text_color(service, version, mode, path + ["text_color"])
                    self.font = self.__class__.font(service, version, mode, path + ["font"])
                    super().__init__(service, version, mode, path)
                def modern_plots_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/modern_plots_enabled").execute(*args, **kwargs)
                def plots_behavior(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/plots_behavior").execute(*args, **kwargs)
                def modern_plots_points_threshold(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/modern_plots_points_threshold").execute(*args, **kwargs)
                def curve_colors(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/curve_colors").execute(*args, **kwargs)
                def tooltip_interpolation(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/tooltip_interpolation").execute(*args, **kwargs)
                def enable_open_glfor_modern_plots(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/enable_open_glfor_modern_plots").execute(*args, **kwargs)
                def print_residuals_data(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/print_residuals_data").execute(*args, **kwargs)
                def print_plot_data(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/print_plot_data").execute(*args, **kwargs)
                def legend_visibility(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/legend_visibility").execute(*args, **kwargs)
                def threshold(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/threshold").execute(*args, **kwargs)
                def legend_alignment(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/legend_alignment").execute(*args, **kwargs)

                class text_color(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def title(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/text_color/title").execute(*args, **kwargs)
                    def axes(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/text_color/axes").execute(*args, **kwargs)
                    def axes_titles(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/text_color/axes_titles").execute(*args, **kwargs)
                    def legend(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/text_color/legend").execute(*args, **kwargs)

                class font(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def axes(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/font/axes").execute(*args, **kwargs)
                    def legend(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/font/legend").execute(*args, **kwargs)
                    def title(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/font/title").execute(*args, **kwargs)
                    def axes_titles(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/charts/font/axes_titles").execute(*args, **kwargs)

            class ansys_logo(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def color(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/ansys_logo/color").execute(*args, **kwargs)
                def visible(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/appearance/ansys_logo/visible").execute(*args, **kwargs)

        class navigation(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.mouse_mapping = self.__class__.mouse_mapping(service, version, mode, path + ["mouse_mapping"])
                super().__init__(service, version, mode, path)

            class mouse_mapping(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.additional = self.__class__.additional(service, version, mode, path + ["additional"])
                    self.basic = self.__class__.basic(service, version, mode, path + ["basic"])
                    super().__init__(service, version, mode, path)
                def mousemaptheme(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/mousemaptheme").execute(*args, **kwargs)

                class additional(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def shiftlmbdrag(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/additional/shiftlmbdrag").execute(*args, **kwargs)
                    def ctrlmmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/additional/ctrlmmbclick").execute(*args, **kwargs)
                    def mouseprobe(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/additional/mouseprobe").execute(*args, **kwargs)
                    def ctrllmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/additional/ctrllmbclick").execute(*args, **kwargs)
                    def shiftmmbdrag(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/additional/shiftmmbdrag").execute(*args, **kwargs)
                    def shiftmmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/additional/shiftmmbclick").execute(*args, **kwargs)
                    def reversewheeldirection(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/additional/reversewheeldirection").execute(*args, **kwargs)
                    def ctrlmmbdrag(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/additional/ctrlmmbdrag").execute(*args, **kwargs)
                    def shiftrmbdrag(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/additional/shiftrmbdrag").execute(*args, **kwargs)
                    def ctrlrmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/additional/ctrlrmbclick").execute(*args, **kwargs)
                    def mousewheelsensitivity(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/additional/mousewheelsensitivity").execute(*args, **kwargs)
                    def ctrllmbdrag(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/additional/ctrllmbdrag").execute(*args, **kwargs)
                    def shiftlmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/additional/shiftlmbclick").execute(*args, **kwargs)
                    def shiftrmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/additional/shiftrmbclick").execute(*args, **kwargs)
                    def mousewheel(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/additional/mousewheel").execute(*args, **kwargs)
                    def ctrlrmbdrag(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/additional/ctrlrmbdrag").execute(*args, **kwargs)

                class basic(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def lmb(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/basic/lmb").execute(*args, **kwargs)
                    def mmb(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/basic/mmb").execute(*args, **kwargs)
                    def mmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/basic/mmbclick").execute(*args, **kwargs)
                    def lmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/basic/lmbclick").execute(*args, **kwargs)
                    def rmb(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/basic/rmb").execute(*args, **kwargs)
                    def rmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/preferences/navigation/mouse_mapping/basic/rmbclick").execute(*args, **kwargs)

    class parametric_study(TUIMenu):
        """
        Enter the parametric study menu.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            self.study = self.__class__.study(service, version, mode, path + ["study"])
            self.design_points = self.__class__.design_points(service, version, mode, path + ["design_points"])
            self.update = self.__class__.update(service, version, mode, path + ["update"])
            super().__init__(service, version, mode, path)
        def use_base_data(self, *args, **kwargs):
            """
            Use Base Data.
            """
            return PyMenu(self._service, self._version, self._mode, "/parametric_study/use_base_data").execute(*args, **kwargs)
        def delete_study(self, *args, **kwargs):
            """
            Delete Study.
            """
            return PyMenu(self._service, self._version, self._mode, "/parametric_study/delete_study").execute(*args, **kwargs)
        def case_settings_changed(self, *args, **kwargs):
            """
            Check if case settings are changed.
            """
            return PyMenu(self._service, self._version, self._mode, "/parametric_study/case_settings_changed").execute(*args, **kwargs)
        def list_studies(self, *args, **kwargs):
            """
            List Studies.
            """
            return PyMenu(self._service, self._version, self._mode, "/parametric_study/list_studies").execute(*args, **kwargs)
        def rename_study(self, *args, **kwargs):
            """
            Rename Study.
            """
            return PyMenu(self._service, self._version, self._mode, "/parametric_study/rename_study").execute(*args, **kwargs)
        def export_design_table(self, *args, **kwargs):
            """
            Export Design Point Table.
            """
            return PyMenu(self._service, self._version, self._mode, "/parametric_study/export_design_table").execute(*args, **kwargs)
        def duplicate_study(self, *args, **kwargs):
            """
            Duplicate Parametric Study.
            """
            return PyMenu(self._service, self._version, self._mode, "/parametric_study/duplicate_study").execute(*args, **kwargs)
        def initialize(self, *args, **kwargs):
            """
            Start Parametric Study.
            """
            return PyMenu(self._service, self._version, self._mode, "/parametric_study/initialize").execute(*args, **kwargs)
        def set_as_current_study(self, *args, **kwargs):
            """
            Set As Current Study.
            """
            return PyMenu(self._service, self._version, self._mode, "/parametric_study/set_as_current_study").execute(*args, **kwargs)
        def import_design_table(self, *args, **kwargs):
            """
            Import Design Point Table.
            """
            return PyMenu(self._service, self._version, self._mode, "/parametric_study/import_design_table").execute(*args, **kwargs)

        class study(TUIMenu):
            """
            Enter the study menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def set_as_current(self, *args, **kwargs):
                """
                Set As Current Study.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/study/set_as_current").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List Studies.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/study/list").execute(*args, **kwargs)
            def initialize(self, *args, **kwargs):
                """
                Start Parametric Study.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/study/initialize").execute(*args, **kwargs)
            def use_data_of_previous_dp(self, *args, **kwargs):
                """
                Use Data of Previous Updated Design Point.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/study/use_data_of_previous_dp").execute(*args, **kwargs)
            def rename(self, *args, **kwargs):
                """
                Rename Study.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/study/rename").execute(*args, **kwargs)
            def use_base_data(self, *args, **kwargs):
                """
                Use Base Data to Initialize a Design Point.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/study/use_base_data").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete Study.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/study/delete").execute(*args, **kwargs)
            def duplicate(self, *args, **kwargs):
                """
                Duplicate Parametric Study.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/study/duplicate").execute(*args, **kwargs)

        class design_points(TUIMenu):
            """
            Enter the design points menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.concurrent = self.__class__.concurrent(service, version, mode, path + ["concurrent"])
                self.auto_create = self.__class__.auto_create(service, version, mode, path + ["auto_create"])
                self.print_to_console = self.__class__.print_to_console(service, version, mode, path + ["print_to_console"])
                self.table = self.__class__.table(service, version, mode, path + ["table"])
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                super().__init__(service, version, mode, path)
            def add(self, *args, **kwargs):
                """
                Add new design point.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/add").execute(*args, **kwargs)
            def clear_data_and_edit_values(self, *args, **kwargs):
                """
                Clear Generated Data.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/clear_data_and_edit_values").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete Design Point.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/delete").execute(*args, **kwargs)
            def save_journals(self, *args, **kwargs):
                """
                Save Journals.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/save_journals").execute(*args, **kwargs)
            def duplicate(self, *args, **kwargs):
                """
                Duplicate Design Point.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/duplicate").execute(*args, **kwargs)
            def load_case_data_for_current_dp(self, *args, **kwargs):
                """
                Loads relevant case/data file for current design point.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/load_case_data_for_current_dp").execute(*args, **kwargs)

            class concurrent(TUIMenu):
                """
                Enter the concurrent design points menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def abort_all_design_points(self, *args, **kwargs):
                    """
                    Interrupt All Design Points.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/concurrent/abort_all_design_points").execute(*args, **kwargs)
                def refresh_status(self, *args, **kwargs):
                    """
                    Refresh Status.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/concurrent/refresh_status").execute(*args, **kwargs)
                def abort_design_point(self, *args, **kwargs):
                    """
                    Interrupt Design Point.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/concurrent/abort_design_point").execute(*args, **kwargs)

            class auto_create(TUIMenu):
                """
                Enter the auto-crate design points menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def create_design_points(self, *args, **kwargs):
                    """
                    Create design points automatically.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/auto_create/create_design_points").execute(*args, **kwargs)
                def export_designs(self, *args, **kwargs):
                    """
                    Export designs by writing a JSON file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/auto_create/export_designs").execute(*args, **kwargs)
                def set_parameter_as_active_or_inactive(self, *args, **kwargs):
                    """
                    Set the parameter as Active or Inactive.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/auto_create/set_parameter_as_active_or_inactive").execute(*args, **kwargs)
                def go_to_optislang(self, *args, **kwargs):
                    """
                    Open the optiSLang project.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/auto_create/go_to_optislang").execute(*args, **kwargs)
                def list_current_settings(self, *args, **kwargs):
                    """
                    List current settings for auto-create design points.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/auto_create/list_current_settings").execute(*args, **kwargs)
                def get_number_of_designs(self, *args, **kwargs):
                    """
                    Get number of designs.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/auto_create/get_number_of_designs").execute(*args, **kwargs)
                def open_designs_in_optislang_postprocessor(self, *args, **kwargs):
                    """
                    Export designs into JSON and open this JSON into optiSLang Postprocessor.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/auto_create/open_designs_in_optislang_postprocessor").execute(*args, **kwargs)

            class print_to_console(TUIMenu):
                """
                Enter the design points print menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def input_parameters_of_dp(self, *args, **kwargs):
                    """
                    Print Input Parameter Values of Current Design Point.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/print_to_console/input_parameters_of_dp").execute(*args, **kwargs)
                def status_of_all_dps(self, *args, **kwargs):
                    """
                    Print Statuses of all Design Points.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/print_to_console/status_of_all_dps").execute(*args, **kwargs)
                def output_parameters_of_dp(self, *args, **kwargs):
                    """
                    Print Output Parameter Values of Design Point.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/print_to_console/output_parameters_of_dp").execute(*args, **kwargs)
                def capture_simulation_report_data(self, *args, **kwargs):
                    """
                    Print Capture Simulation Report Data option for Design Point.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/print_to_console/capture_simulation_report_data").execute(*args, **kwargs)
                def current_dp(self, *args, **kwargs):
                    """
                    Print Name of Current Design Point.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/print_to_console/current_dp").execute(*args, **kwargs)
                def status_of_dp(self, *args, **kwargs):
                    """
                    Print Status of given DP.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/print_to_console/status_of_dp").execute(*args, **kwargs)
                def write_data(self, *args, **kwargs):
                    """
                    Print WriteData option for Design Point.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/print_to_console/write_data").execute(*args, **kwargs)

            class table(TUIMenu):
                """
                Enter the design point table menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def export_design_table(self, *args, **kwargs):
                    """
                    Export Design Points Table.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/table/export_design_table").execute(*args, **kwargs)
                def import_design_table(self, *args, **kwargs):
                    """
                    Import Design Points Table.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/table/import_design_table").execute(*args, **kwargs)

            class set(TUIMenu):
                """
                Enter the design points Set menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def write_data(self, *args, **kwargs):
                    """
                    Set WriteData option for Design Point.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/set/write_data").execute(*args, **kwargs)
                def current_dp(self, *args, **kwargs):
                    """
                    Set current design point.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/set/current_dp").execute(*args, **kwargs)
                def capture_simulation_report_data(self, *args, **kwargs):
                    """
                    Set Capture Simulation Report Data option for Design Point.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/set/capture_simulation_report_data").execute(*args, **kwargs)
                def input_parameters_of_dp(self, *args, **kwargs):
                    """
                    Set Input Parameter Values of Design Point.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/design_points/set/input_parameters_of_dp").execute(*args, **kwargs)

        class update(TUIMenu):
            """
            Enter the update menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.concurrent = self.__class__.concurrent(service, version, mode, path + ["concurrent"])
                super().__init__(service, version, mode, path)
            def set_update_method(self, *args, **kwargs):
                """
                Set update method.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/set_update_method").execute(*args, **kwargs)
            def update_selected_design_points(self, *args, **kwargs):
                """
                Update Selected Design Points.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/update_selected_design_points").execute(*args, **kwargs)
            def update_all(self, *args, **kwargs):
                """
                Update All Design Points.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/update_all").execute(*args, **kwargs)
            def print_update_method(self, *args, **kwargs):
                """
                Print update method.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/print_update_method").execute(*args, **kwargs)
            def auto_update_mesh_morphs(self, *args, **kwargs):
                """
                Enable Auto Mesh Morphing Update.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/auto_update_mesh_morphs").execute(*args, **kwargs)
            def update_current(self, *args, **kwargs):
                """
                Update Current Design Point.
                """
                return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/update_current").execute(*args, **kwargs)

            class concurrent(TUIMenu):
                """
                Enter Concurrent Update menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.licensing = self.__class__.licensing(service, version, mode, path + ["licensing"])
                    self.print_to_console = self.__class__.print_to_console(service, version, mode, path + ["print_to_console"])
                    self.set = self.__class__.set(service, version, mode, path + ["set"])
                    super().__init__(service, version, mode, path)
                def delete_endpoint(self, *args, **kwargs):
                    """
                    Delete endpoint.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/delete_endpoint").execute(*args, **kwargs)
                def register_new_endpoint(self, *args, **kwargs):
                    """
                    Register a new endpoint.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/register_new_endpoint").execute(*args, **kwargs)

                class licensing(TUIMenu):
                    """
                    Enter Concurrent Licensing menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.set = self.__class__.set(service, version, mode, path + ["set"])
                        self.print_to_console = self.__class__.print_to_console(service, version, mode, path + ["print_to_console"])
                        super().__init__(service, version, mode, path)

                    class set(TUIMenu):
                        """
                        Enter Concurrent Licensing Menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def license_type(self, *args, **kwargs):
                            """
                            License Type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/licensing/set/license_type").execute(*args, **kwargs)
                        def optislang_license_count(self, *args, **kwargs):
                            """
                            OptiSLang License Count.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/licensing/set/optislang_license_count").execute(*args, **kwargs)
                        def optislang_license_type(self, *args, **kwargs):
                            """
                            OptiSLang License Type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/licensing/set/optislang_license_type").execute(*args, **kwargs)

                    class print_to_console(TUIMenu):
                        """
                        Print Concurrent Licensing Settings.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def optislang_license_type(self, *args, **kwargs):
                            """
                            OptiSLang License Type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/licensing/print_to_console/optislang_license_type").execute(*args, **kwargs)
                        def optislang_license_count(self, *args, **kwargs):
                            """
                            OptiSLang License Count.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/licensing/print_to_console/optislang_license_count").execute(*args, **kwargs)
                        def license_type(self, *args, **kwargs):
                            """
                            License Type.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/licensing/print_to_console/license_type").execute(*args, **kwargs)

                class print_to_console(TUIMenu):
                    """
                    Print to console concurrent options.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def number_of_concurrent_dps(self, *args, **kwargs):
                        """
                        Print Number of Concurrent Design Points.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/print_to_console/number_of_concurrent_dps").execute(*args, **kwargs)
                    def current_endpoint(self, *args, **kwargs):
                        """
                        Get the current endpoint.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/print_to_console/current_endpoint").execute(*args, **kwargs)
                    def registered_endpoints(self, *args, **kwargs):
                        """
                        List registered endpoints.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/print_to_console/registered_endpoints").execute(*args, **kwargs)
                    def current_queue(self, *args, **kwargs):
                        """
                        Get the current queue.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/print_to_console/current_queue").execute(*args, **kwargs)
                    def number_of_cores_per_dp(self, *args, **kwargs):
                        """
                        Get Number of Cores per Design Point.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/print_to_console/number_of_cores_per_dp").execute(*args, **kwargs)

                class set(TUIMenu):
                    """
                    Set concurrent update options.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def current_queue(self, *args, **kwargs):
                        """
                        Set the current queue.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/set/current_queue").execute(*args, **kwargs)
                    def current_endpoint(self, *args, **kwargs):
                        """
                        Set the current endpoint.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/set/current_endpoint").execute(*args, **kwargs)
                    def number_of_cores_per_dp(self, *args, **kwargs):
                        """
                        Set Number of Cores per Design Point.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/set/number_of_cores_per_dp").execute(*args, **kwargs)
                    def number_of_concurrent_dps(self, *args, **kwargs):
                        """
                        Set Number of Concurrent Design Points.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/parametric_study/update/concurrent/set/number_of_concurrent_dps").execute(*args, **kwargs)

    class views(TUIMenu):
        """
        .
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            self.camera = self.__class__.camera(service, version, mode, path + ["camera"])
            self.display_states = self.__class__.display_states(service, version, mode, path + ["display_states"])
            super().__init__(service, version, mode, path)
        def read_views(self, *args, **kwargs):
            """
            Reads views from a view file.
            """
            return PyMenu(self._service, self._version, self._mode, "/views/read_views").execute(*args, **kwargs)
        def auto_scale(self, *args, **kwargs):
            """
            Scales and centers the current scene without changing its orientation.
            """
            return PyMenu(self._service, self._version, self._mode, "/views/auto_scale").execute(*args, **kwargs)
        def list_views(self, *args, **kwargs):
            """
            Lists predefined and saved views.
            """
            return PyMenu(self._service, self._version, self._mode, "/views/list_views").execute(*args, **kwargs)
        def save_view(self, *args, **kwargs):
            """
            Saves the current view to the view list.
            """
            return PyMenu(self._service, self._version, self._mode, "/views/save_view").execute(*args, **kwargs)
        def next_view(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/views/next_view").execute(*args, **kwargs)
        def delete_view(self, *args, **kwargs):
            """
            Removes a view from the list.
            """
            return PyMenu(self._service, self._version, self._mode, "/views/delete_view").execute(*args, **kwargs)
        def default_view(self, *args, **kwargs):
            """
            Resets view to front and center.
            """
            return PyMenu(self._service, self._version, self._mode, "/views/default_view").execute(*args, **kwargs)
        def write_views(self, *args, **kwargs):
            """
            Writes selected views to a view file.
            """
            return PyMenu(self._service, self._version, self._mode, "/views/write_views").execute(*args, **kwargs)
        def restore_view(self, *args, **kwargs):
            """
            Uses a saved view.
            """
            return PyMenu(self._service, self._version, self._mode, "/views/restore_view").execute(*args, **kwargs)
        def last_view(self, *args, **kwargs):
            """
            Returns to the camera position before the last manipulation.
            """
            return PyMenu(self._service, self._version, self._mode, "/views/last_view").execute(*args, **kwargs)

        class camera(TUIMenu):
            """
            Enters the camera menu to modify the current viewing parameters.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def up_vector(self, *args, **kwargs):
                """
                Sets the camera up-vector.
                """
                return PyMenu(self._service, self._version, self._mode, "/views/camera/up_vector").execute(*args, **kwargs)
            def roll_camera(self, *args, **kwargs):
                """
                Adjusts the camera up-vector.
                """
                return PyMenu(self._service, self._version, self._mode, "/views/camera/roll_camera").execute(*args, **kwargs)
            def orbit_camera(self, *args, **kwargs):
                """
                Adjusts the camera position without modifying the target.
                """
                return PyMenu(self._service, self._version, self._mode, "/views/camera/orbit_camera").execute(*args, **kwargs)
            def zoom_camera(self, *args, **kwargs):
                """
                Adjusts the cameras field of view. This operation is similar to dollying the camera in or out of the scene. Dollying causes objects in front to move past you. Zooming changes the perspective effect in the scene (and can be disconcerting).
                """
                return PyMenu(self._service, self._version, self._mode, "/views/camera/zoom_camera").execute(*args, **kwargs)
            def projection(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/views/camera/projection").execute(*args, **kwargs)
            def pan_camera(self, *args, **kwargs):
                """
                Adjusts the camera target without modifying the position.
                """
                return PyMenu(self._service, self._version, self._mode, "/views/camera/pan_camera").execute(*args, **kwargs)
            def position(self, *args, **kwargs):
                """
                Sets the camera position.
                """
                return PyMenu(self._service, self._version, self._mode, "/views/camera/position").execute(*args, **kwargs)
            def field(self, *args, **kwargs):
                """
                Sets the field of view (width and height).
                """
                return PyMenu(self._service, self._version, self._mode, "/views/camera/field").execute(*args, **kwargs)
            def dolly_camera(self, *args, **kwargs):
                """
                Adjusts the camera position and target.
                """
                return PyMenu(self._service, self._version, self._mode, "/views/camera/dolly_camera").execute(*args, **kwargs)
            def target(self, *args, **kwargs):
                """
                Sets the point to be the center of the camera view.
                """
                return PyMenu(self._service, self._version, self._mode, "/views/camera/target").execute(*args, **kwargs)

        class display_states(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def use_active(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/views/display_states/use_active").execute(*args, **kwargs)
            def copy(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/views/display_states/copy").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/views/display_states/list").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/views/display_states/list_properties").execute(*args, **kwargs)
            def write(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/views/display_states/write").execute(*args, **kwargs)
            def read(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/views/display_states/read").execute(*args, **kwargs)
            def new(self, *args, **kwargs):
                """
                Create a new display-states object.
                """
                return PyMenu(self._service, self._version, self._mode, "/views/display_states/new").execute(*args, **kwargs)
            def rename(self, *args, **kwargs):
                """
                Rename display-states object.
                """
                return PyMenu(self._service, self._version, self._mode, "/views/display_states/rename").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete display-states object.
                """
                return PyMenu(self._service, self._version, self._mode, "/views/display_states/delete").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit display-states object.
                """
                return PyMenu(self._service, self._version, self._mode, "/views/display_states/edit").execute(*args, **kwargs)
            def duplicate(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/views/display_states/duplicate").execute(*args, **kwargs)
            def restore_state(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/views/display_states/restore_state").execute(*args, **kwargs)

    class mesh(TUIMenu):
        """
        Enter the mesh menu.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            self.polyhedra = self.__class__.polyhedra(service, version, mode, path + ["polyhedra"])
            self.adapt = self.__class__.adapt(service, version, mode, path + ["adapt"])
            self.reorder = self.__class__.reorder(service, version, mode, path + ["reorder"])
            self.surface_mesh = self.__class__.surface_mesh(service, version, mode, path + ["surface_mesh"])
            self.repair_improve = self.__class__.repair_improve(service, version, mode, path + ["repair_improve"])
            self.anisotropic_adaption = self.__class__.anisotropic_adaption(service, version, mode, path + ["anisotropic_adaption"])
            self.modify_zones = self.__class__.modify_zones(service, version, mode, path + ["modify_zones"])
            self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
            super().__init__(service, version, mode, path)
        def size_info(self, *args, **kwargs):
            """
            Prints mesh size.
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/size_info").execute(*args, **kwargs)
        def redistribute_boundary_layer(self, *args, **kwargs):
            """
            Redistributes the nodes in a boundary layer zone to achieve a desired growth rate after anisotropic adaption.
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/redistribute_boundary_layer").execute(*args, **kwargs)
        def smooth_mesh(self, *args, **kwargs):
            """
            Smooths the mesh using quality-based, Laplacian, or skewness methods.
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/smooth_mesh").execute(*args, **kwargs)
        def check_verbosity(self, *args, **kwargs):
            """
            Sets the level of details that will be added to the mesh check report generated by mesh/check. A value of 0 (the default) notes when checks are being performed, but does not list them individually. A value of 1 lists the individual checks as they are performed. A value of 2 enables the availability of additional mesh field variables, lists the individual checks as they are performed, and provides additional details (for example, the location of the problem, the affected cells).  The check-verbosity text command can also be used to set the level of detail displayed in the mesh quality report generated by mesh/quality. A value of 0 (the default) or 1 lists the minimum orthogonal quality and the maximum aspect ratio. A value of 2 adds information about the zones that contain the cells with the lowest quality, and additional metrics such as the maximum cell squish index and the minimum expansion ratio.
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/check_verbosity").execute(*args, **kwargs)
        def check_before_solve(self, *args, **kwargs):
            """
            The default value for mesh/check-before-solve is no. If mesh/check-before-solve is set to yes, a mesh check operation will be invoked prior to starting solver. If grid check fails, solver will be interrupted, and relevant information will be printed in the Fluent console.
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/check_before_solve").execute(*args, **kwargs)
        def wall_distance_method(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/wall_distance_method").execute(*args, **kwargs)
        def scale(self, *args, **kwargs):
            """
            Prompts for the scaling factors in each of the active Cartesian coordinate directions.
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/scale").execute(*args, **kwargs)
        def swap_mesh_faces(self, *args, **kwargs):
            """
            Swaps mesh faces.
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/swap_mesh_faces").execute(*args, **kwargs)
        def mesh_info(self, *args, **kwargs):
            """
            Prints zone information size.
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/mesh_info").execute(*args, **kwargs)
        def check(self, *args, **kwargs):
            """
            Performs various mesh consistency checks and displays a report in the console that lists the domain extents, the volume statistics, the face area statistics, and any warnings, as well as details about the various checks and mesh failures (depending on the setting specified for mesh/check-verbosity).
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/check").execute(*args, **kwargs)
        def rotate(self, *args, **kwargs):
            """
            Rotates the mesh.
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/rotate").execute(*args, **kwargs)
        def enhanced_orthogonal_quality(self, *args, **kwargs):
            """
            Enables / disables an enhanced definition when calculating the orthogonal quality. When enabled, the orthogonal quality is defined using a variety quality measures, including: the orthogonality of a face relative to a vector between the face and cell centroids; a metric that detects poor cell shape at a local edge (such as twisting and/or concavity); and the variation of normals between the faces that can be constructed from the cell face. This enhanced definition is optimal for evaluating thin prism cells.
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/enhanced_orthogonal_quality").execute(*args, **kwargs)
        def replace(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/replace").execute(*args, **kwargs)
        def quality(self, *args, **kwargs):
            """
            Displays information about the quality of the mesh in the console, including the minimum orthogonal quality and the maximum aspect ratio. The level of detail displayed depends on the setting specified for mesh/check-verbosity.
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/quality").execute(*args, **kwargs)
        def show_periodic_shadow_zones(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/show_periodic_shadow_zones").execute(*args, **kwargs)
        def memory_usage(self, *args, **kwargs):
            """
            Reports solver memory use.
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/memory_usage").execute(*args, **kwargs)
        def adjacency(self, *args, **kwargs):
            """
            Views and renames face zones adjacent to selected cell  zones.
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/adjacency").execute(*args, **kwargs)
        def translate(self, *args, **kwargs):
            """
            Prompts for the translation offset in each of the active Cartesian coordinate directions.
            """
            return PyMenu(self._service, self._version, self._mode, "/mesh/translate").execute(*args, **kwargs)

        class polyhedra(TUIMenu):
            """
            Enters the polyhedra menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.options = self.__class__.options(service, version, mode, path + ["options"])
                super().__init__(service, version, mode, path)
            def convert_domain(self, *args, **kwargs):
                """
                Converts the entire domain to polyhedra cells.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/polyhedra/convert_domain").execute(*args, **kwargs)
            def convert_skewed_cells(self, *args, **kwargs):
                """
                Converts skewed cells to polyhedra.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/polyhedra/convert_skewed_cells").execute(*args, **kwargs)
            def convert_hanging_nodes(self, *args, **kwargs):
                """
                Converts cells with hanging nodes/edges to polyhedra.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/polyhedra/convert_hanging_nodes").execute(*args, **kwargs)
            def convert_hanging_nodes_zones(self, *args, **kwargs):
                """
                Convert selected cell zones with hanging nodes and faces to polyhedra.
                The selected cell zones cannot be connected to other zones.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/polyhedra/convert_hanging_nodes_zones").execute(*args, **kwargs)

            class options(TUIMenu):
                """
                Enters the polyhedra options menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def preserve_boundary_layer(self, *args, **kwargs):
                    """
                    Specifies whether boundary layer cells will be preserved when the domain is converted to polyhedra. When the value is set to 0 (default) ANSYS Fluent checks for high aspect ratio cells at the boundary layer and if any are found, Fluent asks if you want to preserve the boundary layer. When the value is set to 1, the boundary layer cells are never preserved; when it is set to 2, the boundary layer cells are always preserved (regardless of the aspect ratio of the boundary layer cells).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/polyhedra/options/preserve_boundary_layer").execute(*args, **kwargs)
                def preserve_interior_zones(self, *args, **kwargs):
                    """
                    Enables the preservation of surfaces (that is, manifold zones of type interior) during the conversion of the domain to polyhedra. Note that only those zones with a name that includes the string you specify will be preserved.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/polyhedra/options/preserve_interior_zones").execute(*args, **kwargs)
                def migrate_and_reorder(self, *args, **kwargs):
                    """
                    Enables / disables the migration of newly created partitions to the compute-nodes and the reordering of the domain as part of polyhedra conversion. This is disabled by default, because it requires significant additional memory; when disabled, it is recommended that you save the case file after conversion, read it in a new Fluent session (so that the new / stored partitions become active), and then manually reorder using the mesh/reorder/reorder-domain text command. If you want to run the calculation in the current Fluent session you can enable the migrate-and-reorder? text command prior to conversion, but you must ensure that no more than half of the available memory of your system is currently used.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/polyhedra/options/migrate_and_reorder").execute(*args, **kwargs)

        class adapt(TUIMenu):
            """
            Enters the mesh adaption menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.multi_layer_refinement = self.__class__.multi_layer_refinement(service, version, mode, path + ["multi_layer_refinement"])
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                self.cell_registers = self.__class__.cell_registers(service, version, mode, path + ["cell_registers"])
                self.manage_criteria = self.__class__.manage_criteria(service, version, mode, path + ["manage_criteria"])
                self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                self.profile = self.__class__.profile(service, version, mode, path + ["profile"])
                super().__init__(service, version, mode, path)
            def display_adaption_cells(self, *args, **kwargs):
                """
                Displays the cells that are marked for adaption in the graphics window.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/display_adaption_cells").execute(*args, **kwargs)
            def free_hierarchy(self, *args, **kwargs):
                """
                Deletes the defined adaption hierarchy.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/free_hierarchy").execute(*args, **kwargs)
            def list_adaption_cells(self, *args, **kwargs):
                """
                Prints the number of cells marked for refinement, coarsening, and both to the console.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/list_adaption_cells").execute(*args, **kwargs)
            def manual_refinement_criteria(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/manual_refinement_criteria").execute(*args, **kwargs)
            def manual_coarsening_criteria(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/manual_coarsening_criteria").execute(*args, **kwargs)
            def refinement_criteria(self, *args, **kwargs):
                """
                Allows you to provide an expression for the refinement criterion.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/refinement_criteria").execute(*args, **kwargs)
            def adapt_mesh(self, *args, **kwargs):
                """
                Performs manual adaption on the mesh according to the methods and settings that you specified.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/adapt_mesh").execute(*args, **kwargs)
            def coarsening_criteria(self, *args, **kwargs):
                """
                Allows you to provide an expression for the coarsening criterion.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/coarsening_criteria").execute(*args, **kwargs)
            def anisotropic_adaption(self, *args, **kwargs):
                """
                Applies legacy anisotropic adaption to refine the boundary layers or registers. Cells will be split in the normal direction to the boundary face. Note that this text command is only available for 3D cases that have the adaption method set to hanging node.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/anisotropic_adaption").execute(*args, **kwargs)

            class multi_layer_refinement(TUIMenu):
                """
                Enter the multiple boundary layer refinement menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def parameters(self, *args, **kwargs):
                    """
                    Specify parameters for multiple boundary layer refinement.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/multi_layer_refinement/parameters").execute(*args, **kwargs)
                def layer_count(self, *args, **kwargs):
                    """
                    Specify the layer count for refinement.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/multi_layer_refinement/layer_count").execute(*args, **kwargs)
                def boundary_zones(self, *args, **kwargs):
                    """
                    Specify boundary zones for refinement.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/multi_layer_refinement/boundary_zones").execute(*args, **kwargs)
                def refine_mesh(self, *args, **kwargs):
                    """
                    Refine the mesh for multiple boundary layers.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/multi_layer_refinement/refine_mesh").execute(*args, **kwargs)

            class set(TUIMenu):
                """
                Enters the set menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def prismatic_adaption(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/prismatic_adaption").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    Allows you set how much information about the adaption is printed to the console.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/verbosity").execute(*args, **kwargs)
                def method(self, *args, **kwargs):
                    """
                    Sets the adaption method.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/method").execute(*args, **kwargs)
                def prismatic_split_ratio(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/prismatic_split_ratio").execute(*args, **kwargs)
                def prismatic_boundary_zones(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/prismatic_boundary_zones").execute(*args, **kwargs)
                def display_settings(self, *args, **kwargs):
                    """
                    Sets the graphics display options for the refinement, coarsening, and common cells.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/display_settings").execute(*args, **kwargs)
                def minimum_edge_length(self, *args, **kwargs):
                    """
                    Sets an approximate limit to the edge length for cells that are considered for refinement. Even if a cell is marked for refinement, it will not be refined if (for 3D) its volume is less than the cube of this field or (for 2D) its area is less than the square of this field. The default value of zero places no limits on the size of cells that are refined.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/minimum_edge_length").execute(*args, **kwargs)
                def maximum_refinement_level(self, *args, **kwargs):
                    """
                    Controls the number of levels of refinement used to split cells during the adaption.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/maximum_refinement_level").execute(*args, **kwargs)
                def overset_adapt_dead_cells(self, *args, **kwargs):
                    """
                    Enables/disables the adaption of dead cells in overset meshes.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/overset_adapt_dead_cells").execute(*args, **kwargs)
                def additional_refinement_layers(self, *args, **kwargs):
                    """
                    Allows you to specify additional refinement layers (this is an advanced control).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/additional_refinement_layers").execute(*args, **kwargs)
                def maximum_cell_count(self, *args, **kwargs):
                    """
                    Sets an approximate limit to the total cell count of the mesh during adaption. Fluent uses this value to determine when to stop marking cells for refinement. A value of zero places no limits on the number of cells.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/maximum_cell_count").execute(*args, **kwargs)
                def minimum_cell_quality(self, *args, **kwargs):
                    """
                    Sets the minimum value allowed for the orthogonal quality of cells during adaption. If your solution diverges, you may find that using a higher minimum quality value resolves the issue. This text command is only available with the PUMA 3D adaption method.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/minimum_cell_quality").execute(*args, **kwargs)
                def minimum_cell_volume(self, *args, **kwargs):
                    """
                    Set limit on the minimum volume of cells in the mesh.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/minimum_cell_volume").execute(*args, **kwargs)
                def encapsulate_children(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/encapsulate_children").execute(*args, **kwargs)
                def dynamic_adaption_frequency(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/dynamic_adaption_frequency").execute(*args, **kwargs)
                def dynamic_adaption(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/dynamic_adaption").execute(*args, **kwargs)
                def cell_zones(self, *args, **kwargs):
                    """
                    Sets cell zones to be used for marking adaption. An empty list specifies that all zones are considered for adaption.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/set/cell_zones").execute(*args, **kwargs)

            class cell_registers(TUIMenu):
                """
                Enters the cell registers menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def edit(self, *args, **kwargs):
                    """
                    Edit an object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/cell_registers/edit").execute(*args, **kwargs)
                def coarsen(self, *args, **kwargs):
                    """
                    Coarsen the mesh based on a cell register.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/cell_registers/coarsen").execute(*args, **kwargs)
                def apply_poor_mesh_numerics(self, *args, **kwargs):
                    """
                    Applies poor mesh numerics to the mesh of a cell register.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/cell_registers/apply_poor_mesh_numerics").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    Lists the properties of a cell register.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/cell_registers/list_properties").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Deletes a cell register.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/cell_registers/delete").execute(*args, **kwargs)
                def add(self, *args, **kwargs):
                    """
                    Add a new object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/cell_registers/add").execute(*args, **kwargs)
                def display(self, *args, **kwargs):
                    """
                    Displays a cell register.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/cell_registers/display").execute(*args, **kwargs)
                def adapt(self, *args, **kwargs):
                    """
                    Adapt cell register objects.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/cell_registers/adapt").execute(*args, **kwargs)
                def refine(self, *args, **kwargs):
                    """
                    Refine the mesh based on a cell register.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/cell_registers/refine").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    Lists all of the currently defined cell registers.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/cell_registers/list").execute(*args, **kwargs)

            class manage_criteria(TUIMenu):
                """
                Enters the manage criteria menu, which provides text commands for managing automatic adaption criteria.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def list(self, *args, **kwargs):
                    """
                    Lists all the existing automatic adaption criteria.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/manage_criteria/list").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Deletes an existing automatic adaption criterion.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/manage_criteria/delete").execute(*args, **kwargs)
                def add(self, *args, **kwargs):
                    """
                    Adds a new automatic adaption criterion.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/manage_criteria/add").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edits an existing automatic adaption criterion.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/manage_criteria/edit").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    Lists the properties of an existing automatic adaption criterion.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/manage_criteria/list_properties").execute(*args, **kwargs)

            class geometry(TUIMenu):
                """
                Enters the geometry menu. Note that this text command menu is not available unless the adaption method is set to hanging node.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.manage = self.__class__.manage(service, version, mode, path + ["manage"])
                    super().__init__(service, version, mode, path)
                def reconstruct_geometry(self, *args, **kwargs):
                    """
                    Enables/disables geometry-based adaption.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/geometry/reconstruct_geometry").execute(*args, **kwargs)
                def set_geometry_controls(self, *args, **kwargs):
                    """
                    Sets geometry controls for wall zones.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/geometry/set_geometry_controls").execute(*args, **kwargs)

                class manage(TUIMenu):
                    """
                    Manage geometry-based adaption.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def delete(self, *args, **kwargs):
                        """
                        Delete an object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/geometry/manage/delete").execute(*args, **kwargs)
                    def list_properties(self, *args, **kwargs):
                        """
                        List properties of an object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/geometry/manage/list_properties").execute(*args, **kwargs)
                    def edit(self, *args, **kwargs):
                        """
                        Edit an object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/geometry/manage/edit").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        List objects.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/geometry/manage/list").execute(*args, **kwargs)
                    def add(self, *args, **kwargs):
                        """
                        Add a new object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/geometry/manage/add").execute(*args, **kwargs)

            class profile(TUIMenu):
                """
                Enters the profile menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def clear(self, *args, **kwargs):
                    """
                    Clears the adaption profiling counters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/profile/clear").execute(*args, **kwargs)
                def disable(self, *args, **kwargs):
                    """
                    Disables adaption profiling.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/profile/disable").execute(*args, **kwargs)
                def enable(self, *args, **kwargs):
                    """
                    Enables adaption profiling.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/profile/enable").execute(*args, **kwargs)
                def print(self, *args, **kwargs):
                    """
                    Prints adaption profiling results.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/adapt/profile/print").execute(*args, **kwargs)

        class reorder(TUIMenu):
            """
            Reorders domain menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def band_width(self, *args, **kwargs):
                """
                Prints cell bandwidth.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/reorder/band_width").execute(*args, **kwargs)
            def reorder_domain(self, *args, **kwargs):
                """
                Reorders cells and faces using the reverse Cuthill-McKee algorithm. Note that you must save a new case file (and a data file, if data exists) after reordering with this text command, as well as recreate any ray files and/or surface cluster information.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/reorder/reorder_domain").execute(*args, **kwargs)
            def reorder_zones(self, *args, **kwargs):
                """
                Reorders zones by partition, type, and ID.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/reorder/reorder_zones").execute(*args, **kwargs)

        class surface_mesh(TUIMenu):
            """
            Enters the Surface Mesh menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def read(self, *args, **kwargs):
                """
                Reads surface meshes.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/surface_mesh/read").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Displays surface meshes.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/surface_mesh/display").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Deletes surface mesh.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/surface_mesh/delete").execute(*args, **kwargs)

        class repair_improve(TUIMenu):
            """
            Enter the repair and improve quality menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def repair_wall_distance(self, *args, **kwargs):
                """
                Corrects wall distance at very high aspect ratio hexahedral/polyhedral cells.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/repair_improve/repair_wall_distance").execute(*args, **kwargs)
            def repair_periodic(self, *args, **kwargs):
                """
                Modifies the mesh to enforce a rotational angle or translational distance for periodic boundaries. For translationally periodic boundaries, the command computes an average translation distance and adjusts the node coordinates on the shadow face zone to match this distance. For rotationally periodic boundaries, the command prompts for an angle and adjusts the node coordinates on the shadow face zone using this angle and the defined rotational axis for the cell zone.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/repair_improve/repair_periodic").execute(*args, **kwargs)
            def repair_face_node_order(self, *args, **kwargs):
                """
                Modifies face nodes to repair faces with improper face node order and, therefore, eliminates any resulting left-handed faces.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/repair_improve/repair_face_node_order").execute(*args, **kwargs)
            def include_local_polyhedra_conversion_in_repair(self, *args, **kwargs):
                """
                Enables/disables the local conversion of degenerate cells into polyhedra based on skewness criteria as part of the mesh repairs performed by the  mesh/repair-improve/repair text command.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/repair_improve/include_local_polyhedra_conversion_in_repair").execute(*args, **kwargs)
            def repair(self, *args, **kwargs):
                """
                Repairs mesh problems identified by the mesh check, if possible. The repairs include fixing cells that have the wrong node order, the wrong face handedness, faces that are small or nonexistent, or very poor quality. Only interior nodes are repositioned by default; boundary nodes may be repositioned if the  mesh/repair-improve/allow-repair-at-boundaries text command is enabled. Note that highly skewed cells may be converted into polyhedra, depending on whether the  mesh/repair-improve/include-local-polyhedra-conversion-in-repair text command is enabled.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/repair_improve/repair").execute(*args, **kwargs)
            def improve_quality(self, *args, **kwargs):
                """
                Improves poor quality cells in the mesh, if possible.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/repair_improve/improve_quality").execute(*args, **kwargs)
            def report_poor_elements(self, *args, **kwargs):
                """
                Reports invalid and poor quality elements.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/repair_improve/report_poor_elements").execute(*args, **kwargs)
            def allow_repair_at_boundaries(self, *args, **kwargs):
                """
                Allows the adjustment of the positions of nodes on boundaries as part of the mesh repairs performed by the mesh/repair-improve/repair text command.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/repair_improve/allow_repair_at_boundaries").execute(*args, **kwargs)
            def repair_face_handedness(self, *args, **kwargs):
                """
                Modifies cell centroids to repair meshes that contain left-handed faces without face node order problems.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/repair_improve/repair_face_handedness").execute(*args, **kwargs)

        class anisotropic_adaption(TUIMenu):
            """
            Enter the anisotropic adaption menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.operations = self.__class__.operations(service, version, mode, path + ["operations"])
                self.target = self.__class__.target(service, version, mode, path + ["target"])
                self.indicator = self.__class__.indicator(service, version, mode, path + ["indicator"])
                super().__init__(service, version, mode, path)
            def adapt_mesh(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/anisotropic_adaption/adapt_mesh").execute(*args, **kwargs)
            def iterations(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/anisotropic_adaption/iterations").execute(*args, **kwargs)
            def fixed_zones(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/anisotropic_adaption/fixed_zones").execute(*args, **kwargs)

            class operations(TUIMenu):
                """
                Enter the anisotropic adaption operations menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def refine(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/anisotropic_adaption/operations/refine").execute(*args, **kwargs)
                def coarsen(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/anisotropic_adaption/operations/coarsen").execute(*args, **kwargs)
                def move(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/anisotropic_adaption/operations/move").execute(*args, **kwargs)
                def swap(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/anisotropic_adaption/operations/swap").execute(*args, **kwargs)

            class target(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def factor_of_cells(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/anisotropic_adaption/target/factor_of_cells").execute(*args, **kwargs)
                def target_type(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/anisotropic_adaption/target/target_type").execute(*args, **kwargs)
                def number_of_cells(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/anisotropic_adaption/target/number_of_cells").execute(*args, **kwargs)

            class indicator(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def indicator_type(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/anisotropic_adaption/indicator/indicator_type").execute(*args, **kwargs)
                def single_scalar_fn(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/anisotropic_adaption/indicator/single_scalar_fn").execute(*args, **kwargs)
                def multi_scalar_fn(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/mesh/anisotropic_adaption/indicator/multi_scalar_fn").execute(*args, **kwargs)

        class modify_zones(TUIMenu):
            """
            Enters the zone modification menu. For a description of the items in this menu, see define/boundary-conditions/modify-zones.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def append_mesh(self, *args, **kwargs):
                """
                Append new mesh.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/append_mesh").execute(*args, **kwargs)
            def copy_mesh_to_mrf_motion(self, *args, **kwargs):
                """
                Copy motion variable values for origin, axis and velocities from Mesh Motion to Frame Motion.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/copy_mesh_to_mrf_motion").execute(*args, **kwargs)
            def rotate_zone(self, *args, **kwargs):
                """
                Rotate nodal coordinates of input cell zones.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/rotate_zone").execute(*args, **kwargs)
            def orient_face_zone(self, *args, **kwargs):
                """
                Orient the face zone.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/orient_face_zone").execute(*args, **kwargs)
            def copy_move_cell_zone(self, *args, **kwargs):
                """
                Copy and translate or rotate a cell zone.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/copy_move_cell_zone").execute(*args, **kwargs)
            def merge_zones(self, *args, **kwargs):
                """
                Merge zones of the same type and condition into one.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/merge_zones").execute(*args, **kwargs)
            def sep_face_zone_region(self, *args, **kwargs):
                """
                Separate a face zone based on contiguous regions.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/sep_face_zone_region").execute(*args, **kwargs)
            def list_zones(self, *args, **kwargs):
                """
                List zone IDs, types, kinds, and names.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/list_zones").execute(*args, **kwargs)
            def copy_mrf_to_mesh_motion(self, *args, **kwargs):
                """
                Copy motion variable values for origin, axis and velocities from Frame Motion to Mesh Motion.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/copy_mrf_to_mesh_motion").execute(*args, **kwargs)
            def recreate_all_shells(self, *args, **kwargs):
                """
                Create shell on all the walls where which were deleted using the command delete-all-shells.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/recreate_all_shells").execute(*args, **kwargs)
            def delete_all_shells(self, *args, **kwargs):
                """
                Delete all shell zones and switch off shell conduction on all the walls. These zones can be recreated using the command recreate-all-shells.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/delete_all_shells").execute(*args, **kwargs)
            def make_periodic(self, *args, **kwargs):
                """
                Attempt to establish conformal periodic face zone connectivity.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/make_periodic").execute(*args, **kwargs)
            def extrude_face_zone_para(self, *args, **kwargs):
                """
                Extrude a face thread a specified distance based on a distance and a list of parametric locations between 0 and 1 (eg. 0 0.2 0.4 0.8 1.0).
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/extrude_face_zone_para").execute(*args, **kwargs)
            def change_zone_state(self, *args, **kwargs):
                """
                Change the realgas material state for a zone.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/change_zone_state").execute(*args, **kwargs)
            def sep_cell_zone_region(self, *args, **kwargs):
                """
                Separate a cell zone based on contiguous regions.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/sep_cell_zone_region").execute(*args, **kwargs)
            def convert_all_solid_mrf_to_solid_motion(self, *args, **kwargs):
                """
                Change all solid zones motion specification from MRF to solid motion.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/convert_all_solid_mrf_to_solid_motion").execute(*args, **kwargs)
            def sep_face_zone_angle(self, *args, **kwargs):
                """
                Separate a face zone based on significant angle.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/sep_face_zone_angle").execute(*args, **kwargs)
            def change_zone_phase(self, *args, **kwargs):
                """
                Change the realgas phase for a zone.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/change_zone_phase").execute(*args, **kwargs)
            def replace_zone(self, *args, **kwargs):
                """
                Replace a cell zone.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/replace_zone").execute(*args, **kwargs)
            def sep_cell_zone_mark(self, *args, **kwargs):
                """
                Separate a cell zone based on cell marking.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/sep_cell_zone_mark").execute(*args, **kwargs)
            def translate_zone(self, *args, **kwargs):
                """
                Translate nodal coordinates of input cell zones.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/translate_zone").execute(*args, **kwargs)
            def create_all_shell_threads(self, *args, **kwargs):
                """
                Mark all finite thickness wall for shell creation. Shell zones will be created at the start of iterations.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/create_all_shell_threads").execute(*args, **kwargs)
            def create_periodic_interface(self, *args, **kwargs):
                """
                Create a conformal or non-conformal periodic interface.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/create_periodic_interface").execute(*args, **kwargs)
            def zone_name(self, *args, **kwargs):
                """
                Give a zone a new name.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/zone_name").execute(*args, **kwargs)
            def mrf_to_sliding_mesh(self, *args, **kwargs):
                """
                Change motion specification from MRF to moving mesh.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/mrf_to_sliding_mesh").execute(*args, **kwargs)
            def slit_face_zone(self, *args, **kwargs):
                """
                Slit a two-sided wall into two connected wall zones.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/slit_face_zone").execute(*args, **kwargs)
            def slit_interior_between_diff_solids(self, *args, **kwargs):
                """
                Slit interior created between different solids into coupled walls.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/slit_interior_between_diff_solids").execute(*args, **kwargs)
            def sep_face_zone_mark(self, *args, **kwargs):
                """
                Separate a face zone based on cell marking.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/sep_face_zone_mark").execute(*args, **kwargs)
            def sep_face_zone_face(self, *args, **kwargs):
                """
                Separate each face in a zone into unique zone.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/sep_face_zone_face").execute(*args, **kwargs)
            def scale_zone(self, *args, **kwargs):
                """
                Scale nodal coordinates of input cell zones.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/scale_zone").execute(*args, **kwargs)
            def fuse_face_zones(self, *args, **kwargs):
                """
                Attempt to fuse zones by removing duplicate faces and nodes.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/fuse_face_zones").execute(*args, **kwargs)
            def slit_periodic(self, *args, **kwargs):
                """
                Slit a periodic zone into two symmetry zones.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/slit_periodic").execute(*args, **kwargs)
            def append_mesh_data(self, *args, **kwargs):
                """
                Append new mesh with data.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/append_mesh_data").execute(*args, **kwargs)
            def delete_cell_zone(self, *args, **kwargs):
                """
                Delete a cell thread.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/delete_cell_zone").execute(*args, **kwargs)
            def zone_type(self, *args, **kwargs):
                """
                Set a zone's type.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/zone_type").execute(*args, **kwargs)
            def extrude_face_zone_delta(self, *args, **kwargs):
                """
                Extrude a face thread a specified distance based on a list of deltas.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/extrude_face_zone_delta").execute(*args, **kwargs)
            def deactivate_cell_zone(self, *args, **kwargs):
                """
                Deactivate cell thread.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/deactivate_cell_zone").execute(*args, **kwargs)
            def activate_cell_zone(self, *args, **kwargs):
                """
                Activate a cell thread.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/activate_cell_zone").execute(*args, **kwargs)
            def matching_tolerance(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/modify_zones/matching_tolerance").execute(*args, **kwargs)

        class geometry(TUIMenu):
            """
            Enter the auxiliary geometry menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def list_properties(self, *args, **kwargs):
                """
                List properties of an object.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/geometry/list_properties").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an object.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/geometry/delete").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an object.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/geometry/edit").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Display geometry.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/geometry/display").execute(*args, **kwargs)
            def add(self, *args, **kwargs):
                """
                Add a new object.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/geometry/add").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List objects.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/geometry/list").execute(*args, **kwargs)
            def display_options(self, *args, **kwargs):
                """
                Display options.
                """
                return PyMenu(self._service, self._version, self._mode, "/mesh/geometry/display_options").execute(*args, **kwargs)

    class file(TUIMenu):
        """
        Enter the file menu.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            self.transient_export = self.__class__.transient_export(service, version, mode, path + ["transient_export"])
            self.import_ = self.__class__.import_(service, version, mode, path + ["import_"])
            self.solution_files = self.__class__.solution_files(service, version, mode, path + ["solution_files"])
            self.em_mapping = self.__class__.em_mapping(service, version, mode, path + ["em_mapping"])
            self.table_manager = self.__class__.table_manager(service, version, mode, path + ["table_manager"])
            self.project_beta = self.__class__.project_beta(service, version, mode, path + ["project_beta"])
            self.auto_save = self.__class__.auto_save(service, version, mode, path + ["auto_save"])
            self.interpolate = self.__class__.interpolate(service, version, mode, path + ["interpolate"])
            self.export = self.__class__.export(service, version, mode, path + ["export"])
            self.cffio_options = self.__class__.cffio_options(service, version, mode, path + ["cffio_options"])
            self.fsi = self.__class__.fsi(service, version, mode, path + ["fsi"])
            self.parametric_project = self.__class__.parametric_project(service, version, mode, path + ["parametric_project"])
            super().__init__(service, version, mode, path)
        def write_flamelet(self, *args, **kwargs):
            """
            Writes a flamelet file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_flamelet").execute(*args, **kwargs)
        def set_tui_version(self, *args, **kwargs):
            """
            Set the version of the TUI commands.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/set_tui_version").execute(*args, **kwargs)
        def write_isat_table(self, *args, **kwargs):
            """
            Writes ISAT Table.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_isat_table").execute(*args, **kwargs)
        def cff_files(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/file/cff_files").execute(*args, **kwargs)
        def set_idle_timeout(self, *args, **kwargs):
            """
            Set the idle timeout.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/set_idle_timeout").execute(*args, **kwargs)
        def export_to_cfd_post(self, *args, **kwargs):
            """
            Exports data files that are compatible with CFD-Post and EnSight (that is, .cdat and .cst files) and opens CFD-Post, if desired.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/export_to_cfd_post").execute(*args, **kwargs)
        def read_case_settings(self, *args, **kwargs):
            """
            Read a case file while skipping mesh elements.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_case_settings").execute(*args, **kwargs)
        def read_journal(self, *args, **kwargs):
            """
            Read a journal file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_journal").execute(*args, **kwargs)
        def stop_journal(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/file/stop_journal").execute(*args, **kwargs)
        def sync_workbench(self, *args, **kwargs):
            """
            Directly updates Workbench with the most recent Fluent changes. This command is only available when running ANSYS Fluent in Workbench.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/sync_workbench").execute(*args, **kwargs)
        def start_journal(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/file/start_journal").execute(*args, **kwargs)
        def read_settings(self, *args, **kwargs):
            """
            Reads and sets boundary conditions from a specified file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_settings").execute(*args, **kwargs)
        def write_selected_defined_profiles(self, *args, **kwargs):
            """
            Set profile names, only these profile names which will be used during writing of \\*.csv profiles.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_selected_defined_profiles").execute(*args, **kwargs)
        def read_field_functions(self, *args, **kwargs):
            """
            Reads custom field function definitions from a file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_field_functions").execute(*args, **kwargs)
        def stop_macro(self, *args, **kwargs):
            """
            Stops recording input to a macro.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/stop_macro").execute(*args, **kwargs)
        def read_injections(self, *args, **kwargs):
            """
            Reads all DPM injections from a file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_injections").execute(*args, **kwargs)
        def read_rays(self, *args, **kwargs):
            """
            Reads a ray file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_rays").execute(*args, **kwargs)
        def write_profile(self, *args, **kwargs):
            """
            Writes surface data as a boundary profile file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_profile").execute(*args, **kwargs)
        def write_settings(self, *args, **kwargs):
            """
            Writes out current boundary conditions in use.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_settings").execute(*args, **kwargs)
        def write_gpu_restart(self, *args, **kwargs):
            """
            Write gpuapp restart case and data files.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_gpu_restart").execute(*args, **kwargs)
        def start_transcript(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/file/start_transcript").execute(*args, **kwargs)
        def read_profile(self, *args, **kwargs):
            """
            Reads boundary profile data.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_profile").execute(*args, **kwargs)
        def write_case_data(self, *args, **kwargs):
            """
            Writes a case and a data file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_case_data").execute(*args, **kwargs)
        def set_err_on_inval_cmd(self, *args, **kwargs):
            """
            Set whether to abort journal replay on invalid command.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/set_err_on_inval_cmd").execute(*args, **kwargs)
        def replace_mesh(self, *args, **kwargs):
            """
            Replaces the mesh with a new one while preserving settings.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/replace_mesh").execute(*args, **kwargs)
        def write_data(self, *args, **kwargs):
            """
            Writes a data file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_data").execute(*args, **kwargs)
        def read_viewfactors(self, *args, **kwargs):
            """
            Reads view factors from a file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_viewfactors").execute(*args, **kwargs)
        def write_circumferential_averaged_profile(self, *args, **kwargs):
            """
            Write surface data as a boundary profile file. To use \\*.csv format specify filename with .csv suffix.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_circumferential_averaged_profile").execute(*args, **kwargs)
        def async_optimize(self, *args, **kwargs):
            """
            Chooses whether to optimize file I/O using scratch disks and asynchronous operations.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/async_optimize").execute(*args, **kwargs)
        def read_data(self, *args, **kwargs):
            """
            Reads a data file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_data").execute(*args, **kwargs)
        def show_configuration(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/file/show_configuration").execute(*args, **kwargs)
        def read_transient_table(self, *args, **kwargs):
            """
            Reads table of transient boundary profile data.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_transient_table").execute(*args, **kwargs)
        def set_target_reference_frame_for_write_profiles(self, *args, **kwargs):
            """
            Set reference frame options, which will be used for position transformation during writing of profiles.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/set_target_reference_frame_for_write_profiles").execute(*args, **kwargs)
        def reload_setup(self, *args, **kwargs):
            """
            Discards any changes in the current ANSYS Fluent in Workbench session and removes any corresponding data from the Solution cell. This command is only available when running ANSYS Fluent in Workbench.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/reload_setup").execute(*args, **kwargs)
        def close_without_save(self, *args, **kwargs):
            """
            Exits ANSYS Fluent without saving data in Workbench. This command is only available when running ANSYS Fluent in Workbench.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/close_without_save").execute(*args, **kwargs)
        def write_injections(self, *args, **kwargs):
            """
            Writes out selected DPM injections to a file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_injections").execute(*args, **kwargs)
        def read_pdf(self, *args, **kwargs):
            """
            Reads a PDF file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_pdf").execute(*args, **kwargs)
        def define_macro(self, *args, **kwargs):
            """
            Saves input to a named macro.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/define_macro").execute(*args, **kwargs)
        def write_currently_defined_profiles(self, *args, **kwargs):
            """
            Write currently defined profiles. To use \\*.csv format specify filename with .csv suffix.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_currently_defined_profiles").execute(*args, **kwargs)
        def write_case(self, *args, **kwargs):
            """
            Write a case file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_case").execute(*args, **kwargs)
        def write_field_functions(self, *args, **kwargs):
            """
            Writes the currently defined custom field functions to a file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_field_functions").execute(*args, **kwargs)
        def read_case(self, *args, **kwargs):
            """
            Read a case file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_case").execute(*args, **kwargs)
        def read_isat_table(self, *args, **kwargs):
            """
            Reads ISAT Table.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_isat_table").execute(*args, **kwargs)
        def write_fan_profile(self, *args, **kwargs):
            """
            Computes radial profiles for a fan zone and writes them to a profile file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_fan_profile").execute(*args, **kwargs)
        def single_precision_coordinates(self, *args, **kwargs):
            """
            Specifies whether the nodal coordinates should be written in single precision (rather than the default double precision). This text command is only available in the single-precision version of ANSYS Fluent.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/single_precision_coordinates").execute(*args, **kwargs)
        def stop_transcript(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/file/stop_transcript").execute(*args, **kwargs)
        def write_pdat(self, *args, **kwargs):
            """
            Enables / disables the attempt to save .pdat files. Note that this text command is no longer supported.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_pdat").execute(*args, **kwargs)
        def write_macros(self, *args, **kwargs):
            """
            Writes the currently defined macros to a file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_macros").execute(*args, **kwargs)
        def read_case_data(self, *args, **kwargs):
            """
            Reads a case and a data file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_case_data").execute(*args, **kwargs)
        def confirm_overwrite(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/file/confirm_overwrite").execute(*args, **kwargs)
        def load_act_tool(self, *args, **kwargs):
            """
            Load ACT Start Page.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/load_act_tool").execute(*args, **kwargs)
        def read_macros(self, *args, **kwargs):
            """
            Reads macro definitions from a file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_macros").execute(*args, **kwargs)
        def execute_macro(self, *args, **kwargs):
            """
            Runs a previously defined macro.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/execute_macro").execute(*args, **kwargs)
        def data_file_options(self, *args, **kwargs):
            """
            Sets derived quantities to be written in data file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/data_file_options").execute(*args, **kwargs)
        def read_case_info(self, *args, **kwargs):
            """
            Read basic case info.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_case_info").execute(*args, **kwargs)
        def write_merge_profiles(self, *args, **kwargs):
            """
            Writes a .csv file with the selected surfaces consolidated into one set of data points.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_merge_profiles").execute(*args, **kwargs)
        def write_pdf(self, *args, **kwargs):
            """
            Writes a pdf file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_pdf").execute(*args, **kwargs)
        def write_boundary_mesh(self, *args, **kwargs):
            """
            Writes the boundary mesh to a file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_boundary_mesh").execute(*args, **kwargs)
        def write_cleanup_script(self, *args, **kwargs):
            """
            Writes the cleanup-script-file for ANSYS Fluent.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/write_cleanup_script").execute(*args, **kwargs)
        def convert_hanging_nodes_during_read(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/file/convert_hanging_nodes_during_read").execute(*args, **kwargs)
        def binary_legacy_files(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/file/binary_legacy_files").execute(*args, **kwargs)
        def read_surface_clusters(self, *args, **kwargs):
            """
            Reads surface clusters from a file.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/read_surface_clusters").execute(*args, **kwargs)
        def set_batch_options(self, *args, **kwargs):
            """
            Sets the batch options.
            """
            return PyMenu(self._service, self._version, self._mode, "/file/set_batch_options").execute(*args, **kwargs)

        class transient_export(TUIMenu):
            """
            Enter the export menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.settings = self.__class__.settings(service, version, mode, path + ["settings"])
                super().__init__(service, version, mode, path)
            def ensight_gold_parallel_volume(self, *args, **kwargs):
                """
                Writes EnSight Gold geometry, velocity, and scalar files for cell zones in a parallel format suitable for ANSYS Ensight Enterprise.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/ensight_gold_parallel_volume").execute(*args, **kwargs)
            def common_fluids_format_post(self, *args, **kwargs):
                """
                Write an CFF Post-Only file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/common_fluids_format_post").execute(*args, **kwargs)
            def fieldview_unstruct_mesh(self, *args, **kwargs):
                """
                Writes a FIELDVIEW unstructured mesh only file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/fieldview_unstruct_mesh").execute(*args, **kwargs)
            def ensight_gold_transient(self, *args, **kwargs):
                """
                Writes EnSight Gold geometry, velocity, and scalar files.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/ensight_gold_transient").execute(*args, **kwargs)
            def cdat_for_cfd_post__and__ensight(self, *args, **kwargs):
                """
                Write a CDAT for CFD-Post & EnSight file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/cdat_for_cfd_post__and__ensight").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Deletes transient exports.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/delete").execute(*args, **kwargs)
            def fast_solution(self, *args, **kwargs):
                """
                Writes a FAST/Plot3D unstructured solution file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/fast_solution").execute(*args, **kwargs)
            def patran_neutral(self, *args, **kwargs):
                """
                Writes a PATRAN neutral file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/patran_neutral").execute(*args, **kwargs)
            def taitherm(self, *args, **kwargs):
                """
                Writes a TAITherm file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/taitherm").execute(*args, **kwargs)
            def abaqus(self, *args, **kwargs):
                """
                Writes an ABAQUS file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/abaqus").execute(*args, **kwargs)
            def ascii(self, *args, **kwargs):
                """
                Writes an ASCII file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/ascii").execute(*args, **kwargs)
            def ensight_gold_from_existing_files(self, *args, **kwargs):
                """
                Writes EnSight Gold files using ANSYS Fluent case files.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/ensight_gold_from_existing_files").execute(*args, **kwargs)
            def fieldview_unstruct(self, *args, **kwargs):
                """
                Writes a FIELDVIEW unstructured combined file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/fieldview_unstruct").execute(*args, **kwargs)
            def mechanical_apdl_input(self, *args, **kwargs):
                """
                Writes a Mechanical APDL input file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/mechanical_apdl_input").execute(*args, **kwargs)
            def particle_history_data(self, *args, **kwargs):
                """
                Sets up an automatic particle-history data export.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/particle_history_data").execute(*args, **kwargs)
            def ensight_dvs_surfaces(self, *args, **kwargs):
                """
                Write post-processing data (geometry, velocity and scalars) for surfaces using EnSight Dynamic Visualization Store Interface.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/ensight_dvs_surfaces").execute(*args, **kwargs)
            def nastran(self, *args, **kwargs):
                """
                Writes a NASTRAN file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/nastran").execute(*args, **kwargs)
            def fieldview_unstruct_surfaces(self, *args, **kwargs):
                """
                Writes FIELDVIEW unstructured combined file for surfaces.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/fieldview_unstruct_surfaces").execute(*args, **kwargs)
            def cgns(self, *args, **kwargs):
                """
                Writes a CGNS file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/cgns").execute(*args, **kwargs)
            def ensight_dvs_volume(self, *args, **kwargs):
                """
                Write post-processing data (geometry, velocity and scalars) for cell zones and boundaries attached to them using EnSight Dynamic Visualization Store Interface.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/ensight_dvs_volume").execute(*args, **kwargs)
            def dx(self, *args, **kwargs):
                """
                Writes an IBM Data Explorer format file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/dx").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edits transient exports.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/edit").execute(*args, **kwargs)
            def ensight_gold_parallel_surfaces(self, *args, **kwargs):
                """
                Writes EnSight Gold geometry, velocity, and scalar files for surfaces in a parallel format suitable for ANSYS Ensight Enterprise.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/ensight_gold_parallel_surfaces").execute(*args, **kwargs)
            def avs(self, *args, **kwargs):
                """
                Writes an AVS UCD file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/avs").execute(*args, **kwargs)
            def tecplot(self, *args, **kwargs):
                """
                Write a Tecplot+3DV format file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/tecplot").execute(*args, **kwargs)
            def fieldview_unstruct_data(self, *args, **kwargs):
                """
                Writes a FIELDVIEW unstructured results only file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/fieldview_unstruct_data").execute(*args, **kwargs)
            def fast(self, *args, **kwargs):
                """
                Writes a FAST/Plot3D unstructured mesh velocity scalar file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/fast").execute(*args, **kwargs)
            def ideas(self, *args, **kwargs):
                """
                Writes an I-deas universal file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/ideas").execute(*args, **kwargs)
            def ensight_dvs(self, *args, **kwargs):
                """
                Write post-processing data (geometry, velocity and scalars) for cell and face zones using EnSight Dynamic Visualization Store Interface.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/transient_export/ensight_dvs").execute(*args, **kwargs)

            class settings(TUIMenu):
                """
                Enters the automatic export settings menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def cfd_post_compatible(self, *args, **kwargs):
                    """
                    Specifies when case files are written with the .cdat and .cst files exported for Ansys CFD-Post. Note that this setting is ignored if the Write Case File Every Time option is enabled in the Automatic Export dialog box, which is always the case starting in Release 2021 R1.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/transient_export/settings/cfd_post_compatible").execute(*args, **kwargs)

        class import_(TUIMenu):
            """
            Enter the import menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.cfx = self.__class__.cfx(service, version, mode, path + ["cfx"])
                self.abaqus = self.__class__.abaqus(service, version, mode, path + ["abaqus"])
                self.cgns = self.__class__.cgns(service, version, mode, path + ["cgns"])
                self.lstc = self.__class__.lstc(service, version, mode, path + ["lstc"])
                self.tecplot = self.__class__.tecplot(service, version, mode, path + ["tecplot"])
                self.nastran = self.__class__.nastran(service, version, mode, path + ["nastran"])
                self.partition = self.__class__.partition(service, version, mode, path + ["partition"])
                self.plot3d = self.__class__.plot3d(service, version, mode, path + ["plot3d"])
                self.patran = self.__class__.patran(service, version, mode, path + ["patran"])
                self.mechanical_apdl = self.__class__.mechanical_apdl(service, version, mode, path + ["mechanical_apdl"])
                super().__init__(service, version, mode, path)
            def gambit(self, *args, **kwargs):
                """
                Read a GAMBIT neutral file as a case file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/import_/gambit").execute(*args, **kwargs)
            def flamelet(self, *args, **kwargs):
                """
                Import a flamelet file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/import_/flamelet").execute(*args, **kwargs)
            def prebfc_structured(self, *args, **kwargs):
                """
                Read a formatted preBFC structured mesh (grid) file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/import_/prebfc_structured").execute(*args, **kwargs)
            def fmu_file(self, *args, **kwargs):
                """
                Read a FMU file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/import_/fmu_file").execute(*args, **kwargs)
            def ptc_mechanica(self, *args, **kwargs):
                """
                Read a PTC Mechanica file as a case file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/import_/ptc_mechanica").execute(*args, **kwargs)
            def fluent4_case(self, *args, **kwargs):
                """
                Read a formatted Fluent 4 case file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/import_/fluent4_case").execute(*args, **kwargs)
            def ensight(self, *args, **kwargs):
                """
                Read an Ensight file as a case file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/import_/ensight").execute(*args, **kwargs)
            def fidap(self, *args, **kwargs):
                """
                Read a FIDAP neutral file as a case file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/import_/fidap").execute(*args, **kwargs)
            def chemkin_mechanism(self, *args, **kwargs):
                """
                Read a CHEMKIN mechanism file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/import_/chemkin_mechanism").execute(*args, **kwargs)
            def marc_post(self, *args, **kwargs):
                """
                Read a MARC POST file as a case file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/import_/marc_post").execute(*args, **kwargs)
            def chemkin_report_each_line(self, *args, **kwargs):
                """
                Enable/disable reporting after reading each line.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/import_/chemkin_report_each_line").execute(*args, **kwargs)
            def ideas_universal(self, *args, **kwargs):
                """
                Read an IDEAS Universal file as a case file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/import_/ideas_universal").execute(*args, **kwargs)
            def hypermesh(self, *args, **kwargs):
                """
                Read a HYPERMESH file as a case file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/import_/hypermesh").execute(*args, **kwargs)

            class cfx(TUIMenu):
                """
                Enter the CFX menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def definition(self, *args, **kwargs):
                    """
                    Read a CFX definition file as a case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/cfx/definition").execute(*args, **kwargs)
                def result(self, *args, **kwargs):
                    """
                    Read a CFX result file as a case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/cfx/result").execute(*args, **kwargs)

            class abaqus(TUIMenu):
                """
                Enter the Abaqus menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def fil(self, *args, **kwargs):
                    """
                    Read an Abaqus .fil result file as a case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/abaqus/fil").execute(*args, **kwargs)
                def input(self, *args, **kwargs):
                    """
                    Read an Abaqus Input file as a case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/abaqus/input").execute(*args, **kwargs)
                def odb(self, *args, **kwargs):
                    """
                    Read an Abaqus odb file as a case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/abaqus/odb").execute(*args, **kwargs)

            class cgns(TUIMenu):
                """
                Enter the CGNS menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def data(self, *args, **kwargs):
                    """
                    Read data from CGNS file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/cgns/data").execute(*args, **kwargs)
                def mesh_data(self, *args, **kwargs):
                    """
                    Read a CGNS file as a case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/cgns/mesh_data").execute(*args, **kwargs)
                def mesh(self, *args, **kwargs):
                    """
                    Read a CGNS file as a case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/cgns/mesh").execute(*args, **kwargs)

            class lstc(TUIMenu):
                """
                Enter the LSTC menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def input(self, *args, **kwargs):
                    """
                    Read an LSTC input file as a case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/lstc/input").execute(*args, **kwargs)
                def state(self, *args, **kwargs):
                    """
                    Read an LSTC result file as a case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/lstc/state").execute(*args, **kwargs)

            class tecplot(TUIMenu):
                """
                Enter the Tecplot menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def mesh(self, *args, **kwargs):
                    """
                    Read a Tecplot binary file as a case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/tecplot/mesh").execute(*args, **kwargs)

            class nastran(TUIMenu):
                """
                Enter the NASTRAN menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def output2(self, *args, **kwargs):
                    """
                    Read a NASTRAN op2 file as a case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/nastran/output2").execute(*args, **kwargs)
                def bulkdata(self, *args, **kwargs):
                    """
                    Read a NASTRAN file as a case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/nastran/bulkdata").execute(*args, **kwargs)

            class partition(TUIMenu):
                """
                Enter the partition menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def metis(self, *args, **kwargs):
                    """
                    Read and partition a Fluent 5 case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/partition/metis").execute(*args, **kwargs)
                def metis_zone(self, *args, **kwargs):
                    """
                    Read and partition a Fluent 5 case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/partition/metis_zone").execute(*args, **kwargs)

            class plot3d(TUIMenu):
                """
                Enter the PLOT3D menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def mesh(self, *args, **kwargs):
                    """
                    Read a PLOT3D file as a case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/plot3d/mesh").execute(*args, **kwargs)

            class patran(TUIMenu):
                """
                Enter the PATRAN menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def neutral(self, *args, **kwargs):
                    """
                    Read a PATRAN Neutral file (zones defined by named components) as a case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/patran/neutral").execute(*args, **kwargs)

            class mechanical_apdl(TUIMenu):
                """
                Enter the Mechanical APDL menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def result(self, *args, **kwargs):
                    """
                    Read an Mechanical APDL result file as a case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/mechanical_apdl/result").execute(*args, **kwargs)
                def input(self, *args, **kwargs):
                    """
                    Read an Mechanical APDL file as a case file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/import_/mechanical_apdl/input").execute(*args, **kwargs)

        class solution_files(TUIMenu):
            """
            Enters the solution files menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def delete_solution(self, *args, **kwargs):
                """
                Deletes solution files.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/solution_files/delete_solution").execute(*args, **kwargs)
            def load_solution(self, *args, **kwargs):
                """
                Loads a solution file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/solution_files/load_solution").execute(*args, **kwargs)
            def print_solution_files(self, *args, **kwargs):
                """
                Prints a list of available solution files.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/solution_files/print_solution_files").execute(*args, **kwargs)

        class em_mapping(TUIMenu):
            """
            Enters the electromagnetic loss mapping menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def maintain_loss_on_initialization(self, *args, **kwargs):
                """
                Maintains the loss data provided by Maxwell even if solution is initialized.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/em_mapping/maintain_loss_on_initialization").execute(*args, **kwargs)
            def remove_loss_only(self, *args, **kwargs):
                """
                Removes the loss data provided by Maxwell and keeps all other solution data.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/em_mapping/remove_loss_only").execute(*args, **kwargs)
            def surface_energy_source(self, *args, **kwargs):
                """
                Loss data provided by Ansoft will be assigned to Fluent for selected wall zones.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/em_mapping/surface_energy_source").execute(*args, **kwargs)
            def volumetric_energy_source(self, *args, **kwargs):
                """
                Loss data provided by Ansoft will be assigned to Fluent for selected cell zones.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/em_mapping/volumetric_energy_source").execute(*args, **kwargs)

        class table_manager(TUIMenu):
            """
            Enters the table file manager menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def list_tables(self, *args, **kwargs):
                """
                Lists all locally-stored tables.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/table_manager/list_tables").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                Lists the properties of a locally-stored table.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/table_manager/list_properties").execute(*args, **kwargs)
            def read_rgp_file(self, *args, **kwargs):
                """
                Imports a set of Real Gas Property (RGP) tables from a file into local storage.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/table_manager/read_rgp_file").execute(*args, **kwargs)
            def rename(self, *args, **kwargs):
                """
                Renames a locally-stored table.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/table_manager/rename").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Deletes a table from local storage.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/table_manager/delete").execute(*args, **kwargs)
            def read_matrix_data_file(self, *args, **kwargs):
                """
                Imports a matrix type table from a file into local storage.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/table_manager/read_matrix_data_file").execute(*args, **kwargs)
            def store_in_case_file(self, *args, **kwargs):
                """
                Sets the persistence mode for RGP tables (embedded in case file or rely on external file).
                """
                return PyMenu(self._service, self._version, self._mode, "/file/table_manager/store_in_case_file").execute(*args, **kwargs)
            def list_matrix_data(self, *args, **kwargs):
                """
                Lists the data of a matrix type locally-stored table.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/table_manager/list_matrix_data").execute(*args, **kwargs)

        class project_beta(TUIMenu):
            """
            Enter to create new project, open project, save and archive project.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def save(self, *args, **kwargs):
                """
                Save Project.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/project_beta/save").execute(*args, **kwargs)
            def save_as_copy(self, *args, **kwargs):
                """
                Save As Copy.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/project_beta/save_as_copy").execute(*args, **kwargs)
            def new(self, *args, **kwargs):
                """
                Create New Project.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/project_beta/new").execute(*args, **kwargs)
            def save_as(self, *args, **kwargs):
                """
                Save As Project.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/project_beta/save_as").execute(*args, **kwargs)
            def open(self, *args, **kwargs):
                """
                Open project.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/project_beta/open").execute(*args, **kwargs)
            def archive(self, *args, **kwargs):
                """
                Archive Project.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/project_beta/archive").execute(*args, **kwargs)

        class auto_save(TUIMenu):
            """
            Enters the auto save menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def root_name(self, *args, **kwargs):
                """
                Specifies the root name for the files that are saved.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/auto_save/root_name").execute(*args, **kwargs)
            def max_files(self, *args, **kwargs):
                """
                Sets the maximum number of files. Once the maximum is reached, files will be erased as new files are written.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/auto_save/max_files").execute(*args, **kwargs)
            def append_file_name_with(self, *args, **kwargs):
                """
                Sets the suffix for auto-saved files. The file name can be appended by flow-time, time-step value, or by user-specified flags in file name.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/auto_save/append_file_name_with").execute(*args, **kwargs)
            def case_frequency(self, *args, **kwargs):
                """
                Specifies the frequency (in iterations, time steps, or flow time) with which case files are saved.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/auto_save/case_frequency").execute(*args, **kwargs)
            def retain_most_recent_files(self, *args, **kwargs):
                """
                Sets autosave to retain the 5 most recent files.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/auto_save/retain_most_recent_files").execute(*args, **kwargs)
            def save_data_file_every(self, *args, **kwargs):
                """
                Specifies the type and frequency of the data file to be saved.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/auto_save/save_data_file_every").execute(*args, **kwargs)
            def data_frequency(self, *args, **kwargs):
                """
                Specifies the frequency (in iterations, time steps, or flow time) with which data files are saved.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/auto_save/data_frequency").execute(*args, **kwargs)

        class interpolate(TUIMenu):
            """
            Interpolates data to/from another grid.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def read_data(self, *args, **kwargs):
                """
                Reads and interpolates data.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/interpolate/read_data").execute(*args, **kwargs)
            def write_data(self, *args, **kwargs):
                """
                Writes data for interpolation.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/interpolate/write_data").execute(*args, **kwargs)
            def zone_selection(self, *args, **kwargs):
                """
                Defines a list of cell zone IDs. If specified, interpolation data will be read/written for these cell zones only.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/interpolate/zone_selection").execute(*args, **kwargs)

        class export(TUIMenu):
            """
            Enter the export menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.settings = self.__class__.settings(service, version, mode, path + ["settings"])
                super().__init__(service, version, mode, path)
            def fieldview_unstruct(self, *args, **kwargs):
                """
                Writes FIELDVIEW unstructured combined file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/fieldview_unstruct").execute(*args, **kwargs)
            def nastran(self, *args, **kwargs):
                """
                Write a NASTRAN file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/nastran").execute(*args, **kwargs)
            def ensight_gold_parallel_surfaces(self, *args, **kwargs):
                """
                Writes EnSight Gold geometry, velocity, and scalar files for surfaces in a parallel format suitable for ANSYS Ensight Enterprise.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/ensight_gold_parallel_surfaces").execute(*args, **kwargs)
            def cdat_for_cfd_post__and__ensight(self, *args, **kwargs):
                """
                Write a CDAT for CFD-Post & EnSight file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/cdat_for_cfd_post__and__ensight").execute(*args, **kwargs)
            def fast_velocity(self, *args, **kwargs):
                """
                Writes FAST/Plot3D unstructured vector function file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/fast_velocity").execute(*args, **kwargs)
            def fast_scalar(self, *args, **kwargs):
                """
                Writes FAST/Plot3D unstructured scalar function file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/fast_scalar").execute(*args, **kwargs)
            def fieldview(self, *args, **kwargs):
                """
                Writes FIELDVIEW case and data files.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/fieldview").execute(*args, **kwargs)
            def ensight_dvs_surfaces(self, *args, **kwargs):
                """
                Write post-processing data (geometry, velocity and scalars) for surfaces using EnSight Dynamic Visualization Store Interface.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/ensight_dvs_surfaces").execute(*args, **kwargs)
            def ascii(self, *args, **kwargs):
                """
                Writes an ASCII file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/ascii").execute(*args, **kwargs)
            def ideas(self, *args, **kwargs):
                """
                Writes an I-deas universal file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/ideas").execute(*args, **kwargs)
            def fieldview_unstruct_data(self, *args, **kwargs):
                """
                Writes FIELDVIEW unstructured results-only file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/fieldview_unstruct_data").execute(*args, **kwargs)
            def custom_heat_flux(self, *args, **kwargs):
                """
                Writes a generic file for heat transfer.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/custom_heat_flux").execute(*args, **kwargs)
            def ensight_gold_parallel_volume(self, *args, **kwargs):
                """
                Writes EnSight Gold geometry, velocity, and scalar files for cell zones in a parallel format suitable for ANSYS Ensight Enterprise.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/ensight_gold_parallel_volume").execute(*args, **kwargs)
            def fast_solution(self, *args, **kwargs):
                """
                Writes FAST/Plot3D unstructured solution file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/fast_solution").execute(*args, **kwargs)
            def fieldview_unstruct_mesh(self, *args, **kwargs):
                """
                Writes FIELDVIEW unstructured mesh-only file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/fieldview_unstruct_mesh").execute(*args, **kwargs)
            def taitherm(self, *args, **kwargs):
                """
                Exports TAITherm file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/taitherm").execute(*args, **kwargs)
            def ensight_gold(self, *args, **kwargs):
                """
                Writes EnSight Gold geometry, velocity, and scalar files.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/ensight_gold").execute(*args, **kwargs)
            def dx(self, *args, **kwargs):
                """
                Writes an IBM Data Explorer format file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/dx").execute(*args, **kwargs)
            def ensight_dvs_volume(self, *args, **kwargs):
                """
                Write post-processing data (geometry, velocity and scalars) for cell zones and boundaries attached to them using EnSight Dynamic Visualization Store Interface.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/ensight_dvs_volume").execute(*args, **kwargs)
            def patran_neutral(self, *args, **kwargs):
                """
                Writes a PATRAN neutral file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/patran_neutral").execute(*args, **kwargs)
            def particle_history_data(self, *args, **kwargs):
                """
                Exports particle-history data.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/particle_history_data").execute(*args, **kwargs)
            def fieldview_unstruct_surfaces(self, *args, **kwargs):
                """
                Writes FIELDVIEW unstructured file for surfaces. You are prompted to select either [1], [2] or [3] to write either mesh-only, results-only, or combined for surfaces (respectively).
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/fieldview_unstruct_surfaces").execute(*args, **kwargs)
            def avs(self, *args, **kwargs):
                """
                Writes an AVS UCD file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/avs").execute(*args, **kwargs)
            def icemcfd_for_icepak(self, *args, **kwargs):
                """
                Writes a binary ICEM CFD domain file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/icemcfd_for_icepak").execute(*args, **kwargs)
            def ensight_dvs(self, *args, **kwargs):
                """
                Write post-processing data (geometry, velocity and scalars) for cell and face zones using EnSight Dynamic Visualization Store Interface.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/ensight_dvs").execute(*args, **kwargs)
            def mechanical_apdl_input(self, *args, **kwargs):
                """
                Writes a Mechanical APDL Input file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/mechanical_apdl_input").execute(*args, **kwargs)
            def tecplot(self, *args, **kwargs):
                """
                Writes a Tecplot+3DV format file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/tecplot").execute(*args, **kwargs)
            def ensight(self, *args, **kwargs):
                """
                Writes EnSight geometry, velocity, and scalar files.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/ensight").execute(*args, **kwargs)
            def system_coupling_definition_file_settings(self, *args, **kwargs):
                """
                Enters the system coupling file (.scp) menu.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/system_coupling_definition_file_settings").execute(*args, **kwargs)
            def gambit(self, *args, **kwargs):
                """
                Writes GAMBIT neutral file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/gambit").execute(*args, **kwargs)
            def patran_nodal(self, *args, **kwargs):
                """
                Writes a PATRAN nodal results file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/patran_nodal").execute(*args, **kwargs)
            def fast_mesh(self, *args, **kwargs):
                """
                Writes FAST/Plot3D unstructured mesh file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/fast_mesh").execute(*args, **kwargs)
            def abaqus(self, *args, **kwargs):
                """
                Writes an ABAQUS file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/abaqus").execute(*args, **kwargs)
            def mechanical_apdl(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/mechanical_apdl").execute(*args, **kwargs)
            def common_fluids_format_post(self, *args, **kwargs):
                """
                Writes common fluids format files (.cas.post and .dat.post) for mesh and data, respectively. These files are saved in the hierarchical data format.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/common_fluids_format_post").execute(*args, **kwargs)
            def cgns(self, *args, **kwargs):
                """
                Write a CGNS file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/cgns").execute(*args, **kwargs)
            def fieldview_data(self, *args, **kwargs):
                """
                Writes FIELDVIEW case and data files.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/export/fieldview_data").execute(*args, **kwargs)

            class settings(TUIMenu):
                """
                Enter the export settings menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def set_cgns_export_filetype(self, *args, **kwargs):
                    """
                    Select HDF5 or ADF as file format for CGNS.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/export/settings/set_cgns_export_filetype").execute(*args, **kwargs)
                def cgns_polyhedral_cpu_threads(self, *args, **kwargs):
                    """
                    Set CGNS NGON CPU threads.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/export/settings/cgns_polyhedral_cpu_threads").execute(*args, **kwargs)
                def cgns_mesh_type(self, *args, **kwargs):
                    """
                    Set CGNS NGON mode.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/file/export/settings/cgns_mesh_type").execute(*args, **kwargs)

        class cffio_options(TUIMenu):
            """
            Enters the cffio options menu, which provides options for the I/O of case and data files in the Common Fluids Format (CFF).
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def io_mode(self, *args, **kwargs):
                """
                Sets the I/O mode for writing CFF files.
                1. HOST: I/O is done serially by the host process.
                2. NODE0: I/O is done serially by the node 0 process.
                3. PARALLEL INDEPENDENT: I/O is done in parallel using the independent mode of MPI I/O.
                4. PARALLEL COLLECTIVE: I/O is done in parallel using the collective mode of MPI I/O.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/cffio_options/io_mode").execute(*args, **kwargs)
            def single_precision_data(self, *args, **kwargs):
                """
                Specifies whether the double-precision solver saves single-precision data when writing CFF data files, in order to reduce the size of the files.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/cffio_options/single_precision_data").execute(*args, **kwargs)
            def compression_level(self, *args, **kwargs):
                """
                Sets the compression level for CFF files. The compression level can be set between 0 and 9 with 0 being least compression (fastest) and 9 being highest compression (slowest).
                """
                return PyMenu(self._service, self._version, self._mode, "/file/cffio_options/compression_level").execute(*args, **kwargs)

        class fsi(TUIMenu):
            """
            Enters the fluid-structure interaction menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def write_fsi_mesh(self, *args, **kwargs):
                """
                Writes a fluid-structure interaction mesh file.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/fsi/write_fsi_mesh").execute(*args, **kwargs)
            def conserve_force(self, *args, **kwargs):
                """
                Conserve the forces for linear line, tri and tet elements.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/fsi/conserve_force").execute(*args, **kwargs)
            def display_fsi_mesh(self, *args, **kwargs):
                """
                Displays the mesh for a fluid-structure interaction.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/fsi/display_fsi_mesh").execute(*args, **kwargs)
            def read_fsi_mesh(self, *args, **kwargs):
                """
                Reads an FEM mesh for one-way data mapping from ANSYS Fluent.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/fsi/read_fsi_mesh").execute(*args, **kwargs)

        class parametric_project(TUIMenu):
            """
            Enter to open, save, archive parametric project.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def archive(self, *args, **kwargs):
                """
                Archive Project.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/parametric_project/archive").execute(*args, **kwargs)
            def save_as(self, *args, **kwargs):
                """
                Save As Project.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/parametric_project/save_as").execute(*args, **kwargs)
            def save(self, *args, **kwargs):
                """
                Save Project.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/parametric_project/save").execute(*args, **kwargs)
            def save_a_copy(self, *args, **kwargs):
                """
                Save a Copy.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/parametric_project/save_a_copy").execute(*args, **kwargs)
            def open(self, *args, **kwargs):
                """
                Open project.
                """
                return PyMenu(self._service, self._version, self._mode, "/file/parametric_project/open").execute(*args, **kwargs)

    class report(TUIMenu):
        """
        Enter the report menu.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            self.heat_exchanger = self.__class__.heat_exchanger(service, version, mode, path + ["heat_exchanger"])
            self.simulation_reports = self.__class__.simulation_reports(service, version, mode, path + ["simulation_reports"])
            self.forces = self.__class__.forces(service, version, mode, path + ["forces"])
            self.efficiency = self.__class__.efficiency(service, version, mode, path + ["efficiency"])
            self.modified_setting = self.__class__.modified_setting(service, version, mode, path + ["modified_setting"])
            self.system = self.__class__.system(service, version, mode, path + ["system"])
            self.virtual_blade_model = self.__class__.virtual_blade_model(service, version, mode, path + ["virtual_blade_model"])
            self.reference_values = self.__class__.reference_values(service, version, mode, path + ["reference_values"])
            self.icing = self.__class__.icing(service, version, mode, path + ["icing"])
            self.population_balance = self.__class__.population_balance(service, version, mode, path + ["population_balance"])
            self.fluxes = self.__class__.fluxes(service, version, mode, path + ["fluxes"])
            self.dpm_histogram = self.__class__.dpm_histogram(service, version, mode, path + ["dpm_histogram"])
            super().__init__(service, version, mode, path)
        def particle_summary(self, *args, **kwargs):
            """
            Prints summary report for all current particles.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/particle_summary").execute(*args, **kwargs)
        def print_histogram(self, *args, **kwargs):
            """
            Prints a histogram of a scalar quantity.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/print_histogram").execute(*args, **kwargs)
        def summary(self, *args, **kwargs):
            """
            Prints the current settings for physical models, boundary conditions, material properties, and solution parameters.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/summary").execute(*args, **kwargs)
        def dpm_extended_summary(self, *args, **kwargs):
            """
            Create an extended discrete phase summary report of the discrete phase injection(s). You can choose whether you want to save the extended report to a file or print it in the console window. For unsteady tracking, you will be asked whether you want to include in-domain particle/tracks in the report. You will be also prompted whether you want to select a single injection for the summary report. By default, all injections are included. The output depends on whether you have enabled the report/dpm-zone-summaries-per-injection? text command, in which case additional information is printed for escaped particles, such as per-injection data. Note that, for unsteady particle tracking, it is necessary to enable the report/dpm-zone-summaries-per-injection? text command before any particle parcels are injected into the domain.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/dpm_extended_summary").execute(*args, **kwargs)
        def mphase_summary(self, *args, **kwargs):
            """
            Prints summary report for a multiphase case setup.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/mphase_summary").execute(*args, **kwargs)
        def surface_integrals(self, *args, **kwargs):
            """
            Enters the surface integral menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/surface_integrals").execute(*args, **kwargs)
        def species_mass_flow(self, *args, **kwargs):
            """
            Prints list of species mass flow rate at inlets and outlets. This reports the mass flow rates of all species (in kg/s) flowing through the simulation boundaries.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/species_mass_flow").execute(*args, **kwargs)
        def dpm_sample_sort_file(self, *args, **kwargs):
            """
            Enables/disables writing of sorted DPM sample files.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/dpm_sample_sort_file").execute(*args, **kwargs)
        def dpm_zone_summaries_per_injection(self, *args, **kwargs):
            """
            Enables/disables calculation of the escaped mass per injection. Note that for unsteady particle tracking, if you want to report the mass of escaped particles per injection, this text command must be enabled before any particles are injected into the domain.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/dpm_zone_summaries_per_injection").execute(*args, **kwargs)
        def element_mass_flow(self, *args, **kwargs):
            """
            Prints list of element flow rate at inlets and outlets. This reports the mass flow rates of all chemical elements (in kg/s) flowing through the simulation boundaries.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/element_mass_flow").execute(*args, **kwargs)
        def dpm_sample(self, *args, **kwargs):
            """
            Samples trajectories at boundaries and lines/planes.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/dpm_sample").execute(*args, **kwargs)
        def uds_flow(self, *args, **kwargs):
            """
            Prints list of user-defined scalar flow rate at boundaries.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/uds_flow").execute(*args, **kwargs)
        def dpm_summary(self, *args, **kwargs):
            """
            Prints discrete phase summary report.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/dpm_summary").execute(*args, **kwargs)
        def path_line_summary(self, *args, **kwargs):
            """
            Prints pathline summary report.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/path_line_summary").execute(*args, **kwargs)
        def projected_surface_area(self, *args, **kwargs):
            """
            Computes the area of the projection of selected surfaces along the  ,  , or   axis.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/projected_surface_area").execute(*args, **kwargs)
        def aero_optical_distortions(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/report/aero_optical_distortions").execute(*args, **kwargs)
        def dpm_sample_output_udf(self, *args, **kwargs):
            """
            Allows you to hook a previously loaded DEFINE_DPM_OUTPUT UDF for file format specification for sampling of trajectories and VOF-to-DPM lump conversion transcripts.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/dpm_sample_output_udf").execute(*args, **kwargs)
        def volume_integrals(self, *args, **kwargs):
            """
            Enters the volume integral menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/report/volume_integrals").execute(*args, **kwargs)

        class heat_exchanger(TUIMenu):
            """
            Enters the heat exchanger menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def mass_flow_rate(self, *args, **kwargs):
                """
                Prints mass flow rate.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/heat_exchanger/mass_flow_rate").execute(*args, **kwargs)
            def specific_heat(self, *args, **kwargs):
                """
                Prints fluids specific heat.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/heat_exchanger/specific_heat").execute(*args, **kwargs)
            def outlet_temperature(self, *args, **kwargs):
                """
                Prints outlet temperature.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/heat_exchanger/outlet_temperature").execute(*args, **kwargs)
            def inlet_temperature(self, *args, **kwargs):
                """
                Prints inlet temperature.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/heat_exchanger/inlet_temperature").execute(*args, **kwargs)
            def computed_heat_rejection(self, *args, **kwargs):
                """
                Prints total heat rejection.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/heat_exchanger/computed_heat_rejection").execute(*args, **kwargs)

        class simulation_reports(TUIMenu):
            """
            Enter the simulation reports menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.parametric_study = self.__class__.parametric_study(service, version, mode, path + ["parametric_study"])
                super().__init__(service, version, mode, path)
            def list_simulation_reports(self, *args, **kwargs):
                """
                List all report names.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/simulation_reports/list_simulation_reports").execute(*args, **kwargs)
            def generate_simulation_report(self, *args, **kwargs):
                """
                Generate a new simulation report or regenerate an existing simulation report with the provided name.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/simulation_reports/generate_simulation_report").execute(*args, **kwargs)
            def read_simulation_report_template_file(self, *args, **kwargs):
                """
                Read a JSON template file with existing Simulation Report settings.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/simulation_reports/read_simulation_report_template_file").execute(*args, **kwargs)
            def write_simulation_report_template_file(self, *args, **kwargs):
                """
                Write a JSON template file with this case's Simulation Report settings.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/simulation_reports/write_simulation_report_template_file").execute(*args, **kwargs)
            def export_simulation_report_as_html(self, *args, **kwargs):
                """
                Export the provided simulation report as HTML.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/simulation_reports/export_simulation_report_as_html").execute(*args, **kwargs)
            def export_simulation_report_as_pptx(self, *args, **kwargs):
                """
                Export the provided simulation report as a PPT file.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/simulation_reports/export_simulation_report_as_pptx").execute(*args, **kwargs)
            def delete_simulation_report(self, *args, **kwargs):
                """
                Delete the provided simulation report.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/simulation_reports/delete_simulation_report").execute(*args, **kwargs)
            def view_simulation_report(self, *args, **kwargs):
                """
                View a simulation report that has already been generated. In batch mode this will print the report's URL.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/simulation_reports/view_simulation_report").execute(*args, **kwargs)
            def write_report_names_to_file(self, *args, **kwargs):
                """
                Write the list of currently generated report names to a txt file.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/simulation_reports/write_report_names_to_file").execute(*args, **kwargs)
            def export_simulation_report_as_pdf(self, *args, **kwargs):
                """
                Export the provided simulation report as a PDF file.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/simulation_reports/export_simulation_report_as_pdf").execute(*args, **kwargs)
            def rename_simulation_report(self, *args, **kwargs):
                """
                Rename a report which has already been generated.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/simulation_reports/rename_simulation_report").execute(*args, **kwargs)
            def duplicate_simulation_report(self, *args, **kwargs):
                """
                Duplicate a report and all of its settings to a new report.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/simulation_reports/duplicate_simulation_report").execute(*args, **kwargs)
            def reset_report_to_defaults(self, *args, **kwargs):
                """
                Reset all report settings to default for the provided simulation report.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/simulation_reports/reset_report_to_defaults").execute(*args, **kwargs)

            class parametric_study(TUIMenu):
                """
                Enter the parametric study menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def generate_parametric_report(self, *args, **kwargs):
                    """
                    Generate a parametric report for your study.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/simulation_reports/parametric_study/generate_parametric_report").execute(*args, **kwargs)
                def generate_design_point_report(self, *args, **kwargs):
                    """
                    Generate a simulation report for an updated design point.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/simulation_reports/parametric_study/generate_design_point_report").execute(*args, **kwargs)

        class forces(TUIMenu):
            """
            Enters the forces menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def pressure_center(self, *args, **kwargs):
                """
                Prints the center of pressure on wall zones.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/forces/pressure_center").execute(*args, **kwargs)
            def wall_moments(self, *args, **kwargs):
                """
                Computes the moments about the specified moment center for all wall zones.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/forces/wall_moments").execute(*args, **kwargs)
            def wall_forces(self, *args, **kwargs):
                """
                Computes the forces along the specified force vector for all wall zones.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/forces/wall_forces").execute(*args, **kwargs)

        class efficiency(TUIMenu):
            """
            Enter the menu for efficiency computations.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def polytropic(self, *args, **kwargs):
                """
                Calculate polytropic efficiency.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/efficiency/polytropic").execute(*args, **kwargs)
            def isentropic(self, *args, **kwargs):
                """
                Calculate isentropic efficiency.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/efficiency/isentropic").execute(*args, **kwargs)
            def use_in_turbo_report(self, *args, **kwargs):
                """
                Use this general method instead of constant Cp-based to compute efficiency with Turbo Report tool.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/efficiency/use_in_turbo_report").execute(*args, **kwargs)

        class modified_setting(TUIMenu):
            """
            Enter the modified settings menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def write_user_setting(self, *args, **kwargs):
                """
                Write the contents of the Modified Settings Summary table to a file.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/modified_setting/write_user_setting").execute(*args, **kwargs)
            def modified_setting(self, *args, **kwargs):
                """
                Specify which areas of setup will be checked for non-default settings for generating the Modified Settings Summary table. The table is displayed tabbed with the graphics window.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/modified_setting/modified_setting").execute(*args, **kwargs)

        class system(TUIMenu):
            """
            Enters the system menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def proc_stats(self, *args, **kwargs):
                """
                Prints ANSYS Fluent process information. This is used to report the memory usage of each of the ANSYS Fluent processes.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/system/proc_stats").execute(*args, **kwargs)
            def sys_stats(self, *args, **kwargs):
                """
                System information. This is used to report the CPU configuration of the machines where ANSYS Fluent processes have been spawned.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/system/sys_stats").execute(*args, **kwargs)
            def gpgpu_stats(self, *args, **kwargs):
                """
                Prints information about installed general purpose graphical processing units.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/system/gpgpu_stats").execute(*args, **kwargs)
            def time_stats(self, *args, **kwargs):
                """
                Timer information. This is used to report CPU timings for user and kernel processes and detailed solver timings.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/system/time_stats").execute(*args, **kwargs)

        class virtual_blade_model(TUIMenu):
            """
            VBM reports menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def rotor_roll_moment(self, *args, **kwargs):
                """
                Print Rotor Roll-Moment.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/virtual_blade_model/rotor_roll_moment").execute(*args, **kwargs)
            def rotor_torque(self, *args, **kwargs):
                """
                Print Rotor Torque.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/virtual_blade_model/rotor_torque").execute(*args, **kwargs)
            def rotor_thrust(self, *args, **kwargs):
                """
                Print Rotor Thrust.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/virtual_blade_model/rotor_thrust").execute(*args, **kwargs)
            def rotor_power(self, *args, **kwargs):
                """
                Print Rotor Power.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/virtual_blade_model/rotor_power").execute(*args, **kwargs)
            def rotor_pitch_moment(self, *args, **kwargs):
                """
                Print Rotor Pitch-Moment.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/virtual_blade_model/rotor_pitch_moment").execute(*args, **kwargs)

        class reference_values(TUIMenu):
            """
            Enters the reference value menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.compute = self.__class__.compute(service, version, mode, path + ["compute"])
                super().__init__(service, version, mode, path)
            def temperature(self, *args, **kwargs):
                """
                Sets reference temperature for normalization.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/reference_values/temperature").execute(*args, **kwargs)
            def pressure(self, *args, **kwargs):
                """
                Sets reference pressure for normalization.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/reference_values/pressure").execute(*args, **kwargs)
            def density(self, *args, **kwargs):
                """
                Sets reference density for normalization.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/reference_values/density").execute(*args, **kwargs)
            def velocity(self, *args, **kwargs):
                """
                Sets reference velocity for normalization.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/reference_values/velocity").execute(*args, **kwargs)
            def enthalpy(self, *args, **kwargs):
                """
                Sets reference enthalpy for enthalpy damping and normalization.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/reference_values/enthalpy").execute(*args, **kwargs)
            def depth(self, *args, **kwargs):
                """
                Sets reference depth for volume calculation.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/reference_values/depth").execute(*args, **kwargs)
            def area(self, *args, **kwargs):
                """
                Sets reference area for normalization.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/reference_values/area").execute(*args, **kwargs)
            def zone(self, *args, **kwargs):
                """
                Sets reference zone.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/reference_values/zone").execute(*args, **kwargs)
            def viscosity(self, *args, **kwargs):
                """
                Sets reference viscosity for normalization.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/reference_values/viscosity").execute(*args, **kwargs)
            def yplus(self, *args, **kwargs):
                """
                Sets reference yplus for calculation of Yplus Based Heat Transfer Coefficient.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/reference_values/yplus").execute(*args, **kwargs)
            def length(self, *args, **kwargs):
                """
                Sets reference length for normalization.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/reference_values/length").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                Lists current reference values.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/reference_values/list").execute(*args, **kwargs)

            class compute(TUIMenu):
                """
                Computes reference values from zone boundary conditions.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def velocity_inlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/velocity_inlet").execute(*args, **kwargs)
                def outlet_vent(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/outlet_vent").execute(*args, **kwargs)
                def wall(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/wall").execute(*args, **kwargs)
                def network_end(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/network_end").execute(*args, **kwargs)
                def porous_jump(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/porous_jump").execute(*args, **kwargs)
                def mass_flow_outlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/mass_flow_outlet").execute(*args, **kwargs)
                def symmetry(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/symmetry").execute(*args, **kwargs)
                def exhaust_fan(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/exhaust_fan").execute(*args, **kwargs)
                def pressure_outlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/pressure_outlet").execute(*args, **kwargs)
                def overset(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/overset").execute(*args, **kwargs)
                def axis(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/axis").execute(*args, **kwargs)
                def interior(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/interior").execute(*args, **kwargs)
                def fluid(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/fluid").execute(*args, **kwargs)
                def solid(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/solid").execute(*args, **kwargs)
                def outflow(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/outflow").execute(*args, **kwargs)
                def rans_les_interface(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/rans_les_interface").execute(*args, **kwargs)
                def inlet_vent(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/inlet_vent").execute(*args, **kwargs)
                def recirculation_inlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/recirculation_inlet").execute(*args, **kwargs)
                def recirculation_outlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/recirculation_outlet").execute(*args, **kwargs)
                def fan(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/fan").execute(*args, **kwargs)
                def radiator(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/radiator").execute(*args, **kwargs)
                def intake_fan(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/intake_fan").execute(*args, **kwargs)
                def pressure_far_field(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/pressure_far_field").execute(*args, **kwargs)
                def network(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/network").execute(*args, **kwargs)
                def periodic(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/periodic").execute(*args, **kwargs)
                def shadow(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/shadow").execute(*args, **kwargs)
                def geometry(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/geometry").execute(*args, **kwargs)
                def dummy_entry(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/dummy_entry").execute(*args, **kwargs)
                def interface(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/interface").execute(*args, **kwargs)
                def mass_flow_inlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/mass_flow_inlet").execute(*args, **kwargs)
                def pressure_inlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/pressure_inlet").execute(*args, **kwargs)
                def degassing(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/reference_values/compute/degassing").execute(*args, **kwargs)

        class icing(TUIMenu):
            """
            Icing reports menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def mass_of_ice(self, *args, **kwargs):
                """
                Print Mass of Ice Accretion.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/icing/mass_of_ice").execute(*args, **kwargs)
            def particles_droplets_collection_eff(self, *args, **kwargs):
                """
                Print Droplets Collection Efficiency.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/icing/particles_droplets_collection_eff").execute(*args, **kwargs)
            def mass_of_water_impinged(self, *args, **kwargs):
                """
                Print Mass of Water Impingement.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/icing/mass_of_water_impinged").execute(*args, **kwargs)
            def icing_energy_of_conduction(self, *args, **kwargs):
                """
                Print Energy of Conduction.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/icing/icing_energy_of_conduction").execute(*args, **kwargs)
            def particles_crystals_collection_eff(self, *args, **kwargs):
                """
                Print Crystals Collection Efficiency.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/icing/particles_crystals_collection_eff").execute(*args, **kwargs)
            def energy_of_ice_formation(self, *args, **kwargs):
                """
                Print Energy of Ice Formation.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/icing/energy_of_ice_formation").execute(*args, **kwargs)
            def energy_of_water_impinged(self, *args, **kwargs):
                """
                Print Energy of Water Impingement.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/icing/energy_of_water_impinged").execute(*args, **kwargs)

        class population_balance(TUIMenu):
            """
            Population Balance menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def number_density(self, *args, **kwargs):
                """
                Set number density functions.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/population_balance/number_density").execute(*args, **kwargs)
            def moments(self, *args, **kwargs):
                """
                Set moments for population balance.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/population_balance/moments").execute(*args, **kwargs)

        class fluxes(TUIMenu):
            """
            Enters the fluxes menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def rad_heat_trans(self, *args, **kwargs):
                """
                Prints radiation heat transfer rate at boundaries.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/fluxes/rad_heat_trans").execute(*args, **kwargs)
            def heat_transfer_sensible(self, *args, **kwargs):
                """
                Prints the sensible heat transfer rate at the boundaries.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/fluxes/heat_transfer_sensible").execute(*args, **kwargs)
            def film_mass_flow(self, *args, **kwargs):
                """
                Prints wall film mass flow rate at boundaries. This text command is only available when you enable the Eulerian wall film model.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/fluxes/film_mass_flow").execute(*args, **kwargs)
            def mass_flow(self, *args, **kwargs):
                """
                Prints mass flow rate at inlets and outlets.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/fluxes/mass_flow").execute(*args, **kwargs)
            def film_heat_transfer(self, *args, **kwargs):
                """
                Prints wall film heat transfer rate at boundaries. This text command is only available when you enable the Eulerian wall film model.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/fluxes/film_heat_transfer").execute(*args, **kwargs)
            def pressure_work(self, *args, **kwargs):
                """
                Prints the pressure work rate at the boundaries. This text command is only available when the energy equation is enabled, the absolute velocity formulation is selected, and zone motion is enabled for a fluid cell zone.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/fluxes/pressure_work").execute(*args, **kwargs)
            def viscous_work(self, *args, **kwargs):
                """
                Prints the viscous work rate at the boundaries. This text command is only available when the energy equation is enabled and the pressure-based solver is selected.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/fluxes/viscous_work").execute(*args, **kwargs)
            def heat_transfer(self, *args, **kwargs):
                """
                Prints heat transfer rate at boundaries.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/fluxes/heat_transfer").execute(*args, **kwargs)
            def electric_current(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/report/fluxes/electric_current").execute(*args, **kwargs)

        class dpm_histogram(TUIMenu):
            """
            Enters the DPM histogram menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.setup_reduction = self.__class__.setup_reduction(service, version, mode, path + ["setup_reduction"])
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                super().__init__(service, version, mode, path)
            def reduce_picked_sample(self, *args, **kwargs):
                """
                Reduce a sample as specified by the data reduction parameters. This command is available only after you selected the sample using the pick-sample-to-reduce text command.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/reduce_picked_sample").execute(*args, **kwargs)
            def list_samples(self, *args, **kwargs):
                """
                Shows all samples in a loaded sample list.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/list_samples").execute(*args, **kwargs)
            def prep_dpm_sample_cont_plot_exprs(self, *args, **kwargs):
                """
                Prepare named expressions from data in a DPM sample file (collected at a cut plane surface) for contour plotting.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/prep_dpm_sample_cont_plot_exprs").execute(*args, **kwargs)
            def read_sample(self, *args, **kwargs):
                """
                Reads a sample file and adds it to the sample list.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/read_sample").execute(*args, **kwargs)
            def write_sample(self, *args, **kwargs):
                """
                Write a histogram of a loaded sample into a file.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/write_sample").execute(*args, **kwargs)
            def delete_sample(self, *args, **kwargs):
                """
                Deletes a sample from the loaded sample list.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/delete_sample").execute(*args, **kwargs)
            def plot_sample(self, *args, **kwargs):
                """
                Plots a histogram of a loaded sample.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/plot_sample").execute(*args, **kwargs)
            def pick_sample_to_reduce(self, *args, **kwargs):
                """
                Select a sample to be reduced.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/pick_sample_to_reduce").execute(*args, **kwargs)
            def compute_sample(self, *args, **kwargs):
                """
                Computes the minimum/maximum of a sample variable.
                """
                return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/compute_sample").execute(*args, **kwargs)

            class setup_reduction(TUIMenu):
                """
                Set up the sample data reduction by specifying all relevant options and setting parameters as desired.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def make_steady_from_unsteady_file(self, *args, **kwargs):
                    """
                    Specify whether the unsteady sample is to be reduced into a steady-state injection file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/setup_reduction/make_steady_from_unsteady_file").execute(*args, **kwargs)
                def use_weighting(self, *args, **kwargs):
                    """
                    Specify whether to use any weighting in the averaging that is done in each bin in the data reduction.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/setup_reduction/use_weighting").execute(*args, **kwargs)
                def maximum(self, *args, **kwargs):
                    """
                    Set the maximum value of the range to be considered for a specific variable in the data reduction.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/setup_reduction/maximum").execute(*args, **kwargs)
                def list_settings(self, *args, **kwargs):
                    """
                    List all user inputs for the sample picked for data reduction.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/setup_reduction/list_settings").execute(*args, **kwargs)
                def all_variables_number_of_bins(self, *args, **kwargs):
                    """
                    Set the number of bins to be used for ALL variables in the data reduction.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/setup_reduction/all_variables_number_of_bins").execute(*args, **kwargs)
                def minimum(self, *args, **kwargs):
                    """
                    Set the minimum value of the range to be considered for a specific variable in the data reduction.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/setup_reduction/minimum").execute(*args, **kwargs)
                def weighting_variable(self, *args, **kwargs):
                    """
                    Choose the weighting variable for the averaging in each bin in the data reduction.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/setup_reduction/weighting_variable").execute(*args, **kwargs)
                def number_of_bins(self, *args, **kwargs):
                    """
                    Set the number of bins to be used for a specific variable in the data reduction.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/setup_reduction/number_of_bins").execute(*args, **kwargs)
                def logarithmic(self, *args, **kwargs):
                    """
                    Switch on or off logarithmic scaling to be used for a specific variable in the data reduction.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/setup_reduction/logarithmic").execute(*args, **kwargs)
                def reset_min_and_max(self, *args, **kwargs):
                    """
                    Reset the min and max values of the range to be considered for a specific variable in the data reduction.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/setup_reduction/reset_min_and_max").execute(*args, **kwargs)

            class set(TUIMenu):
                """
                Enters the settings menu for the histogram.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def weighting(self, *args, **kwargs):
                    """
                    Uses weighting with additional variables when sorting data into samples.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/set/weighting").execute(*args, **kwargs)
                def minimum(self, *args, **kwargs):
                    """
                    Specifies the minimum value of the x-axis variable for histogram plots.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/set/minimum").execute(*args, **kwargs)
                def histogram_mode(self, *args, **kwargs):
                    """
                    Uses bars for the histogram plot or xy-style.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/set/histogram_mode").execute(*args, **kwargs)
                def percentage(self, *args, **kwargs):
                    """
                    Uses percentages of bins to be computed.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/set/percentage").execute(*args, **kwargs)
                def variable_power_3(self, *args, **kwargs):
                    """
                    Use the cubic of the cumulation variable during computation of the cumulative curve.
                    When the particle mass was not sampled, the diameter can be used instead.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/set/variable_power_3").execute(*args, **kwargs)
                def number_of_bins(self, *args, **kwargs):
                    """
                    Specifies the number of bins.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/set/number_of_bins").execute(*args, **kwargs)
                def maximum(self, *args, **kwargs):
                    """
                    Specifies the maximum value of the x-axis variable for histogram plots.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/set/maximum").execute(*args, **kwargs)
                def cumulation_curve(self, *args, **kwargs):
                    """
                    Computes a cumulative curve for the sampling variable or correlation variable when correlation? is specified.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/set/cumulation_curve").execute(*args, **kwargs)
                def auto_range(self, *args, **kwargs):
                    """
                    Automatically computes the range of the sampling variable for histogram plots.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/set/auto_range").execute(*args, **kwargs)
                def correlation(self, *args, **kwargs):
                    """
                    Computes the correlation of the sampling variable with another variable.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/set/correlation").execute(*args, **kwargs)
                def logarithmic(self, *args, **kwargs):
                    """
                    Enables/disables the use of logarithmic scaling on the abscissa of the histogram.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/set/logarithmic").execute(*args, **kwargs)
                def diameter_statistics(self, *args, **kwargs):
                    """
                    Computes the Rosin Rammler parameters, Sauter, and other mean diameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/report/dpm_histogram/set/diameter_statistics").execute(*args, **kwargs)

    class parallel(TUIMenu):
        """
        Enter the parallel processing menu.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            self.network = self.__class__.network(service, version, mode, path + ["network"])
            self.partition = self.__class__.partition(service, version, mode, path + ["partition"])
            self.load_balance = self.__class__.load_balance(service, version, mode, path + ["load_balance"])
            self.timer = self.__class__.timer(service, version, mode, path + ["timer"])
            self.multidomain = self.__class__.multidomain(service, version, mode, path + ["multidomain"])
            self.set = self.__class__.set(service, version, mode, path + ["set"])
            self.gpgpu = self.__class__.gpgpu(service, version, mode, path + ["gpgpu"])
            super().__init__(service, version, mode, path)
        def bandwidth(self, *args, **kwargs):
            """
            Shows network bandwidth.
            """
            return PyMenu(self._service, self._version, self._mode, "/parallel/bandwidth").execute(*args, **kwargs)
        def check_verbosity(self, *args, **kwargs):
            """
            Sets verbosity output of the parallel check. Higher verbosity corresponds to more detailed information.
            """
            return PyMenu(self._service, self._version, self._mode, "/parallel/check_verbosity").execute(*args, **kwargs)
        def latency(self, *args, **kwargs):
            """
            Shows network latency.
            """
            return PyMenu(self._service, self._version, self._mode, "/parallel/latency").execute(*args, **kwargs)
        def check(self, *args, **kwargs):
            """
            Performs checks of various factors that affect parallel performance.
            """
            return PyMenu(self._service, self._version, self._mode, "/parallel/check").execute(*args, **kwargs)
        def thread_number_control(self, *args, **kwargs):
            """
            .
            """
            return PyMenu(self._service, self._version, self._mode, "/parallel/thread_number_control").execute(*args, **kwargs)
        def show_connectivity(self, *args, **kwargs):
            """
            Prints the network connectivity for the selected compute node.
            """
            return PyMenu(self._service, self._version, self._mode, "/parallel/show_connectivity").execute(*args, **kwargs)

        class network(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def kill_node(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/network/kill_node").execute(*args, **kwargs)
            def save_hosts(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/network/save_hosts").execute(*args, **kwargs)
            def load_hosts(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/network/load_hosts").execute(*args, **kwargs)
            def kill_all_nodes(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/network/kill_all_nodes").execute(*args, **kwargs)
            def spawn_node(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/network/spawn_node").execute(*args, **kwargs)
            def shell_script_path(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/network/shell_script_path").execute(*args, **kwargs)

        class partition(TUIMenu):
            """
            Enters the partition domain menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.automatic = self.__class__.automatic(service, version, mode, path + ["automatic"])
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                super().__init__(service, version, mode, path)
            def print_active_partitions(self, *args, **kwargs):
                """
                Prints active partition information (parallel solver).
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/partition/print_active_partitions").execute(*args, **kwargs)
            def print_partitions(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/partition/print_partitions").execute(*args, **kwargs)
            def combine_partition(self, *args, **kwargs):
                """
                Merges every N partitions.
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/partition/combine_partition").execute(*args, **kwargs)
            def use_stored_partitions(self, *args, **kwargs):
                """
                Uses this partitioning.
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/partition/use_stored_partitions").execute(*args, **kwargs)
            def reorder_partitions(self, *args, **kwargs):
                """
                Reorders partitions.
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/partition/reorder_partitions").execute(*args, **kwargs)
            def print_stored_partitions(self, *args, **kwargs):
                """
                Prints stored partition information (parallel solver).
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/partition/print_stored_partitions").execute(*args, **kwargs)
            def merge_clusters(self, *args, **kwargs):
                """
                Calls the optimizer that attempts to decrease the number of interfaces by eliminating orphan cell clusters. (An orphan cluster is a group of connected cells such that each member has at least one face that is part of an interface boundary.).
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/partition/merge_clusters").execute(*args, **kwargs)
            def reorder_partitions_to_architecture(self, *args, **kwargs):
                """
                Reorders partitions to architecture.
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/partition/reorder_partitions_to_architecture").execute(*args, **kwargs)
            def method(self, *args, **kwargs):
                """
                Sets the partition method.
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/partition/method").execute(*args, **kwargs)
            def smooth_partition(self, *args, **kwargs):
                """
                Calls the optimizer that attempts to minimize the number of interfaces by modifying the partition boundaries to reduce surface area.
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/partition/smooth_partition").execute(*args, **kwargs)

            class automatic(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def use_case_file_method(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/automatic/use_case_file_method").execute(*args, **kwargs)
                def across_zones(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/automatic/across_zones").execute(*args, **kwargs)
                def load_vector(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/automatic/load_vector").execute(*args, **kwargs)
                def pre_test(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/automatic/pre_test").execute(*args, **kwargs)
                def method(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/automatic/method").execute(*args, **kwargs)

            class set(TUIMenu):
                """
                Enters the set partition parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.partition_origin_vector = self.__class__.partition_origin_vector(service, version, mode, path + ["partition_origin_vector"])
                    super().__init__(service, version, mode, path)
                def stretched_mesh_enhancement(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/stretched_mesh_enhancement").execute(*args, **kwargs)
                def isat_weight(self, *args, **kwargs):
                    """
                    Sets ISAT weight.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/isat_weight").execute(*args, **kwargs)
                def fluid_solid_rebalance_after_read_case(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/fluid_solid_rebalance_after_read_case").execute(*args, **kwargs)
                def solid_thread_weight(self, *args, **kwargs):
                    """
                    Uses solid thread weights.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/solid_thread_weight").execute(*args, **kwargs)
                def merge(self, *args, **kwargs):
                    """
                    Toggles the optimizer that attempts to decrease the number of interfaces by eliminating orphan cell clusters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/merge").execute(*args, **kwargs)
                def layering(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/layering").execute(*args, **kwargs)
                def nfaces_as_weights(self, *args, **kwargs):
                    """
                    Uses number of faces as weights.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/nfaces_as_weights").execute(*args, **kwargs)
                def print_verbosity(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/print_verbosity").execute(*args, **kwargs)
                def face_area_as_weights(self, *args, **kwargs):
                    """
                    Uses face area as connection weights.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/face_area_as_weights").execute(*args, **kwargs)
                def model_weighted_partition(self, *args, **kwargs):
                    """
                    Enables / disables model-weighted partitioning. This option works with the METIS partitioning method, and specifies that Fluent automatically calculates the weighting based on the cell count and the models and attributes specified as weights (using the parallel/partition/set/isat-weight text command, for example).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/model_weighted_partition").execute(*args, **kwargs)
                def laplace_smoothing(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/laplace_smoothing").execute(*args, **kwargs)
                def vof_free_surface_weight(self, *args, **kwargs):
                    """
                    Sets VOF free surface weight.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/vof_free_surface_weight").execute(*args, **kwargs)
                def pre_test(self, *args, **kwargs):
                    """
                    Enables the operation that determines the best coordinate-splitting direction.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/pre_test").execute(*args, **kwargs)
                def load_distribution(self, *args, **kwargs):
                    """
                    Sets the number of cells desired for each partition. This is useful, for example, when computing on multiple machines with significantly different performance characteristics. If left unset, each partition will contain an approximately equal number of cells. Normalized relative values may be used for the entries.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/load_distribution").execute(*args, **kwargs)
                def across_zones(self, *args, **kwargs):
                    """
                    Allows partitions to cross zone boundaries (the default). If turned off, it will restrict partitioning to within each cell zone. This is recommended only when cells in different zones require significantly different amounts of computation during the solution phase; for example, if the domain contains both solid and fluid zones.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/across_zones").execute(*args, **kwargs)
                def smooth(self, *args, **kwargs):
                    """
                    Toggles the optimizer that attempts to minimize the number of interfaces by modifying the partition boundaries to reduce surface area.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/smooth").execute(*args, **kwargs)
                def origin(self, *args, **kwargs):
                    """
                    Sets the , , and  coordinate of the origin used by those partitioning functions that require a radial distance. By default, the origin is set to (0, 0, 0).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/origin").execute(*args, **kwargs)
                def cell_function(self, *args, **kwargs):
                    """
                    Sets cell function.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/cell_function").execute(*args, **kwargs)
                def all_off(self, *args, **kwargs):
                    """
                    Disables all optimizations.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/all_off").execute(*args, **kwargs)
                def all_on(self, *args, **kwargs):
                    """
                    Enables all optimizations.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/all_on").execute(*args, **kwargs)
                def dpm_load_balancing(self, *args, **kwargs):
                    """
                    Enables / disables dynamic load balancing for discrete phase model cases that use a second domain for DPM particle tracking (that is, cases for which you have enabled the define/models/dpm/parallel/hybrid-2domain? text command).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/dpm_load_balancing").execute(*args, **kwargs)
                def particle_weight(self, *args, **kwargs):
                    """
                    Sets DPM particle weight.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/particle_weight").execute(*args, **kwargs)

                class partition_origin_vector(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def list_properties(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/partition_origin_vector/list_properties").execute(*args, **kwargs)
                    def edit(self, *args, **kwargs):
                        """
                        Edit partition-origin-vector object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/partition_origin_vector/edit").execute(*args, **kwargs)
                    def number_of_objects(self, *args, **kwargs):
                        """
                        Set number of objects for partition-origin-vector.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/parallel/partition/set/partition_origin_vector/number_of_objects").execute(*args, **kwargs)

        class load_balance(TUIMenu):
            """
            Enters the load balancing parameters menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def dynamic_mesh(self, *args, **kwargs):
                """
                Uses load balancing for dynamic mesh?.
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/load_balance/dynamic_mesh").execute(*args, **kwargs)
            def physical_models(self, *args, **kwargs):
                """
                Uses physical-models load balancing?.
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/load_balance/physical_models").execute(*args, **kwargs)
            def mesh_adaption(self, *args, **kwargs):
                """
                Uses load balancing for mesh adaption?.
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/load_balance/mesh_adaption").execute(*args, **kwargs)

        class timer(TUIMenu):
            """
            Enters the timer menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def usage(self, *args, **kwargs):
                """
                Prints performance statistics in the console window.
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/timer/usage").execute(*args, **kwargs)
            def reset(self, *args, **kwargs):
                """
                Adjusts domain timers.
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/timer/reset").execute(*args, **kwargs)

        class multidomain(TUIMenu):
            """
            Enters the multidomain architecture menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.solve = self.__class__.solve(service, version, mode, path + ["solve"])
                self.conjugate_heat_transfer = self.__class__.conjugate_heat_transfer(service, version, mode, path + ["conjugate_heat_transfer"])
                super().__init__(service, version, mode, path)

            class solve(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def iterate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/multidomain/solve/iterate").execute(*args, **kwargs)
                def dual_time_iterate(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/multidomain/solve/dual_time_iterate").execute(*args, **kwargs)

            class conjugate_heat_transfer(TUIMenu):
                """
                Enters the conjugate heat transfer menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.set = self.__class__.set(service, version, mode, path + ["set"])
                    super().__init__(service, version, mode, path)
                def enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/parallel/multidomain/conjugate_heat_transfer/enabled").execute(*args, **kwargs)

                class set(TUIMenu):
                    """
                    Enters the set menu for loosely coupled conjugate heat transfer.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.helper_session_setup = self.__class__.helper_session_setup(service, version, mode, path + ["helper_session_setup"])
                        super().__init__(service, version, mode, path)
                    def coupling(self, *args, **kwargs):
                        """
                        Specifies when the fluid and solid zone calculations are coupled,  either at a defined time period or number of fluid time steps.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/parallel/multidomain/conjugate_heat_transfer/set/coupling").execute(*args, **kwargs)
                    def helper_session(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/parallel/multidomain/conjugate_heat_transfer/set/helper_session").execute(*args, **kwargs)

                    class helper_session_setup(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def process_count(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/parallel/multidomain/conjugate_heat_transfer/set/helper_session_setup/process_count").execute(*args, **kwargs)
                        def host_name(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/parallel/multidomain/conjugate_heat_transfer/set/helper_session_setup/host_name").execute(*args, **kwargs)

        class set(TUIMenu):
            """
            Enters the set parallel parameters menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def verbosity(self, *args, **kwargs):
                """
                Sets the parallel verbosity.
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/set/verbosity").execute(*args, **kwargs)
            def time_out(self, *args, **kwargs):
                """
                Sets spawn time-out in seconds.
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/set/time_out").execute(*args, **kwargs)
            def fast_io(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/set/fast_io").execute(*args, **kwargs)
            def partition_mask(self, *args, **kwargs):
                """
                Sets partition mask.
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/set/partition_mask").execute(*args, **kwargs)

        class gpgpu(TUIMenu):
            """
            Enters the GPGPU menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def show(self, *args, **kwargs):
                """
                Lists the available GPGPUs. GPGPUs selected for use are indicated by the presence of an asterisk (\\*).
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/gpgpu/show").execute(*args, **kwargs)
            def select(self, *args, **kwargs):
                """
                Selects which GPGPUs to use for AMG acceleration.
                """
                return PyMenu(self._service, self._version, self._mode, "/parallel/gpgpu/select").execute(*args, **kwargs)

    class solve(TUIMenu):
        """
        Enter the solve menu.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            self.cell_register_operations = self.__class__.cell_register_operations(service, version, mode, path + ["cell_register_operations"])
            self.report_plots = self.__class__.report_plots(service, version, mode, path + ["report_plots"])
            self.report_files = self.__class__.report_files(service, version, mode, path + ["report_files"])
            self.cell_registers = self.__class__.cell_registers(service, version, mode, path + ["cell_registers"])
            self.execute_commands = self.__class__.execute_commands(service, version, mode, path + ["execute_commands"])
            self.set = self.__class__.set(service, version, mode, path + ["set"])
            self.animate = self.__class__.animate(service, version, mode, path + ["animate"])
            self.initialize = self.__class__.initialize(service, version, mode, path + ["initialize"])
            self.report_definitions = self.__class__.report_definitions(service, version, mode, path + ["report_definitions"])
            self.monitors = self.__class__.monitors(service, version, mode, path + ["monitors"])
            super().__init__(service, version, mode, path)
        def convergence_conditions(self, *args, **kwargs):
            """
            Enters the convergence conditions menu.
            """
            return PyMenu(self._service, self._version, self._mode, "/solve/convergence_conditions").execute(*args, **kwargs)
        def dpm_update(self, *args, **kwargs):
            """
            Updates discrete phase source terms.
            """
            return PyMenu(self._service, self._version, self._mode, "/solve/dpm_update").execute(*args, **kwargs)
        def mesh_motion(self, *args, **kwargs):
            """
            Performs mesh motion.
            """
            return PyMenu(self._service, self._version, self._mode, "/solve/mesh_motion").execute(*args, **kwargs)
        def max_iterations_per_time_step(self, *args, **kwargs):
            """
            Set maximum iterations per time step for transient case.
            """
            return PyMenu(self._service, self._version, self._mode, "/solve/max_iterations_per_time_step").execute(*args, **kwargs)
        def multistage_time_iterate(self, *args, **kwargs):
            """
            Perform unsteady iterations.
            """
            return PyMenu(self._service, self._version, self._mode, "/solve/multistage_time_iterate").execute(*args, **kwargs)
        def update_physical_time(self, *args, **kwargs):
            """
            Advances the unsteady solution to the next physical time level. Using this command in conjunction with theiterate command allows you to manually advance the solution in time (rather than doing it automatically with the dual-time-iterate command).
            """
            return PyMenu(self._service, self._version, self._mode, "/solve/update_physical_time").execute(*args, **kwargs)
        def dual_time_iterate(self, *args, **kwargs):
            """
            Performs unsteady iterations for a specified number of time steps.
            """
            return PyMenu(self._service, self._version, self._mode, "/solve/dual_time_iterate").execute(*args, **kwargs)
        def patch(self, *args, **kwargs):
            """
            Patches a value for a flow variable in the domain. You can either provide a numerical value, which you can enter directly, or you can enter an expression, which must be entered within quotation marks.
            """
            return PyMenu(self._service, self._version, self._mode, "/solve/patch").execute(*args, **kwargs)
        def iterate_steady_2way_fsi(self, *args, **kwargs):
            """
            Perform a specified number of steps.
            """
            return PyMenu(self._service, self._version, self._mode, "/solve/iterate_steady_2way_fsi").execute(*args, **kwargs)
        def iterate(self, *args, **kwargs):
            """
            Performs a specified number of iterations.  This option is still available during transient simulations, since it can be used to add more iterations to the same time step after interrupting iterations within a time step.
            """
            return PyMenu(self._service, self._version, self._mode, "/solve/iterate").execute(*args, **kwargs)

        class cell_register_operations(TUIMenu):
            """
            Enters the cell register operations menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def edit(self, *args, **kwargs):
                """
                Edits an existing cell register operation.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/cell_register_operations/edit").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                Lists the currently defined cell register operations.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/cell_register_operations/list").execute(*args, **kwargs)
            def add(self, *args, **kwargs):
                """
                Creates a new cell register operation.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/cell_register_operations/add").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                Lists the properties of a report register operation.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/cell_register_operations/list_properties").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Deletes a cell register operation.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/cell_register_operations/delete").execute(*args, **kwargs)

        class report_plots(TUIMenu):
            """
            Enters the report plots menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def axes(self, *args, **kwargs):
                """
                Defines the axes for a report plot.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_plots/axes").execute(*args, **kwargs)
            def add(self, *args, **kwargs):
                """
                Creates a report plot.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_plots/add").execute(*args, **kwargs)
            def get_window_id(self, *args, **kwargs):
                """
                Get report-plot object window id.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_plots/get_window_id").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Deletes all of the report plot objects.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_plots/delete_all").execute(*args, **kwargs)
            def clear_data(self, *args, **kwargs):
                """
                Clears the data associated with a report plot.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_plots/clear_data").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                Lists all defined report plots.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_plots/list").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                Lists the properties of a report plot.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_plots/list_properties").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edits a report plot.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_plots/edit").execute(*args, **kwargs)
            def plot(self, *args, **kwargs):
                """
                Plots the specified report plot.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_plots/plot").execute(*args, **kwargs)
            def curves(self, *args, **kwargs):
                """
                Defines the curves for a report plot.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_plots/curves").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Deletes a report plot object.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_plots/delete").execute(*args, **kwargs)

        class report_files(TUIMenu):
            """
            Enters the report files menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def delete(self, *args, **kwargs):
                """
                Deletes a report file object.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_files/delete").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Deletes all of the report file objects.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_files/delete_all").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                Lists the properties of a report file.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_files/list_properties").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edits a report file.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_files/edit").execute(*args, **kwargs)
            def add(self, *args, **kwargs):
                """
                Creates a report file.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_files/add").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                Lists all defined report files.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_files/list").execute(*args, **kwargs)
            def clear_data(self, *args, **kwargs):
                """
                Clears the data associated with a report file.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_files/clear_data").execute(*args, **kwargs)

        class cell_registers(TUIMenu):
            """
            Enters the cell registers menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def list(self, *args, **kwargs):
                """
                Lists all of the currently defined cell registers.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/cell_registers/list").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Deletes a cell register.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/cell_registers/delete").execute(*args, **kwargs)
            def refine(self, *args, **kwargs):
                """
                Refine the mesh based on a cell register.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/cell_registers/refine").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                Lists the properties of a cell register.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/cell_registers/list_properties").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an object.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/cell_registers/edit").execute(*args, **kwargs)
            def apply_poor_mesh_numerics(self, *args, **kwargs):
                """
                Applies poor mesh numerics to the mesh of a cell register.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/cell_registers/apply_poor_mesh_numerics").execute(*args, **kwargs)
            def coarsen(self, *args, **kwargs):
                """
                Coarsen the mesh based on a cell register.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/cell_registers/coarsen").execute(*args, **kwargs)
            def add(self, *args, **kwargs):
                """
                Add a new object.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/cell_registers/add").execute(*args, **kwargs)
            def adapt(self, *args, **kwargs):
                """
                Adapt cell register objects.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/cell_registers/adapt").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Displays a cell register.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/cell_registers/display").execute(*args, **kwargs)

        class execute_commands(TUIMenu):
            """
            Enters the execute commands menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def enable(self, *args, **kwargs):
                """
                Enables an execute command.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/execute_commands/enable").execute(*args, **kwargs)
            def disable(self, *args, **kwargs):
                """
                Disables an execute command.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/execute_commands/disable").execute(*args, **kwargs)
            def export(self, *args, **kwargs):
                """
                Export execute-commands to a TSV file.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/execute_commands/export").execute(*args, **kwargs)
            def add_edit(self, *args, **kwargs):
                """
                Adds or edits execute commands.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/execute_commands/add_edit").execute(*args, **kwargs)
            def import_(self, *args, **kwargs):
                """
                Import execute-commands from a TSV file.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/execute_commands/import_").execute(*args, **kwargs)
            def copy(self, *args, **kwargs):
                """
                Copy an execute-command.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/execute_commands/copy").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an execute-command.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/execute_commands/delete").execute(*args, **kwargs)

        class set(TUIMenu):
            """
            Enters the set solution parameters menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.divergence_prevention = self.__class__.divergence_prevention(service, version, mode, path + ["divergence_prevention"])
                self.acoustics_wave_equation_controls = self.__class__.acoustics_wave_equation_controls(service, version, mode, path + ["acoustics_wave_equation_controls"])
                self.data_sampling_options = self.__class__.data_sampling_options(service, version, mode, path + ["data_sampling_options"])
                self.warped_face_gradient_correction = self.__class__.warped_face_gradient_correction(service, version, mode, path + ["warped_face_gradient_correction"])
                self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                self.transient_controls = self.__class__.transient_controls(service, version, mode, path + ["transient_controls"])
                self.fast_transient_settings = self.__class__.fast_transient_settings(service, version, mode, path + ["fast_transient_settings"])
                self.open_channel_wave_options = self.__class__.open_channel_wave_options(service, version, mode, path + ["open_channel_wave_options"])
                self.contact_solution_controls = self.__class__.contact_solution_controls(service, version, mode, path + ["contact_solution_controls"])
                self.amg_options = self.__class__.amg_options(service, version, mode, path + ["amg_options"])
                self.advanced = self.__class__.advanced(service, version, mode, path + ["advanced"])
                self.poor_mesh_numerics = self.__class__.poor_mesh_numerics(service, version, mode, path + ["poor_mesh_numerics"])
                self.pseudo_time_method = self.__class__.pseudo_time_method(service, version, mode, path + ["pseudo_time_method"])
                self.high_speed_numerics = self.__class__.high_speed_numerics(service, version, mode, path + ["high_speed_numerics"])
                self.enhanced_les_numerics = self.__class__.enhanced_les_numerics(service, version, mode, path + ["enhanced_les_numerics"])
                self.nita_expert_controls = self.__class__.nita_expert_controls(service, version, mode, path + ["nita_expert_controls"])
                self.previous_defaults = self.__class__.previous_defaults(service, version, mode, path + ["previous_defaults"])
                self.multiphase_numerics = self.__class__.multiphase_numerics(service, version, mode, path + ["multiphase_numerics"])
                self.slope_limiter_menu = self.__class__.slope_limiter_menu(service, version, mode, path + ["slope_limiter_menu"])
                self.high_order_term_relaxation = self.__class__.high_order_term_relaxation(service, version, mode, path + ["high_order_term_relaxation"])
                super().__init__(service, version, mode, path)
            def bc_pressure_extrapolations(self, *args, **kwargs):
                """
                Sets pressure extrapolations schemes on boundaries.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/bc_pressure_extrapolations").execute(*args, **kwargs)
            def reporting_interval(self, *args, **kwargs):
                """
                Sets the number of iterations for which convergence monitors are reported. The default is 1 (after every iteration).
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/reporting_interval").execute(*args, **kwargs)
            def max_corrections(self, *args, **kwargs):
                """
                Enters the max-corrections menu.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/max_corrections").execute(*args, **kwargs)
            def set_all_species_together(self, *args, **kwargs):
                """
                Sets all species discretizations and URFs together.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/set_all_species_together").execute(*args, **kwargs)
            def accelerated_non_iterative_time_marching(self, *args, **kwargs):
                """
                Enables a modified NITA scheme and other setting changes that can speed up the simulation. This option is only available with the Large Eddy Simulation (LES) turbulence model, and is intended for unreacting flow simulations that use a constant-density fluid.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/accelerated_non_iterative_time_marching").execute(*args, **kwargs)
            def pseudo_transient(self, *args, **kwargs):
                """
                For backward compatibility, pseudo transient (global time-step) formulation setup.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/pseudo_transient").execute(*args, **kwargs)
            def equations(self, *args, **kwargs):
                """
                Selects the equations to be solved.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/equations").execute(*args, **kwargs)
            def material_property_warnings(self, *args, **kwargs):
                """
                Control the display of material property warning diagnostics:
                0 - off (no messages)
                1 - messages per material
                2 - messages per material and per property.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/material_property_warnings").execute(*args, **kwargs)
            def numerical_beach_controls(self, *args, **kwargs):
                """
                Sets damping function in flow direction. This command appears only when the VOF model is enabled. Select the damping function to be used:
                Index
                Damping Function
                0
                Linear
                1
                Quadratic
                2
                Cubic
                3
                Cosine.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/numerical_beach_controls").execute(*args, **kwargs)
            def residual_tolerance(self, *args, **kwargs):
                """
                Enters the residual tolerance menu.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/residual_tolerance").execute(*args, **kwargs)
            def multi_grid_amg(self, *args, **kwargs):
                """
                Sets the parameters that govern the algebraic multigrid procedure.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/multi_grid_amg").execute(*args, **kwargs)
            def relaxation_method(self, *args, **kwargs):
                """
                Sets the solver relaxation method.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/relaxation_method").execute(*args, **kwargs)
            def set_solution_methods_to_default(self, *args, **kwargs):
                """
                Sets the solution methods to the default settings.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/set_solution_methods_to_default").execute(*args, **kwargs)
            def numerics(self, *args, **kwargs):
                """
                Sets numerics options.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/numerics").execute(*args, **kwargs)
            def expert(self, *args, **kwargs):
                """
                Sets expert options.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/expert").execute(*args, **kwargs)
            def under_relaxation(self, *args, **kwargs):
                """
                Enters the under-relaxation menu, which allows you to set the under-relaxation factor for each equation that is being solved in a segregated manner.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/under_relaxation").execute(*args, **kwargs)
            def multi_grid_controls(self, *args, **kwargs):
                """
                Sets multigrid parameters and termination criteria.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/multi_grid_controls").execute(*args, **kwargs)
            def disable_reconstruction(self, *args, **kwargs):
                """
                Completely disables reconstruction, resulting in totally first-order accuracy.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/disable_reconstruction").execute(*args, **kwargs)
            def limits(self, *args, **kwargs):
                """
                Sets solver limits for various solution variables, in order to improve the stability of the solution.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/limits").execute(*args, **kwargs)
            def pseudo_relaxation_factor(self, *args, **kwargs):
                """
                For backward compatibility, pseudo relaxation factor menu.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/pseudo_relaxation_factor").execute(*args, **kwargs)
            def equation_ordering(self, *args, **kwargs):
                """
                Sets the order in which the model equations are solved, which can affect the convergence speed when you are using the pressure-based solver. The standard method is enabled by default and corresponds to the ordering shown in  and  in the Theory Guide; alternatively, you can select theoptimized-for-volumetric-expansion method, which is recommended for flows in which the density is strongly dependent on thermal effects, chemical composition, and so on (such as combustion simulations). This text command is not available for steady simulations and/or when a multiphase model is enabled.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/equation_ordering").execute(*args, **kwargs)
            def p_v_controls(self, *args, **kwargs):
                """
                Sets pressure-velocity controls.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/p_v_controls").execute(*args, **kwargs)
            def gradient_scheme(self, *args, **kwargs):
                """
                Sets gradient options.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/gradient_scheme").execute(*args, **kwargs)
            def courant_number(self, *args, **kwargs):
                """
                Sets the fine-grid Courant number (time step factor). This command is available only for the coupled solvers.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/courant_number").execute(*args, **kwargs)
            def flow_warnings(self, *args, **kwargs):
                """
                Specifies whether or not to print warning messages when reversed flow occurs at inlets and outlets, and when mass-flow inlets develop supersonic regions. By default, flow warnings are printed.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/flow_warnings").execute(*args, **kwargs)
            def surface_tension(self, *args, **kwargs):
                """
                Sets surface-tension calculation options.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/surface_tension").execute(*args, **kwargs)
            def correction_tolerance(self, *args, **kwargs):
                """
                Enters the correction tolerance menu.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/correction_tolerance").execute(*args, **kwargs)
            def variable_time_stepping(self, *args, **kwargs):
                """
                Set Multiphase-Specific Adaptive time stepping parameters.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/variable_time_stepping").execute(*args, **kwargs)
            def slope_limiter_set(self, *args, **kwargs):
                """
                Selects a new Fluent solver slope limiter.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/slope_limiter_set").execute(*args, **kwargs)
            def vof_numerics(self, *args, **kwargs):
                """
                Sets VOF numeric options.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/vof_numerics").execute(*args, **kwargs)
            def nb_gradient_boundary_option(self, *args, **kwargs):
                """
                Switches between the modified treatment of node-based gradients at boundary cells and the legacy treatment (R14.5.7 and earlier). If using the density-based solver, you can also specify the extended treatment. For details, see .
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/nb_gradient_boundary_option").execute(*args, **kwargs)
            def mp_reference_density(self, *args, **kwargs):
                """
                Sets the reference density method for the Eulerian multiphase model. The following options are available:
                0 (default): Averaged density of the phase
                1: Cell density of the phase
                1: Constant value of 1
                1: Cell density of the phase
                See  for more information.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/mp_reference_density").execute(*args, **kwargs)
            def phase_based_vof_discretization(self, *args, **kwargs):
                """
                Sets phase based slope limiter for VOF compressive scheme.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/phase_based_vof_discretization").execute(*args, **kwargs)
            def enable_output_dp_dt(self, *args, **kwargs):
                """
                Controls whether the output field variabledp-dt will be available for transient simulation postprocessing. If you select no, pressure fields at the previous time steps will not be stored in memory which reduces memory usage.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/enable_output_dp_dt").execute(*args, **kwargs)
            def data_sampling(self, *args, **kwargs):
                """
                Enables data sampling for steady or unsteady flow statistics.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/data_sampling").execute(*args, **kwargs)
            def discretization_scheme(self, *args, **kwargs):
                """
                Enters the discretization scheme menu. This allows you to select the discretization scheme for the convection terms in the solution equations. The following text commands can make a selection from a subset of the models in the following table:.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/discretization_scheme").execute(*args, **kwargs)
            def solution_steering(self, *args, **kwargs):
                """
                Enables solution steering for the density-based solver.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/solution_steering").execute(*args, **kwargs)
            def second_order_time_options(self, *args, **kwargs):
                """
                Enables / disables the variable time step size formulation for second-order implicit transient formulations. If you disable the variable time step size formulation, note that any change in the time step size will introduce an error proportional to the change in the time step size ratio.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/second_order_time_options").execute(*args, **kwargs)
            def set_controls_to_default(self, *args, **kwargs):
                """
                Sets controls to default values.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/set_controls_to_default").execute(*args, **kwargs)
            def convergence_acceleration_for_stretched_meshes(self, *args, **kwargs):
                """
                Enables convergence acceleration for stretched meshes to improve the convergence of the implicit density based solver on meshes with high cell stretching.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/convergence_acceleration_for_stretched_meshes").execute(*args, **kwargs)
            def vof_explicit_controls(self, *args, **kwargs):
                """
                Sets the sub time step calculation method for VOF calculations.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/vof_explicit_controls").execute(*args, **kwargs)
            def p_v_controls_advanced(self, *args, **kwargs):
                """
                Set advanced pressure-velocity coupling controls.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/p_v_controls_advanced").execute(*args, **kwargs)
            def adaptive_time_stepping(self, *args, **kwargs):
                """
                Set Error-based adaptive time-stepping parameters.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/adaptive_time_stepping").execute(*args, **kwargs)
            def reactions(self, *args, **kwargs):
                """
                Enables the species reaction sources and sets relaxation factor.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/reactions").execute(*args, **kwargs)
            def number_of_iterations(self, *args, **kwargs):
                """
                Sets the number of iterations for a steady-state simulation without starting the calculation.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/number_of_iterations").execute(*args, **kwargs)
            def reduced_rank_extrapolation_options(self, *args, **kwargs):
                """
                Reduced Rank Extrapolation options.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/reduced_rank_extrapolation_options").execute(*args, **kwargs)
            def set_solution_steering(self, *args, **kwargs):
                """
                Sets solution steering parameters.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/set_solution_steering").execute(*args, **kwargs)
            def multi_grid_fas(self, *args, **kwargs):
                """
                Sets the parameters that control the FAS multigrid solver. This command appears only when the explicit coupled solver is used.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/multi_grid_fas").execute(*args, **kwargs)
            def residual_smoothing(self, *args, **kwargs):
                """
                Sets the implicit residual smoothing parameters. This command is available only for the explicit coupled solver.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/residual_smoothing").execute(*args, **kwargs)
            def stiff_chemistry(self, *args, **kwargs):
                """
                Sets solver options for stiff chemistry solutions.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/stiff_chemistry").execute(*args, **kwargs)
            def relaxation_factor(self, *args, **kwargs):
                """
                Enters the relaxation-factor menu.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/relaxation_factor").execute(*args, **kwargs)
            def coupled_vof_expert(self, *args, **kwargs):
                """
                Set coupled vof expert controls.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/coupled_vof_expert").execute(*args, **kwargs)
            def p_v_coupling(self, *args, **kwargs):
                """
                Selects which pressure-velocity coupling scheme is to be used. Five schemes are available:.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/p_v_coupling").execute(*args, **kwargs)
            def residual_verbosity(self, *args, **kwargs):
                """
                Sets the amount of residual information to be printed. A value of 0 (the default) prints residuals at the end of each fine grid iteration. A value of 1 prints residuals after every stage of the fine grid iteration. A value of 2 prints residuals after every stage on every grid level.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/residual_verbosity").execute(*args, **kwargs)
            def surface_tension_expert(self, *args, **kwargs):
                """
                Set surface-tension expert options.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/surface_tension_expert").execute(*args, **kwargs)
            def reduced_rank_extrapolation(self, *args, **kwargs):
                """
                Enable Reduced Rank Extrapolation method to accelerate solution time.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/reduced_rank_extrapolation").execute(*args, **kwargs)
            def pseudo_transient_expert(self, *args, **kwargs):
                """
                For backward compatibility, pseudo transient expert usage control.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/pseudo_transient_expert").execute(*args, **kwargs)
            def moving_mesh_numerics(self, *args, **kwargs):
                """
                Transient options for sliding, moving, and/or dynamic mesh.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/moving_mesh_numerics").execute(*args, **kwargs)
            def limiter_warnings(self, *args, **kwargs):
                """
                Specifies whether or not to print warning messages when quantities are being limited. By default, limiter warnings are printed.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/limiter_warnings").execute(*args, **kwargs)
            def flux_type(self, *args, **kwargs):
                """
                Enter the flux type.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/flux_type").execute(*args, **kwargs)
            def heterogeneous_stiff_chemistry(self, *args, **kwargs):
                """
                Sets the heterogeneous stiff-chemistry solver.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/heterogeneous_stiff_chemistry").execute(*args, **kwargs)
            def cfl_based_adaptive_time_stepping(self, *args, **kwargs):
                """
                Set CFL-based adaptive time-stepping parameters.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/cfl_based_adaptive_time_stepping").execute(*args, **kwargs)
            def lock_solid_temperature(self, *args, **kwargs):
                """
                Specifies whether you want to lock (or freeze) the temperature values for all the cells in solid zones (including those to which you have a hooked an energy source through a UDF) and in walls that have shell conduction enabled, so that the values do not change during further solver iterations.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/lock_solid_temperature").execute(*args, **kwargs)
            def time_step(self, *args, **kwargs):
                """
                Set the time step.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/time_step").execute(*args, **kwargs)
            def multi_stage(self, *args, **kwargs):
                """
                Sets the multi-stage coefficients and the dissipation and viscous evaluation stages. This command appears only when the explicit coupled solver is used.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/multi_stage").execute(*args, **kwargs)
            def open_channel_controls(self, *args, **kwargs):
                """
                For flows that do not transition from sub-critical to super-critical, or vice-versa, you can speed-up the solution calculation by updating the frequency of Froude number during run time.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/open_channel_controls").execute(*args, **kwargs)
            def mp_mfluid_aniso_drag(self, *args, **kwargs):
                """
                Sets anisotropic drag parameters for the Eulerian multiphase model.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/set/mp_mfluid_aniso_drag").execute(*args, **kwargs)

            class divergence_prevention(TUIMenu):
                """
                Enters the divergence prevention menu. This menu is only available for the density-based solver.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def enable(self, *args, **kwargs):
                    """
                    Enables a divergence prevention option so that Fluent applies under-relaxation to the variables in select cells where the temperature and/or pressure values are approaching the minimum and/or maximum limits.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/divergence_prevention/enable").execute(*args, **kwargs)

            class acoustics_wave_equation_controls(TUIMenu):
                """
                Enters the menu to specify parameters of the acoustics wave equation solver.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    super().__init__(service, version, mode, path)
                def relative_convergence_criterion(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/acoustics_wave_equation_controls/relative_convergence_criterion").execute(*args, **kwargs)
                def max_iterations_per_timestep(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/acoustics_wave_equation_controls/max_iterations_per_timestep").execute(*args, **kwargs)

                class expert(TUIMenu):
                    """
                    Enters the menu to specify the expert parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def under_relaxation_factor(self, *args, **kwargs):
                        """
                        Specifies the implicit under-relaxation factor. Should be used only  with bad meshes, when the AMG linear solver does not converge.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/acoustics_wave_equation_controls/expert/under_relaxation_factor").execute(*args, **kwargs)
                    def explicit_relaxation_factor(self, *args, **kwargs):
                        """
                        Specifies the explicit relaxation factor. Should be used only with  bad meshes, when iterations do not converge.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/acoustics_wave_equation_controls/expert/explicit_relaxation_factor").execute(*args, **kwargs)

            class data_sampling_options(TUIMenu):
                """
                Enter the menu for specifying quantities and zones for steady and unsteady flow statistics.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.dft_datasets = self.__class__.dft_datasets(service, version, mode, path + ["dft_datasets"])
                    super().__init__(service, version, mode, path)
                def add_datasets(self, *args, **kwargs):
                    """
                    Add a dataset. After providing the zones for a dataset, press [Enter] to move onto selecting quantities. Enter () to complete the quantity selection for this dataset.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/data_sampling_options/add_datasets").execute(*args, **kwargs)
                def list_datasets(self, *args, **kwargs):
                    """
                    Lists the combinations of zones and quantities that are defined for sampling steady and unsteady flow statistics.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/data_sampling_options/list_datasets").execute(*args, **kwargs)
                def remove_dataset(self, *args, **kwargs):
                    """
                    Remove dataset.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/data_sampling_options/remove_dataset").execute(*args, **kwargs)

                class dft_datasets(TUIMenu):
                    """
                    Data sampling options for runtime discrete Fourier transform.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def delete_dataset(self, *args, **kwargs):
                        """
                        Delete DFT datasets.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/data_sampling_options/dft_datasets/delete_dataset").execute(*args, **kwargs)
                    def add_band_datasets(self, *args, **kwargs):
                        """
                        Add DFT datasets for a frequency band.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/data_sampling_options/dft_datasets/add_band_datasets").execute(*args, **kwargs)
                    def list_datasets(self, *args, **kwargs):
                        """
                        List DFT datasets.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/data_sampling_options/dft_datasets/list_datasets").execute(*args, **kwargs)
                    def window_function(self, *args, **kwargs):
                        """
                        Select window function for a DFT dataset.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/data_sampling_options/dft_datasets/window_function").execute(*args, **kwargs)
                    def quantities(self, *args, **kwargs):
                        """
                        Select quantities for a new DFT dataset. Enter () to complete the quantity selection.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/data_sampling_options/dft_datasets/quantities").execute(*args, **kwargs)
                    def add_tone_datasets(self, *args, **kwargs):
                        """
                        Add DFT datasets for a single tone.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/data_sampling_options/dft_datasets/add_tone_datasets").execute(*args, **kwargs)
                    def dataset_properties(self, *args, **kwargs):
                        """
                        Print properties of a DFT dataset.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/data_sampling_options/dft_datasets/dataset_properties").execute(*args, **kwargs)
                    def zones(self, *args, **kwargs):
                        """
                        Select zones for a new DFT dataset.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/data_sampling_options/dft_datasets/zones").execute(*args, **kwargs)

            class warped_face_gradient_correction(TUIMenu):
                """
                Enters the warped-face gradient correction menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def turbulence_options(self, *args, **kwargs):
                    """
                    Set turbulence Warped Face Gradient Correction.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/warped_face_gradient_correction/turbulence_options").execute(*args, **kwargs)
                def enable(self, *args, **kwargs):
                    """
                    Enables/disables gradient enhancement computations and specifies whether Fluent uses fast or memory saving mode.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/warped_face_gradient_correction/enable").execute(*args, **kwargs)

            class overset(TUIMenu):
                """
                Specifies overset meshing solver options.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    super().__init__(service, version, mode, path)
                def orphan_cell_treatment(self, *args, **kwargs):
                    """
                    Enables/disables a numerical treatment that attempts to assign reasonable data values to orphan cells.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/overset/orphan_cell_treatment").execute(*args, **kwargs)
                def high_order_pressure(self, *args, **kwargs):
                    """
                    Uses the pressure gradient of the donor cell in the interpolation of pressure for its receptor cell.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/overset/high_order_pressure").execute(*args, **kwargs)
                def interpolation_method(self, *args, **kwargs):
                    """
                    Selects the interpolation method for overset interfaces. Note that the least squares method is recommended for sliding mesh cases.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/overset/interpolation_method").execute(*args, **kwargs)

                class expert(TUIMenu):
                    """
                    Enter overset expert solver options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def hybrid_mode_selection(self, *args, **kwargs):
                        """
                        Mode for hybrid interpolation.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/overset/expert/hybrid_mode_selection").execute(*args, **kwargs)
                    def mass_flux_correction_method(self, *args, **kwargs):
                        """
                        Enter mass flux correction option at overset interfaces.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/overset/expert/mass_flux_correction_method").execute(*args, **kwargs)

            class transient_controls(TUIMenu):
                """
                Enters the transient controls menu, which allows you to define settings related to time advancement for transient flow calculations.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.multiphase_specific_time_constraints = self.__class__.multiphase_specific_time_constraints(service, version, mode, path + ["multiphase_specific_time_constraints"])
                    super().__init__(service, version, mode, path)
                def solid_time_step_size(self, *args, **kwargs):
                    """
                    Allows you to specify that the time step size used for solid zones is independent from that used for fluid zones. This text command is only available when both a solid zone exists and energy is enabled.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/solid_time_step_size").execute(*args, **kwargs)
                def cfl_based_time_stepping(self, *args, **kwargs):
                    """
                    Allows you to specify that an adaptive time stepping method is used in which the time step gets modified by ANSYS Fluent as the calculation proceeds such that the CourantFriedrichsLewy (CFL) condition is satisfied, using the specified Courant number.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/cfl_based_time_stepping").execute(*args, **kwargs)
                def fixed_periodic(self, *args, **kwargs):
                    """
                    Allows you to specify that a fixed time stepping method is used in which a specified period or frequency is the basis for determining the time step size and number of time steps.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/fixed_periodic").execute(*args, **kwargs)
                def incremental_time(self, *args, **kwargs):
                    """
                    Sets the amount of incremental (that is, additional) time to run the simulation, regardless of how much time has already been run in previous calculations. This text command is only available when the solve/set/transient-controls/duration-specification-method is set to3.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/incremental_time").execute(*args, **kwargs)
                def duration_specification_method(self, *args, **kwargs):
                    """
                    Sets the method by which you will specify the duration of the calculation. The duration can be defined by the total time, the total number of time steps, the incremental time, or the number of incremental time steps. In this context, "total" indicates that Fluent will consider the amount of time / steps that have already been solved and stop appropriately, whereas "incremental" indicates that the solution will proceed for a specified amount of time / steps regardless of what has previously been calculated. This text command is only available when the time stepping is adaptive or based on a user-defined function.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/duration_specification_method").execute(*args, **kwargs)
                def specified_time_step(self, *args, **kwargs):
                    """
                    Specifies whether to define the transient advancement either directly by entering a time step size / period / frequency (using the text commands available in thesolve/set/transient-controls menu) or indirectly by entering a Courant number value (using the solve/set/courant-number text command). This text command is only available for the density-based solver when both the explicit formulation and explicit transient formulation are used.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/specified_time_step").execute(*args, **kwargs)
                def fixed_user_specified(self, *args, **kwargs):
                    """
                    Allows you to specify that a fixed time stepping method is used in which you directly specify the time step size and number of time steps.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/fixed_user_specified").execute(*args, **kwargs)
                def time_step_size_for_acoustic_export(self, *args, **kwargs):
                    """
                    Specifies the time interval for acoustic data sampling. This text command is only available when both the Ffowcs Williams and Hawkings model is selected and the density-based solver is used with the explicit formulation and explicit transient formulation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/time_step_size_for_acoustic_export").execute(*args, **kwargs)
                def udf_based_time_stepping(self, *args, **kwargs):
                    """
                    Allows you to specify that the time step size is defined by a user-defined function (UDF) that uses theDEFINE_DELTAT macro.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/udf_based_time_stepping").execute(*args, **kwargs)
                def time_step_size(self, *args, **kwargs):
                    """
                    Sets the magnitude of the (physical) time step . This text command is only available when the solve/set/transient-controls/fixed-user-specified text command is set toyes.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/time_step_size").execute(*args, **kwargs)
                def number_of_time_steps(self, *args, **kwargs):
                    """
                    Sets the number of time steps for a transient simulation without starting the calculation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/number_of_time_steps").execute(*args, **kwargs)
                def total_time(self, *args, **kwargs):
                    """
                    Sets the total amount of time that the simulation will be run (which includes any time that has already been run in previous calculations). This text command is only available when the solve/set/transient-controls/duration-specification-method is set to2.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/total_time").execute(*args, **kwargs)
                def max_iterations_per_time_step(self, *args, **kwargs):
                    """
                    Sets the number of time steps for a transient simulation.  This option is available when automatic initialization and case modification is enabled.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/max_iterations_per_time_step").execute(*args, **kwargs)
                def total_number_of_time_steps(self, *args, **kwargs):
                    """
                    Sets the total number of time steps that the simulation will run (which includes any time steps that have already been run in previous calculations). This text command is only available when the solve/set/transient-controls/duration-specification-method is set to1.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/total_number_of_time_steps").execute(*args, **kwargs)
                def cfl_based_time_stepping_advanced_options(self, *args, **kwargs):
                    """
                    Set CFL-based adaptive time-stepping advanced parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/cfl_based_time_stepping_advanced_options").execute(*args, **kwargs)
                def extrapolate_vars(self, *args, **kwargs):
                    """
                    Applies a predictor algorithm for computing initial conditions at time step n+1. The predictor algorithm is a computation that sets a better initial condition for the time step.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/extrapolate_vars").execute(*args, **kwargs)
                def rotating_mesh_flow_predictor(self, *args, **kwargs):
                    """
                    Enables / disables an option that allows for better prediction of the flow field in rotating fluid zones at every time step, in order to speed up the calculation. This text command is only available for transient simulations.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/rotating_mesh_flow_predictor").execute(*args, **kwargs)
                def error_based_time_stepping(self, *args, **kwargs):
                    """
                    Allows you to specify that an adaptive time stepping method is used in which the time step gets modified by ANSYS Fluent  based on the specified truncation error tolerance.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/error_based_time_stepping").execute(*args, **kwargs)
                def solution_status(self, *args, **kwargs):
                    """
                    Allows you to open theSimulation Status dialog box, which reports details about the simulation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/solution_status").execute(*args, **kwargs)
                def extrapolate_eqn_vars(self, *args, **kwargs):
                    """
                    Enters the extrapolation menu.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/extrapolate_eqn_vars").execute(*args, **kwargs)
                def undo_timestep(self, *args, **kwargs):
                    """
                    When enabled, if the truncation error within a time step exceeds the specified tolerance Fluent will automatically undo the current calculation and make another attempt with the time step reduced by 1/2. This will be attempted up to 5 times after which Fluent will accept the result and proceed to the next time step.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/undo_timestep").execute(*args, **kwargs)
                def predict_next_time(self, *args, **kwargs):
                    """
                    Applies a predictor algorithm for computing the next time step. The predictor algorithm is a computation that sets a better initial condition for the time step. It uses the rate of change between the prediction and the correction as an indicator for whether the next time step should be larger, smaller, or the same as the current one.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/predict_next_time").execute(*args, **kwargs)
                def multiphase_specific_time_stepping(self, *args, **kwargs):
                    """
                    Allows you to specify that an adaptive time stepping method is used in which the time step gets modified by ANSYS Fluent  based on the convective time scale (global Courant number): the time-step-size calculation depends on the mesh density and velocity in interfacial cells. This method is available for all multiphase models using the implicit or explicit volume fraction formulation, except for the wet steam model.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/multiphase_specific_time_stepping").execute(*args, **kwargs)
                def max_flow_time(self, *args, **kwargs):
                    """
                    Sets the maximum flow time.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/max_flow_time").execute(*args, **kwargs)

                class multiphase_specific_time_constraints(TUIMenu):
                    """
                    Enters the menu for setting multiphase-specific time constraints.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.time_scale_options = self.__class__.time_scale_options(service, version, mode, path + ["time_scale_options"])
                        super().__init__(service, version, mode, path)
                    def moving_mesh_cfl_constraint(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/multiphase_specific_time_constraints/moving_mesh_cfl_constraint").execute(*args, **kwargs)
                    def physics_based_constraint(self, *args, **kwargs):
                        """
                        Enables/disables the physics-driven time-step constraints.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/multiphase_specific_time_constraints/physics_based_constraint").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        When enabled, various time scales (depending on the selection) are  printed to the console window at every time step. This text command is  available with the moving mesh CFL constraint and with the physics-based  constraint.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/multiphase_specific_time_constraints/verbosity").execute(*args, **kwargs)

                    class time_scale_options(TUIMenu):
                        """
                        Enters the menu for choosing the time-scale options. This menu  becomes available after you enable the physics-driven time-step  constraints using the solve/set/transient-controls/multiphase-specific-time-constraints/physics-based-constraint?  text command.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def viscous_scale(self, *args, **kwargs):
                            """
                            Allows you to Include the viscous time scale. This option is disabled by default. This command is not available with inviscid flows.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/multiphase_specific_time_constraints/time_scale_options/viscous_scale").execute(*args, **kwargs)
                        def surface_tension_scale(self, *args, **kwargs):
                            """
                            Allows you to Include the surface-tension-driven time scale. This option is available only if the surface tension force modeling is enabled.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/multiphase_specific_time_constraints/time_scale_options/surface_tension_scale").execute(*args, **kwargs)
                        def gravity_scale(self, *args, **kwargs):
                            """
                            Allows you to Include the gravitational time scale. This option is available only if gravity is enabled.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/multiphase_specific_time_constraints/time_scale_options/gravity_scale").execute(*args, **kwargs)
                        def acoustic_scale(self, *args, **kwargs):
                            """
                            Allows you to Include the acoustic time scale. This option is available only for compressible flows.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/transient_controls/multiphase_specific_time_constraints/time_scale_options/acoustic_scale").execute(*args, **kwargs)

            class fast_transient_settings(TUIMenu):
                """
                Enters the fast transient settings menu. This menu is only available for transient cases that use the density-based solver.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def rk2(self, *args, **kwargs):
                    """
                    Allows you to enable the use of a two-stage Runge-Kutta scheme for time integration, or revert to the default multi-stage Runge-Kutta scheme. This text command is only available for transient cases that use the density-based explicit formulation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/fast_transient_settings/rk2").execute(*args, **kwargs)

            class open_channel_wave_options(TUIMenu):
                """
                Sets buffer layer height, verbosity, and open channel wave theory formulation.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def set_buffer_layer_ht(self, *args, **kwargs):
                    """
                    Sets the buffer layer height.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/open_channel_wave_options/set_buffer_layer_ht").execute(*args, **kwargs)
                def set_verbosity(self, *args, **kwargs):
                    """
                    Sets the open channel wave verbosity.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/open_channel_wave_options/set_verbosity").execute(*args, **kwargs)
                def stokes_wave_variants(self, *args, **kwargs):
                    """
                    Specifies which open channel wave theory formulation Fluent uses.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/open_channel_wave_options/stokes_wave_variants").execute(*args, **kwargs)

            class contact_solution_controls(TUIMenu):
                """
                Solver controls for contact marks method.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.miscellaneous = self.__class__.miscellaneous(service, version, mode, path + ["miscellaneous"])
                    self.spatial = self.__class__.spatial(service, version, mode, path + ["spatial"])
                    self.amg = self.__class__.amg(service, version, mode, path + ["amg"])
                    self.models = self.__class__.models(service, version, mode, path + ["models"])
                    self.methods = self.__class__.methods(service, version, mode, path + ["methods"])
                    self.parameters = self.__class__.parameters(service, version, mode, path + ["parameters"])
                    self.transient = self.__class__.transient(service, version, mode, path + ["transient"])
                    super().__init__(service, version, mode, path)
                def verbosity(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/verbosity").execute(*args, **kwargs)
                def solution_stabilization(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/solution_stabilization").execute(*args, **kwargs)
                def set_settings_to_default(self, *args, **kwargs):
                    """
                    Set contact solution stabilization to default.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/set_settings_to_default").execute(*args, **kwargs)

                class miscellaneous(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def statistics_level(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/miscellaneous/statistics_level").execute(*args, **kwargs)
                    def compute_statistics(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/miscellaneous/compute_statistics").execute(*args, **kwargs)

                class spatial(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def rhie_chow_flux_specify(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/spatial/rhie_chow_flux_specify").execute(*args, **kwargs)
                    def rhie_chow_method(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/spatial/rhie_chow_method").execute(*args, **kwargs)
                    def scheme(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/spatial/scheme").execute(*args, **kwargs)
                    def first_to_second_order_blending(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/spatial/first_to_second_order_blending").execute(*args, **kwargs)
                    def first_to_second_order_blending_list(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/spatial/first_to_second_order_blending_list").execute(*args, **kwargs)
                    def scalars_skew_diffusion_exclude(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/spatial/scalars_skew_diffusion_exclude").execute(*args, **kwargs)
                    def flow_skew_diffusion_exclude(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/spatial/flow_skew_diffusion_exclude").execute(*args, **kwargs)

                class amg(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def specify_coarsening_rate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/amg/specify_coarsening_rate").execute(*args, **kwargs)
                    def pre_sweeps(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/amg/pre_sweeps").execute(*args, **kwargs)
                    def increase_pre_sweeps(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/amg/increase_pre_sweeps").execute(*args, **kwargs)
                    def coarsen_rate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/amg/coarsen_rate").execute(*args, **kwargs)
                    def enforce_laplace_coarsening(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/amg/enforce_laplace_coarsening").execute(*args, **kwargs)

                class models(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def ramp_flow(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/models/ramp_flow").execute(*args, **kwargs)
                    def model_ramping(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/models/model_ramping").execute(*args, **kwargs)
                    def ramp_turbulence(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/models/ramp_turbulence").execute(*args, **kwargs)
                    def ramp_scalars(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/models/ramp_scalars").execute(*args, **kwargs)

                class methods(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def gradient_controls(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/methods/gradient_controls").execute(*args, **kwargs)
                    def specify_gradient_method(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/methods/specify_gradient_method").execute(*args, **kwargs)
                    def pressure_velocity_coupling_method(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/methods/pressure_velocity_coupling_method").execute(*args, **kwargs)
                    def pressure_velocity_coupling_controls(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/methods/pressure_velocity_coupling_controls").execute(*args, **kwargs)

                class parameters(TUIMenu):
                    """
                    Parameters used in stabilization strategy.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def persistence_fixed_duration(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/parameters/persistence_fixed_duration").execute(*args, **kwargs)
                    def extrapolation_method(self, *args, **kwargs):
                        """
                        Solution extrapolation method for cells changing status from contact to non-contact [0-none, 1-local extrapolation].
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/parameters/extrapolation_method").execute(*args, **kwargs)
                    def iterations(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/parameters/iterations").execute(*args, **kwargs)
                    def persistence_fixed_time_steps(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/parameters/persistence_fixed_time_steps").execute(*args, **kwargs)
                    def solution_stabilization_persistence(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/parameters/solution_stabilization_persistence").execute(*args, **kwargs)

                class transient(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def time_scale_modification_method(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/transient/time_scale_modification_method").execute(*args, **kwargs)
                    def transient_scheme(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/transient/transient_scheme").execute(*args, **kwargs)
                    def transient_parameters_specify(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/transient/transient_parameters_specify").execute(*args, **kwargs)
                    def time_scale_modification_factor(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/contact_solution_controls/transient/time_scale_modification_factor").execute(*args, **kwargs)

            class amg_options(TUIMenu):
                """
                Enters the AMG options menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def amg_gpgpu_options(self, *args, **kwargs):
                    """
                    Set GPGPU AMG solver options.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/amg_options/amg_gpgpu_options").execute(*args, **kwargs)
                def conservative_amg_coarsening(self, *args, **kwargs):
                    """
                    Enables / disables the use of conservative coarsening techniques for scalar and/or coupled equations that can improve parallel performance and/or convergence for some difficult cases.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/amg_options/conservative_amg_coarsening").execute(*args, **kwargs)
                def aggressive_amg_coarsening(self, *args, **kwargs):
                    """
                    Enables / disables the use of a version of the AMG solver that is optimized for high coarsening rates. This option is recommended if the AMG solver diverges with the default settings.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/amg_options/aggressive_amg_coarsening").execute(*args, **kwargs)
                def laplace_coarsening(self, *args, **kwargs):
                    """
                    Enables / disables Laplace coarsening for scalar and/or coupled equations.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/amg_options/laplace_coarsening").execute(*args, **kwargs)

            class advanced(TUIMenu):
                """
                Enters the advanced settings menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.secondary_gradient_limiting = self.__class__.secondary_gradient_limiting(service, version, mode, path + ["secondary_gradient_limiting"])
                    self.turbomachinery_specific_numerics = self.__class__.turbomachinery_specific_numerics(service, version, mode, path + ["turbomachinery_specific_numerics"])
                    self.anisotropic_solid_heat_transfer = self.__class__.anisotropic_solid_heat_transfer(service, version, mode, path + ["anisotropic_solid_heat_transfer"])
                    self.non_reflecting_boundary_treatment = self.__class__.non_reflecting_boundary_treatment(service, version, mode, path + ["non_reflecting_boundary_treatment"])
                    super().__init__(service, version, mode, path)
                def skewness_correction_enhanced(self, *args, **kwargs):
                    """
                    Enable enhanced skewness correction scheme.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/skewness_correction_enhanced").execute(*args, **kwargs)
                def volume_flux_for_single_phase(self, *args, **kwargs):
                    """
                    Enable/disable volume flux formulation for single phase flows.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/volume_flux_for_single_phase").execute(*args, **kwargs)
                def bcd_weights_freeze(self, *args, **kwargs):
                    """
                    Enables/disables freezing of weighting coefficients of the central differencing and the upwind components of the BCD scheme. This dialog command requires the iteration number, after which the BCD scheme weights are to be frozen at each timestep. Freezing the BCD weighting coefficients may help to improve convergence of the timestep iterations as described in .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/bcd_weights_freeze").execute(*args, **kwargs)
                def energy_numerical_noise_filter(self, *args, **kwargs):
                    """
                    Enables/disables a filter to eliminate non-physical numerical noise in the energy field. Numerical noise can appear in solution fields where large variations in specific heat or combustion with phase change are present. Using the energy equation numerical noise filter increases robustness, but may make the solution slightly more diffusive. This text command is only available with the pressure-based solver.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/energy_numerical_noise_filter").execute(*args, **kwargs)
                def show_all_discretization_schemes(self, *args, **kwargs):
                    """
                    Enables/disables the availability of all applicable discretization schemes.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/show_all_discretization_schemes").execute(*args, **kwargs)
                def singhal_et_al_cavitation_model(self, *args, **kwargs):
                    """
                    Enables/disables the availability of the Singhal et al. cavitation model option, which can then be enabled in the Multiphase Model dialog box or by using the following text command: define/phases/set-domain-properties/interaction-domain/heat-mass-reaction/cavitation/cavitation?.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/singhal_et_al_cavitation_model").execute(*args, **kwargs)
                def energy_reconstruction_gradient_limiting(self, *args, **kwargs):
                    """
                    Enable limiting of reconstruction gradient for the energy equation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/energy_reconstruction_gradient_limiting").execute(*args, **kwargs)
                def explicit_under_relaxation_value(self, *args, **kwargs):
                    """
                    Explicit under-relaxation value.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/explicit_under_relaxation_value").execute(*args, **kwargs)
                def bcd_scheme_type(self, *args, **kwargs):
                    """
                    BCD scheme type (standard or tunable).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/bcd_scheme_type").execute(*args, **kwargs)
                def retain_cell_residuals(self, *args, **kwargs):
                    """
                    Enables/disables the retention of cell residuals for postprocessing.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/retain_cell_residuals").execute(*args, **kwargs)
                def retain_temporary_solver_mem(self, *args, **kwargs):
                    """
                    Enables/disables the retention of temporary solver memory, which retains gradient data and makes some advanced options available for postprocessing.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/retain_temporary_solver_mem").execute(*args, **kwargs)
                def anisotropic_heat_flux(self, *args, **kwargs):
                    """
                    Select the heat flux calculation methods.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/anisotropic_heat_flux").execute(*args, **kwargs)
                def alternate_wall_temp_formulation(self, *args, **kwargs):
                    """
                    Enables/disables an alternate formulation for wall temperatures.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/alternate_wall_temp_formulation").execute(*args, **kwargs)
                def bcd_boundedness(self, *args, **kwargs):
                    """
                    Specifies the BCD scheme parameter, which controls the boundedness strength of the BCD scheme in the pressure-based solver, as described in .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/bcd_boundedness").execute(*args, **kwargs)
                def linearized_mass_transfer_udf(self, *args, **kwargs):
                    """
                    Enables/disables the use of a linearized mass transfer user-defined function (that is, the DEFINE_LINEARIZED_MASS_TRANSFER macro), as opposed to a mass transfer user-defined function (that is, the DEFINE_MASS_TRANSFER macro).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/linearized_mass_transfer_udf").execute(*args, **kwargs)
                def correction_form(self, *args, **kwargs):
                    """
                    S.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/correction_form").execute(*args, **kwargs)

                class secondary_gradient_limiting(TUIMenu):
                    """
                    Enters the secondary gradient limiting menu. This menu is only available when the define/models/solver/pressure-based text command is enabled.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def energy(self, *args, **kwargs):
                        """
                        Enables/disables secondary gradient limiting for the energy  calculations on coupled two-sided walls. This limiting can help prevent  divergence when the cells on such walls have poor orthogonality.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/secondary_gradient_limiting/energy").execute(*args, **kwargs)
                    def mesh_quality_limits(self, *args, **kwargs):
                        """
                        Defines the mesh quality limits used when applying secondary  gradient limiting to faces on coupled two-sided walls. Shifting this  range closer to 1 will decrease the risk of divergence, but at the cost  of accuracy.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/secondary_gradient_limiting/mesh_quality_limits").execute(*args, **kwargs)
                    def uds(self, *args, **kwargs):
                        """
                        Enables/disables secondary gradient limiting for the user-defined  scalar (UDS) calculations on coupled two-sided walls. This limiting can  help prevent divergence when the cells on such walls have poor  orthogonality.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/secondary_gradient_limiting/uds").execute(*args, **kwargs)

                class turbomachinery_specific_numerics(TUIMenu):
                    """
                    Enter turbomachinery specific numerics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def enable(self, *args, **kwargs):
                        """
                        Activate/deactivate turbomachinery specific numerics.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/turbomachinery_specific_numerics/enable").execute(*args, **kwargs)
                    def settings(self, *args, **kwargs):
                        """
                        Adjust settings for turbomachinery specific numerics.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/turbomachinery_specific_numerics/settings").execute(*args, **kwargs)

                class anisotropic_solid_heat_transfer(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def gradient(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/anisotropic_solid_heat_transfer/gradient").execute(*args, **kwargs)
                    def flux(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/anisotropic_solid_heat_transfer/flux").execute(*args, **kwargs)

                class non_reflecting_boundary_treatment(TUIMenu):
                    """
                    Enter non reflecting boundary treatment using minimal pressure reflection approach menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def velocity_inlet(self, *args, **kwargs):
                        """
                        Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/non_reflecting_boundary_treatment/velocity_inlet").execute(*args, **kwargs)
                    def pressure_inlet(self, *args, **kwargs):
                        """
                        Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/non_reflecting_boundary_treatment/pressure_inlet").execute(*args, **kwargs)
                    def pressure_outlet(self, *args, **kwargs):
                        """
                        Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/advanced/non_reflecting_boundary_treatment/pressure_outlet").execute(*args, **kwargs)

            class poor_mesh_numerics(TUIMenu):
                """
                Enters the poor mesh numerics menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.register_based = self.__class__.register_based(service, version, mode, path + ["register_based"])
                    self.solution_based_pmn = self.__class__.solution_based_pmn(service, version, mode, path + ["solution_based_pmn"])
                    super().__init__(service, version, mode, path)
                def solution_and_quality_based(self, *args, **kwargs):
                    """
                    Enables/disables the detection and treatment of poor cells using a criterion based on the solution and cell quality. Poor mesh numerics are applied when the criterion value is equal to or less than a threshold value defined as part of this text command, and at a specified frequency (of iterations or time steps). This criterion is only available with the pressure-based solver.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/solution_and_quality_based").execute(*args, **kwargs)
                def enhanced_pmn(self, *args, **kwargs):
                    """
                    This option is available with the density-based solver. When enabled, it will apply quality-based poor-mesh-numerics order=1 on any cells with a quality-measure below 0.2. In addition, their CFL number is limited to 1.0.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/enhanced_pmn").execute(*args, **kwargs)
                def orthogonality_enhancing_cell_centroids(self, *args, **kwargs):
                    """
                    Enables/disables the relocation of select cell centroids, to improve the orthogonality metrics and solution stability. It is applied to cells when the criterion value is equal to or less than a threshold value defined as part of the text command. Note that the enhanced metrics are only apparent when reporting the quality in the solution mode of Fluent, and not in the meshing mode.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/orthogonality_enhancing_cell_centroids").execute(*args, **kwargs)
                def set_quality_threshold(self, *args, **kwargs):
                    """
                    Sets the orthogonal quality threshold used for applying poor mesh numerics when the solve/set/poor-mesh-numerics/cell-quality-based? text command is enabled. By default, cells with an orthogonal quality of 0.05 or lower are corrected.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/set_quality_threshold").execute(*args, **kwargs)
                def cell_quality_based(self, *args, **kwargs):
                    """
                    Enables/disables the application of poor mesh numerics on cells with an orthogonal quality that is equal to or less than the threshold defined by the solve/set/poor-mesh-numerics/set-quality-threshold text command (which by default is set to 0.05).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/cell_quality_based").execute(*args, **kwargs)
                def user_defined_on_register_auto(self, *args, **kwargs):
                    """
                    Set up the application of poor mesh numerics to cells in registers during the calculation at a specified frequency.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/user_defined_on_register_auto").execute(*args, **kwargs)
                def gradient_quality_based(self, *args, **kwargs):
                    """
                    Enables/disables the detection and treatment of poor cells using a criterion based on the cell gradient quality. Poor mesh numerics are applied when the criterion value is equal to or less than a threshold value defined as part of this text command. This criterion is only available with the pressure-based solver, and is not supported for cases that have periodic boundaries.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/gradient_quality_based").execute(*args, **kwargs)
                def print_poor_elements_count(self, *args, **kwargs):
                    """
                    Prints out a listing of the poor cells for each criterion: default, cell quality, and user-defined, and (if enabled) cell gradient quality and solution and cell quality.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/print_poor_elements_count").execute(*args, **kwargs)
                def reset_poor_elements(self, *args, **kwargs):
                    """
                    Resets the list of poor cells included by the default, cell quality, user-defined, cell gradient quality, and solution and cell quality criteria.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/reset_poor_elements").execute(*args, **kwargs)
                def enable(self, *args, **kwargs):
                    """
                    Enables/disables the application of poor mesh numerics on cells (those with an orthogonal quality of 0, as well as those identified by other enabled criteria), and defines whether the local solution correction is 0th, 1st, or 2nd order.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/enable").execute(*args, **kwargs)
                def turbulence_production_term(self, *args, **kwargs):
                    """
                    Enable/disable poor mesh numerics for turbulence production term.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/turbulence_production_term").execute(*args, **kwargs)
                def user_defined_on_register(self, *args, **kwargs):
                    """
                    Includes a register for the poor mesh numerics or not.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/user_defined_on_register").execute(*args, **kwargs)

                class register_based(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def list_properties(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/register_based/list_properties").execute(*args, **kwargs)
                    def edit(self, *args, **kwargs):
                        """
                        Edit a definition for poor mesh numerics.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/register_based/edit").execute(*args, **kwargs)
                    def duplicate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/register_based/duplicate").execute(*args, **kwargs)
                    def set(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/register_based/set").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/register_based/list").execute(*args, **kwargs)
                    def rename(self, *args, **kwargs):
                        """
                        Rename register-based object.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/register_based/rename").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete a definition for poor mesh numerics.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/register_based/delete").execute(*args, **kwargs)
                    def new(self, *args, **kwargs):
                        """
                        Add a new definition for poor mesh numerics.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/register_based/new").execute(*args, **kwargs)

                class solution_based_pmn(TUIMenu):
                    """
                    Solution based poor-mesh numerics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def mark_cfl_limit(self, *args, **kwargs):
                        """
                        Mark cells exceeding cfl limit.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/solution_based_pmn/mark_cfl_limit").execute(*args, **kwargs)
                    def enable(self, *args, **kwargs):
                        """
                        Enable solution based treatment.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/solution_based_pmn/enable").execute(*args, **kwargs)
                    def mark_cfl_jump(self, *args, **kwargs):
                        """
                        Mark cells exceeding cfl jump in neighborhood.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/solution_based_pmn/mark_cfl_jump").execute(*args, **kwargs)
                    def mark_velocity_limit(self, *args, **kwargs):
                        """
                        Mark cells exceeding velocity limit.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/solution_based_pmn/mark_velocity_limit").execute(*args, **kwargs)
                    def mark_primary_solution_limits(self, *args, **kwargs):
                        """
                        Mark cells violating solution limits.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/poor_mesh_numerics/solution_based_pmn/mark_primary_solution_limits").execute(*args, **kwargs)

            class pseudo_time_method(TUIMenu):
                """
                Enters the pseudo time method menu. This menu is only available for cases that use a pressure-based segregated solver (SIMPLE, SIMPLEC, or PISO) or for steady-state cases that use the pressure-based coupled solver or the density-based implicit solver.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def relaxation_method(self, *args, **kwargs):
                    """
                    Select relaxation definition for pseudo time method.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/pseudo_time_method/relaxation_method").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    Sets the verbosity of the messages related to the pseudo time method.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/pseudo_time_method/verbosity").execute(*args, **kwargs)
                def advanced_options(self, *args, **kwargs):
                    """
                    Enters the advanced options menu, which allows you to enable / disable the pseudo time method for individual equations and define their pseudo time scale factors or under-relaxation factors, respectively. These settings only apply when the global time step formulation is selected.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/pseudo_time_method/advanced_options").execute(*args, **kwargs)
                def formulation(self, *args, **kwargs):
                    """
                    Enables and sets the pseudo time step size formulation or disables the pseudo time method option.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/pseudo_time_method/formulation").execute(*args, **kwargs)
                def relaxation_factors(self, *args, **kwargs):
                    """
                    Enters the relaxation factors menu, where you can set the pseudo time explicit relaxation factors for individual equations. These factors only apply when the global time step formulation is selected.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/pseudo_time_method/relaxation_factors").execute(*args, **kwargs)
                def global_time_step_settings(self, *args, **kwargs):
                    """
                    Defines the pseudo time settings for the calculation when the global time step formulation is selected.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/pseudo_time_method/global_time_step_settings").execute(*args, **kwargs)
                def relaxation_bounds(self, *args, **kwargs):
                    """
                    Select relaxation bounding scheme for pseudo time method.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/pseudo_time_method/relaxation_bounds").execute(*args, **kwargs)
                def local_time_step_settings(self, *args, **kwargs):
                    """
                    Defines the pseudo time Courant number when the local time step formulation is selected.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/pseudo_time_method/local_time_step_settings").execute(*args, **kwargs)
                def explicit_relaxation(self, *args, **kwargs):
                    """
                    Enable the explicit relaxation option for the pseudo time method.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/pseudo_time_method/explicit_relaxation").execute(*args, **kwargs)
                def convergence_acceleration_for_stretched_meshes(self, *args, **kwargs):
                    """
                    Enable convergence acceleration for stretched meshes to improve the convergence of the implicit pressure based solver on meshes with high cell stretching.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/pseudo_time_method/convergence_acceleration_for_stretched_meshes").execute(*args, **kwargs)

            class high_speed_numerics(TUIMenu):
                """
                Enter high-speed-numerics menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def expert(self, *args, **kwargs):
                    """
                    Sets the level of stabilization used to achieve fast convergence. Enter a number 0-5 corresponding to the Mach number range that best characterizes the flow.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/high_speed_numerics/expert").execute(*args, **kwargs)
                def enable(self, *args, **kwargs):
                    """
                    Enables/disables High Speed Numerics.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/high_speed_numerics/enable").execute(*args, **kwargs)
                def visualize_pressure_discontinuity_sensor(self, *args, **kwargs):
                    """
                    Makes available the Pressure Discontinuity Sensor which is a binary identifier equal to 1 if a cell is in proximity of a pressure discontinuity.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/high_speed_numerics/visualize_pressure_discontinuity_sensor").execute(*args, **kwargs)

            class enhanced_les_numerics(TUIMenu):
                """
                Enter enhanced LES options menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def optimized_cd(self, *args, **kwargs):
                    """
                    Use optimized central difference discretization.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/enhanced_les_numerics/optimized_cd").execute(*args, **kwargs)
                def optimized_algorithm(self, *args, **kwargs):
                    """
                    Use solver algorithm optimized for LES.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/enhanced_les_numerics/optimized_algorithm").execute(*args, **kwargs)
                def optimized_advection(self, *args, **kwargs):
                    """
                    Use advection scheme optimized for LES.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/enhanced_les_numerics/optimized_advection").execute(*args, **kwargs)

            class nita_expert_controls(TUIMenu):
                """
                Enters the NITA expert control menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def verbosity(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/nita_expert_controls/verbosity").execute(*args, **kwargs)
                def skewness_neighbor_coupling(self, *args, **kwargs):
                    """
                    Enables/disables coupling of the neighbor and skewness corrections.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/nita_expert_controls/skewness_neighbor_coupling").execute(*args, **kwargs)
                def hybrid_nita_settings(self, *args, **kwargs):
                    """
                    Enables and sets hybrid NITA options. For more details, see .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/nita_expert_controls/hybrid_nita_settings").execute(*args, **kwargs)

            class previous_defaults(TUIMenu):
                """
                Provides text commands that allow you to undo enhancements to the default solver behavior.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def undo_2023r1_default_changes(self, *args, **kwargs):
                    """
                    Undo default changes introduced in 2023R1.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/previous_defaults/undo_2023r1_default_changes").execute(*args, **kwargs)
                def undo_2021r2_default_changes(self, *args, **kwargs):
                    """
                    Allows you to undo the following enhancements introduced in version 2021 R2 of ANSYS Fluent:.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/previous_defaults/undo_2021r2_default_changes").execute(*args, **kwargs)
                def undo_2019r3_default_changes(self, *args, **kwargs):
                    """
                    Allows you to undo enhancements introduced in version 2019 R3 of ANSYS Fluent, including:.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/previous_defaults/undo_2019r3_default_changes").execute(*args, **kwargs)
                def undo_2019r1_default_changes(self, *args, **kwargs):
                    """
                    Allows you to undo enhancements introduced in version 2019 R1 of ANSYS Fluent, including:.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/previous_defaults/undo_2019r1_default_changes").execute(*args, **kwargs)
                def undo_2023r2_default_changes(self, *args, **kwargs):
                    """
                    Undo default changes introduced in 2023R2.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/previous_defaults/undo_2023r2_default_changes").execute(*args, **kwargs)
                def undo_r19_point_0_default_changes(self, *args, **kwargs):
                    """
                    Undo default changes introduced in R19.0.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/previous_defaults/undo_r19_point_0_default_changes").execute(*args, **kwargs)
                def undo_2022r1_default_changes(self, *args, **kwargs):
                    """
                    Allows you to undo the following enhancements introduced in version 2022 R1 of ANSYS Fluent:.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/previous_defaults/undo_2022r1_default_changes").execute(*args, **kwargs)
                def undo_2021r1_default_changes(self, *args, **kwargs):
                    """
                    Allows you to undo enhancements introduced in version 2021 R1 of ANSYS Fluent, including:.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/previous_defaults/undo_2021r1_default_changes").execute(*args, **kwargs)

            class multiphase_numerics(TUIMenu):
                """
                Sets multiphase numerics options.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.heat_mass_transfer = self.__class__.heat_mass_transfer(service, version, mode, path + ["heat_mass_transfer"])
                    self.boiling_parameters = self.__class__.boiling_parameters(service, version, mode, path + ["boiling_parameters"])
                    self.compressible_flow = self.__class__.compressible_flow(service, version, mode, path + ["compressible_flow"])
                    self.default_controls = self.__class__.default_controls(service, version, mode, path + ["default_controls"])
                    self.advanced_stability_controls = self.__class__.advanced_stability_controls(service, version, mode, path + ["advanced_stability_controls"])
                    self.face_pressure_controls = self.__class__.face_pressure_controls(service, version, mode, path + ["face_pressure_controls"])
                    self.solution_stabilization = self.__class__.solution_stabilization(service, version, mode, path + ["solution_stabilization"])
                    self.viscous_flow = self.__class__.viscous_flow(service, version, mode, path + ["viscous_flow"])
                    self.porous_media = self.__class__.porous_media(service, version, mode, path + ["porous_media"])
                    super().__init__(service, version, mode, path)
                def stable_vof_settings(self, *args, **kwargs):
                    """
                    Execute Stable VOF settings.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/stable_vof_settings").execute(*args, **kwargs)

                class heat_mass_transfer(TUIMenu):
                    """
                    Enters the menu for the multiphase heat mass transfer parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.boiling = self.__class__.boiling(service, version, mode, path + ["boiling"])
                        self.area_density = self.__class__.area_density(service, version, mode, path + ["area_density"])
                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                        self.evaporation_condensation = self.__class__.evaporation_condensation(service, version, mode, path + ["evaporation_condensation"])
                        super().__init__(service, version, mode, path)
                    def alternative_energy_treatment(self, *args, **kwargs):
                        """
                        Enables the alternative treatment of the energy sources. For more  information, see .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/alternative_energy_treatment").execute(*args, **kwargs)

                    class boiling(TUIMenu):
                        """
                        Enters the menu for the advanced boiling options for the  semi-mechanistic boiling model.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def show_expert_options(self, *args, **kwargs):
                            """
                            Exposes the expert options for the semi-mechanistic boiling model. For more information about these options, see .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/boiling/show_expert_options").execute(*args, **kwargs)
                        def two_resistance_boiling_framework(self, *args, **kwargs):
                            """
                            Enables/disables the two-resistance boiling framework to improve the robustness and accuracy of the solution of cases with multiple boiling mechanisms. For more information about this item, see .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/boiling/two_resistance_boiling_framework").execute(*args, **kwargs)
                        def heat_flux_relaxation_factor(self, *args, **kwargs):
                            """
                            Sets the under-relaxation factor for boiling heat flux. See  for details.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/boiling/heat_flux_relaxation_factor").execute(*args, **kwargs)

                    class area_density(TUIMenu):
                        """
                        Enters the menu for the area density.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def ia_grad_sym(self, *args, **kwargs):
                            """
                            Enables/disables the interfacial area density Gradient-Symmetric model. For more information about this model, see .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/area_density/ia_grad_sym").execute(*args, **kwargs)
                        def vof_min_seeding(self, *args, **kwargs):
                            """
                            Sets the minimum volume fraction for the area density and cavitation. This may be useful, for example, in cases when a species mass transfer model (such as the Symmetric model or Particle model) do not consider evaporation or condensation if the volume fraction of one of the phases is zero. The seeding allows for a phase change to occur in the fluid flow. The default value is 1e-6.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/area_density/vof_min_seeding").execute(*args, **kwargs)

                    class cavitation(TUIMenu):
                        """
                        Enters the cavitation heat mass transfer menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def turbulent_diffusion(self, *args, **kwargs):
                            """
                            Enables/disables the turbulent diffusion treatment for a cavitating turbulent flow. See  for details.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/cavitation/turbulent_diffusion").execute(*args, **kwargs)
                        def schnerr_cond_coeff(self, *args, **kwargs):
                            """
                            Sets the condensation coefficient for the Schnerr-Sauer model (  in ). The default and recommended value of 0.2.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/cavitation/schnerr_cond_coeff").execute(*args, **kwargs)
                        def schnerr_evap_coeff(self, *args, **kwargs):
                            """
                            Sets the evaporation coefficient for the Schnerr-Sauer model (  in ). The default and recommended value of 1.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/cavitation/schnerr_evap_coeff").execute(*args, **kwargs)
                        def min_vapor_pressure(self, *args, **kwargs):
                            """
                            Sets the minimum vapor pressure limit for the cavitation mass-transfer model. The default value is 1 Pa.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/cavitation/min_vapor_pressure").execute(*args, **kwargs)
                        def display_clipped_pressure(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/cavitation/display_clipped_pressure").execute(*args, **kwargs)
                        def max_vapor_pressure_ratio(self, *args, **kwargs):
                            """
                            Sets the maximum limit on the vapor pressure after the turbulence and thermal correction. The default value is five times the vapor pressure, with consideration of turbulent and thermal effects for each cell and phase.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/cavitation/max_vapor_pressure_ratio").execute(*args, **kwargs)

                    class evaporation_condensation(TUIMenu):
                        """
                        Evaporation-condensation advanced options menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def vof_to_min_limit(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/evaporation_condensation/vof_to_min_limit").execute(*args, **kwargs)
                        def vof_to_max_limit(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/evaporation_condensation/vof_to_max_limit").execute(*args, **kwargs)
                        def vof_from_min_limit(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/evaporation_condensation/vof_from_min_limit").execute(*args, **kwargs)
                        def vof_from_max_limit(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/evaporation_condensation/vof_from_max_limit").execute(*args, **kwargs)
                        def ia_norm_min_limit(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/evaporation_condensation/ia_norm_min_limit").execute(*args, **kwargs)
                        def max_rel_humiditiy(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/heat_mass_transfer/evaporation_condensation/max_rel_humiditiy").execute(*args, **kwargs)

                class boiling_parameters(TUIMenu):
                    """
                    Enters the menu for the multiphase boiling model parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def thin_film(self, *args, **kwargs):
                        """
                        When enabled, includes multiphase boiling thin film effects using .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/boiling_parameters/thin_film").execute(*args, **kwargs)
                    def liquid_vof_factor(self, *args, **kwargs):
                        """
                        When enabled, considers liquid volume fraction effects by multiplying the heat transfer coefficients by the local liquid volume fraction.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/boiling_parameters/liquid_vof_factor").execute(*args, **kwargs)

                class compressible_flow(TUIMenu):
                    """
                    Enters the compressible multiphase flow numerics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def enhanced_numerics(self, *args, **kwargs):
                        """
                        Enables an enhanced numerical treatment that provides better  stability at startup and during calculation of compressible  flows.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/compressible_flow/enhanced_numerics").execute(*args, **kwargs)
                    def alternate_bc_formulation(self, *args, **kwargs):
                        """
                        Enables an alternative formulation for compressible phases at an  inlet boundary. This formulation calculates static temperature and  pressure using an iterative method based on fundamental thermodynamic  relations.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/compressible_flow/alternate_bc_formulation").execute(*args, **kwargs)

                class default_controls(TUIMenu):
                    """
                    Enters the default controls menu. This menu is available only for multiphase flows.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def recommended_defaults_for_existing_cases(self, *args, **kwargs):
                        """
                        Applies the multiphase defaults (version 2020 R1) to the loaded case  file.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/default_controls/recommended_defaults_for_existing_cases").execute(*args, **kwargs)
                    def revert_to_pre_r20_point_1_default_settings(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/default_controls/revert_to_pre_r20_point_1_default_settings").execute(*args, **kwargs)

                class advanced_stability_controls(TUIMenu):
                    """
                    Enters the menu for the stability controls for multiphase flows. For more information about the below option, see  and .
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.p_v_coupling = self.__class__.p_v_coupling(service, version, mode, path + ["p_v_coupling"])
                        self.anti_diffusion = self.__class__.anti_diffusion(service, version, mode, path + ["anti_diffusion"])
                        self.pseudo_time = self.__class__.pseudo_time(service, version, mode, path + ["pseudo_time"])
                        self.pseudo_transient = self.__class__.pseudo_transient(service, version, mode, path + ["pseudo_transient"])
                        self.equation_order = self.__class__.equation_order(service, version, mode, path + ["equation_order"])
                        self.num_ventilation = self.__class__.num_ventilation(service, version, mode, path + ["num_ventilation"])
                        self.velocity_limiting = self.__class__.velocity_limiting(service, version, mode, path + ["velocity_limiting"])
                        self.hybrid_nita = self.__class__.hybrid_nita(service, version, mode, path + ["hybrid_nita"])
                        super().__init__(service, version, mode, path)

                    class p_v_coupling(TUIMenu):
                        """
                        Enters the menu for the pressure-velocity coupling controls.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.skewness_correction = self.__class__.skewness_correction(service, version, mode, path + ["skewness_correction"])
                            self.pressure_interpolation = self.__class__.pressure_interpolation(service, version, mode, path + ["pressure_interpolation"])
                            self.coupled_vof = self.__class__.coupled_vof(service, version, mode, path + ["coupled_vof"])
                            self.rhie_chow_flux = self.__class__.rhie_chow_flux(service, version, mode, path + ["rhie_chow_flux"])
                            super().__init__(service, version, mode, path)

                        class skewness_correction(TUIMenu):
                            """
                            Enters the skewness correction menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def limit_pressure_correction_gradient(self, *args, **kwargs):
                                """
                                Enables/disables the limited pressure correction  gradient in skewness terms for the PISO, SIMPLEC, or  fractional step pressure-coupling schemes.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/p_v_coupling/skewness_correction/limit_pressure_correction_gradient").execute(*args, **kwargs)

                        class pressure_interpolation(TUIMenu):
                            """
                            Enters the pressure interpolation menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def modified_bfw_scheme(self, *args, **kwargs):
                                """
                                Enables/disables the modified body force weighted  interpolation scheme. See  for more information about  this option.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/p_v_coupling/pressure_interpolation/modified_bfw_scheme").execute(*args, **kwargs)

                        class coupled_vof(TUIMenu):
                            """
                            Enters the stability control menu for VOF cases that involve the Coupled pressure-velocity coupling scheme.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def buoyancy_force_linearization(self, *args, **kwargs):
                                """
                                Allows you to use the linearized buoyancy force and the  blended treatment for the buoyancy force.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/p_v_coupling/coupled_vof/buoyancy_force_linearization").execute(*args, **kwargs)

                        class rhie_chow_flux(TUIMenu):
                            """
                            Enters the stability controls menu for the Rhie-Chow interpolation.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def low_order_rhie_chow(self, *args, **kwargs):
                                """
                                Enables/disables the low-order velocity interpolation in  the flux calculation.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/p_v_coupling/rhie_chow_flux/low_order_rhie_chow").execute(*args, **kwargs)

                    class anti_diffusion(TUIMenu):
                        """
                        Enters the anti-diffusion menu. This item is available for VOF cases  with the Interfacial Anti-Diffusion option  enabled.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def set_dynamic_strength_exponent(self, *args, **kwargs):
                            """
                            Sets the cosine exponent in the dynamic strength treatment in ).
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/anti_diffusion/set_dynamic_strength_exponent").execute(*args, **kwargs)
                        def set_maximum_dynamic_strength(self, *args, **kwargs):
                            """
                            Sets the maximum value of dynamic anti-diffusion strength in ).
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/anti_diffusion/set_maximum_dynamic_strength").execute(*args, **kwargs)
                        def enable_dynamic_strength(self, *args, **kwargs):
                            """
                            Enables dynamic strength to reduce compression in the direction tangential to the interface.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/anti_diffusion/enable_dynamic_strength").execute(*args, **kwargs)

                    class pseudo_time(TUIMenu):
                        """
                        Pseudo-Time stability controls for multiphase flow.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.auto_dt_advanced_controls = self.__class__.auto_dt_advanced_controls(service, version, mode, path + ["auto_dt_advanced_controls"])
                            super().__init__(service, version, mode, path)
                        def false_time_step_linearization(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_time/false_time_step_linearization").execute(*args, **kwargs)
                        def smoothed_density_stabilization_method(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_time/smoothed_density_stabilization_method").execute(*args, **kwargs)

                        class auto_dt_advanced_controls(TUIMenu):
                            """
                            Set automatic time-stepping controls for better solution stability.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def enable(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/enable").execute(*args, **kwargs)
                            def dt_factor_min(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/dt_factor_min").execute(*args, **kwargs)
                            def dt_factor_max(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/dt_factor_max").execute(*args, **kwargs)
                            def dt_max(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/dt_max").execute(*args, **kwargs)
                            def max_velocity_ratio(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/max_velocity_ratio").execute(*args, **kwargs)
                            def dt_init_limit(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/dt_init_limit").execute(*args, **kwargs)

                    class pseudo_transient(TUIMenu):
                        """
                        Enters the stability control menu for  steady-state multiphase cases with the pseudo time method option  enabled.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.auto_dt_advanced_controls = self.__class__.auto_dt_advanced_controls(service, version, mode, path + ["auto_dt_advanced_controls"])
                            super().__init__(service, version, mode, path)
                        def false_time_step_linearization(self, *args, **kwargs):
                            """
                            When enabled, provides additional stability for buoyancy-driven flows with the pseudo time method option enabled by increasing the diagonal dominance using the false time step size.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_transient/false_time_step_linearization").execute(*args, **kwargs)
                        def smoothed_density_stabilization_method(self, *args, **kwargs):
                            """
                            Smooths the cell density near the interface, therefore avoiding unphysical acceleration of the lighter phase in the vicinity of interface. The default number of density smoothings is 2. In case of very large unphysical velocities across the interface, you can increase this number when prompted with Number of density smoothings.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_transient/smoothed_density_stabilization_method").execute(*args, **kwargs)

                        class auto_dt_advanced_controls(TUIMenu):
                            """
                            Set automatic time-stepping controls for better solution stability.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def enable(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_transient/auto_dt_advanced_controls/enable").execute(*args, **kwargs)
                            def dt_factor_max(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_transient/auto_dt_advanced_controls/dt_factor_max").execute(*args, **kwargs)
                            def dt_factor_min(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_transient/auto_dt_advanced_controls/dt_factor_min").execute(*args, **kwargs)
                            def max_velocity_ratio(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_transient/auto_dt_advanced_controls/max_velocity_ratio").execute(*args, **kwargs)
                            def dt_init_limit(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_transient/auto_dt_advanced_controls/dt_init_limit").execute(*args, **kwargs)
                            def dt_max(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_transient/auto_dt_advanced_controls/dt_max").execute(*args, **kwargs)

                    class equation_order(TUIMenu):
                        """
                        Enters the equation order menu for homogeneous multiphase flow  models.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def solve_exp_vof_at_end(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/equation_order/solve_exp_vof_at_end").execute(*args, **kwargs)
                        def solve_flow_last(self, *args, **kwargs):
                            """
                            When enabled, solves the flow equation at the end of the iteration. This improves the behavior at the start of new time-step if the solution does not converge properly.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/equation_order/solve_flow_last").execute(*args, **kwargs)

                    class num_ventilation(TUIMenu):
                        """
                        Numerical Ventilation Menu for VOF Model.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def tau_estimation_options(self, *args, **kwargs):
                            """
                            Set time step size option for numerical ventilation treatment.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/num_ventilation/tau_estimation_options").execute(*args, **kwargs)
                        def trapped_phase_vof_max(self, *args, **kwargs):
                            """
                            Set trapped phase maximum volume fraction to activate numerical ventilation treatment for non-trapped phases.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/num_ventilation/trapped_phase_vof_max").execute(*args, **kwargs)
                        def trapped_phase_vof_min(self, *args, **kwargs):
                            """
                            Set trapped phase minimum volume fraction to activate numerical ventilation treatment for trapped phase.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/num_ventilation/trapped_phase_vof_min").execute(*args, **kwargs)
                        def enable(self, *args, **kwargs):
                            """
                            Enable numerical ventilation treatment to remove trapped phase adjacent to wall.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/num_ventilation/enable").execute(*args, **kwargs)
                        def near_wall_treatment_options(self, *args, **kwargs):
                            """
                            Set near wall treatment options.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/num_ventilation/near_wall_treatment_options").execute(*args, **kwargs)

                    class velocity_limiting(TUIMenu):
                        """
                        Velocity limiting related stabiity controls for multiphase flow.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def verbosity(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/velocity_limiting/verbosity").execute(*args, **kwargs)
                        def set_velocity_and_vof_cutoffs(self, *args, **kwargs):
                            """
                            Set phase based velocity limiting controls.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/velocity_limiting/set_velocity_and_vof_cutoffs").execute(*args, **kwargs)
                        def set_damping_strength(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/velocity_limiting/set_damping_strength").execute(*args, **kwargs)
                        def set_damping_strengths(self, *args, **kwargs):
                            """
                            Set phase based damping strength.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/velocity_limiting/set_damping_strengths").execute(*args, **kwargs)
                        def set_velocity_cutoff(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/velocity_limiting/set_velocity_cutoff").execute(*args, **kwargs)
                        def enable_velocity_limiting(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/velocity_limiting/enable_velocity_limiting").execute(*args, **kwargs)

                    class hybrid_nita(TUIMenu):
                        """
                        Enters the equation order menu for homogeneous multiphase flow  models.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.instability_detector = self.__class__.instability_detector(service, version, mode, path + ["instability_detector"])
                            super().__init__(service, version, mode, path)
                        def initial_outer_iterations(self, *args, **kwargs):
                            """
                            Allows you to change the number of initial time-steps and the number of initial outer iterations to control solution stability.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/hybrid_nita/initial_outer_iterations").execute(*args, **kwargs)
                        def outer_iterations(self, *args, **kwargs):
                            """
                            Sets the number of outer iterations.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/hybrid_nita/outer_iterations").execute(*args, **kwargs)

                        class instability_detector(TUIMenu):
                            """
                            Enters the menu for the instability detector controls.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def set_cfl_type(self, *args, **kwargs):
                                """
                                Selects the CFL number type for detection of an unstable  event. This command becomes available once the enable-instability-detector? text  option has been enabled.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/set_cfl_type").execute(*args, **kwargs)
                            def set_velocity_limit(self, *args, **kwargs):
                                """
                                Sets the velocity limit for detecting unstable events.  This command becomes available once the enable-instability-detector? text  option has been enabled.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/set_velocity_limit").execute(*args, **kwargs)
                            def enable_instability_detector(self, *args, **kwargs):
                                """
                                Enables/disables the instability detector to deal with  possible instability problems. Once this option is enabled,  additional instability detection options become  available.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/enable_instability_detector").execute(*args, **kwargs)
                            def unstable_event_outer_iterations(self, *args, **kwargs):
                                """
                                Sets the number of outer iterations for an unstable  event.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/unstable_event_outer_iterations").execute(*args, **kwargs)
                            def set_cfl_limit(self, *args, **kwargs):
                                """
                                Sets the Courant number limit for detecting unstable  events. This command becomes available once the enable-instability-detector? text  option has been enabled.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/set_cfl_limit").execute(*args, **kwargs)

                class face_pressure_controls(TUIMenu):
                    """
                    Enter the face pressure expert controls menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def face_pressure_options(self, *args, **kwargs):
                        """
                        Set face pressure options.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/face_pressure_controls/face_pressure_options").execute(*args, **kwargs)

                class solution_stabilization(TUIMenu):
                    """
                    Enters the solution-stabilization numerics menu. This item is available only for the VOF model.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.additional_stabilization_controls = self.__class__.additional_stabilization_controls(service, version, mode, path + ["additional_stabilization_controls"])
                        self.velocity_limiting_treatment = self.__class__.velocity_limiting_treatment(service, version, mode, path + ["velocity_limiting_treatment"])
                        super().__init__(service, version, mode, path)
                    def execute_settings_optimization(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/solution_stabilization/execute_settings_optimization").execute(*args, **kwargs)
                    def execute_additional_stability_controls(self, *args, **kwargs):
                        """
                        When enabled, uses additional controls for improved solution  stability.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/solution_stabilization/execute_additional_stability_controls").execute(*args, **kwargs)
                    def execute_advanced_stabilization(self, *args, **kwargs):
                        """
                        When enabled, modifies solver settings for improved solution  stability.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/solution_stabilization/execute_advanced_stabilization").execute(*args, **kwargs)

                    class additional_stabilization_controls(TUIMenu):
                        """
                        Enters the menu for additional advanced stability controls.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def pseudo_transient_stabilization(self, *args, **kwargs):
                            """
                            Enables/disables the pseudo-transient momentum stabilization and false time step linearization methods.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/solution_stabilization/additional_stabilization_controls/pseudo_transient_stabilization").execute(*args, **kwargs)
                        def pseudo_time_stabilization(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/solution_stabilization/additional_stabilization_controls/pseudo_time_stabilization").execute(*args, **kwargs)
                        def blended_compressive_scheme(self, *args, **kwargs):
                            """
                            Enables/disables the blended compressive discretization scheme.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/solution_stabilization/additional_stabilization_controls/blended_compressive_scheme").execute(*args, **kwargs)

                    class velocity_limiting_treatment(TUIMenu):
                        """
                        Enters the menu for the velocity-limiting-treatment.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def set_damping_strength(self, *args, **kwargs):
                            """
                            .
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_damping_strength").execute(*args, **kwargs)
                        def set_damping_strengths(self, *args, **kwargs):
                            """
                            Set phase based damping strength.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_damping_strengths").execute(*args, **kwargs)
                        def verbosity(self, *args, **kwargs):
                            """
                            When enabled, the solver prints the number of velocity limited cells at each iteration.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/verbosity").execute(*args, **kwargs)
                        def enable_velocity_limiting(self, *args, **kwargs):
                            """
                            Enables/disables the velocity limiting treatment.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/enable_velocity_limiting").execute(*args, **kwargs)
                        def set_velocity_and_vof_cutoffs(self, *args, **kwargs):
                            """
                            Set phase based velocity limiting controls.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_velocity_and_vof_cutoffs").execute(*args, **kwargs)
                        def set_velocity_cutoff(self, *args, **kwargs):
                            """
                            Specifies the maximum velocity magnitude.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_velocity_cutoff").execute(*args, **kwargs)

                class viscous_flow(TUIMenu):
                    """
                    Enters the viscous multiphase flow numerics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def viscosity_averaging(self, *args, **kwargs):
                        """
                        Forces harmonic averaging of cell viscosities to calculate face  viscosity used in momentum equation. This can improve convergence for  highly viscous flow applications (the VOF model only).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/viscous_flow/viscosity_averaging").execute(*args, **kwargs)
                    def turb_visc_based_damping(self, *args, **kwargs):
                        """
                        Turbulence viscosity based damping controls.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/viscous_flow/turb_visc_based_damping").execute(*args, **kwargs)
                    def interfacial_artificial_viscosity(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/viscous_flow/interfacial_artificial_viscosity").execute(*args, **kwargs)

                class porous_media(TUIMenu):
                    """
                    Enters the porous media numerics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def capillary_pressure_as_diffusion(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/porous_media/capillary_pressure_as_diffusion").execute(*args, **kwargs)
                    def relative_permeability(self, *args, **kwargs):
                        """
                        Allows you to fix the saturation (volume fraction) of the phase at  its user-specified residual saturation value.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/multiphase_numerics/porous_media/relative_permeability").execute(*args, **kwargs)

            class slope_limiter_menu(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def type(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/slope_limiter_menu/type").execute(*args, **kwargs)
                def direction(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/slope_limiter_menu/direction").execute(*args, **kwargs)
                def filter(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/slope_limiter_menu/filter").execute(*args, **kwargs)

            class high_order_term_relaxation(TUIMenu):
                """
                Enter High Order Relaxation Menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.options = self.__class__.options(service, version, mode, path + ["options"])
                    super().__init__(service, version, mode, path)
                def enable(self, *args, **kwargs):
                    """
                    Enables/disables High Order Term Relaxation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/set/high_order_term_relaxation/enable").execute(*args, **kwargs)

                class options(TUIMenu):
                    """
                    High Order Term Relaxation Options.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.variables = self.__class__.variables(service, version, mode, path + ["variables"])
                        super().__init__(service, version, mode, path)
                    def type(self, *args, **kwargs):
                        """
                        Enter high order relaxation type.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/high_order_term_relaxation/options/type").execute(*args, **kwargs)
                    def relaxation_factor(self, *args, **kwargs):
                        """
                        Sets the relaxation factor.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/set/high_order_term_relaxation/options/relaxation_factor").execute(*args, **kwargs)

                    class variables(TUIMenu):
                        """
                        Selects the variables.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def select(self, *args, **kwargs):
                            """
                            Select variables for high order term relaxation.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/set/high_order_term_relaxation/options/variables/select").execute(*args, **kwargs)

        class animate(TUIMenu):
            """
            Enters the animation menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.define = self.__class__.define(service, version, mode, path + ["define"])
                self.inverse_dft = self.__class__.inverse_dft(service, version, mode, path + ["inverse_dft"])
                self.objects = self.__class__.objects(service, version, mode, path + ["objects"])
                self.playback = self.__class__.playback(service, version, mode, path + ["playback"])
                self.pulse = self.__class__.pulse(service, version, mode, path + ["pulse"])
                super().__init__(service, version, mode, path)

            class define(TUIMenu):
                """
                Enters the animation definition menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def edit_monitor(self, *args, **kwargs):
                    """
                    Changes animation monitor attributes.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/define/edit_monitor").execute(*args, **kwargs)
                def define_monitor(self, *args, **kwargs):
                    """
                    Defines new animation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/define/define_monitor").execute(*args, **kwargs)

            class inverse_dft(TUIMenu):
                """
                Reconstruct DFT signal.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def run(self, *args, **kwargs):
                    """
                    Make inverse DFT recontruction.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/inverse_dft/run").execute(*args, **kwargs)
                def set(self, *args, **kwargs):
                    """
                    Set reconstruction parameters.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/inverse_dft/set").execute(*args, **kwargs)

            class objects(TUIMenu):
                """
                Enters the object manipulation menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def get_window_id(self, *args, **kwargs):
                    """
                    Get animation object window id.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/objects/get_window_id").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Creates new solution animation object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/objects/create").execute(*args, **kwargs)
                def clear_history(self, *args, **kwargs):
                    """
                    Clears solution animation object history.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/objects/clear_history").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edits solution animation object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/objects/edit").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Deletes solution animation object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/objects/delete").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    Copies solution animation object.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/objects/copy").execute(*args, **kwargs)

            class playback(TUIMenu):
                """
                Enters the animation playback menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.video = self.__class__.video(service, version, mode, path + ["video"])
                    super().__init__(service, version, mode, path)
                def stored_view(self, *args, **kwargs):
                    """
                    Plays the 3D animation sequence using the view stored in the sequence.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/stored_view").execute(*args, **kwargs)
                def play(self, *args, **kwargs):
                    """
                    Plays the selected animation.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/play").execute(*args, **kwargs)
                def write(self, *args, **kwargs):
                    """
                    Writes animation sequence to the file.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/write").execute(*args, **kwargs)
                def read(self, *args, **kwargs):
                    """
                    Reads new animation from file or already defined animations.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/read").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Deletes animation sequence.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/delete").execute(*args, **kwargs)
                def set_custom_frames(self, *args, **kwargs):
                    """
                    Specify a custom start frame, increment, and end frame for video export.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/set_custom_frames").execute(*args, **kwargs)

                class video(TUIMenu):
                    """
                    Enters the video menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.advance_quality = self.__class__.advance_quality(service, version, mode, path + ["advance_quality"])
                        super().__init__(service, version, mode, path)
                    def scale(self, *args, **kwargs):
                        """
                        Expands or collapses the resolution based on this scaling  factor.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/video/scale").execute(*args, **kwargs)
                    def set_standard_resolution(self, *args, **kwargs):
                        """
                        Select from pre-defined resolution list.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/video/set_standard_resolution").execute(*args, **kwargs)
                    def quality(self, *args, **kwargs):
                        """
                        Set quality for exporting video file.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/video/quality").execute(*args, **kwargs)
                    def format(self, *args, **kwargs):
                        """
                        Specifies what format the video file will be written in (MP4 | AVI |  FLV | MOV | MPEG).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/video/format").execute(*args, **kwargs)
                    def fps(self, *args, **kwargs):
                        """
                        Sets the target frames per second (FPS) for the saved video  file.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/video/fps").execute(*args, **kwargs)
                    def width(self, *args, **kwargs):
                        """
                        Set the width for exporting video file.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/video/width").execute(*args, **kwargs)
                    def height(self, *args, **kwargs):
                        """
                        Set the height for exporting video file.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/video/height").execute(*args, **kwargs)
                    def name(self, *args, **kwargs):
                        """
                        Sets the name of the saved video file.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/video/name").execute(*args, **kwargs)
                    def use_original_resolution(self, *args, **kwargs):
                        """
                        Controls whether the resolution of the saved video file matches that  of the images used to create it.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/video/use_original_resolution").execute(*args, **kwargs)

                    class advance_quality(TUIMenu):
                        """
                        Advance Quality setting.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def compression_method(self, *args, **kwargs):
                            """
                            Compression methode for Microsoft AVI movie.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/video/advance_quality/compression_method").execute(*args, **kwargs)
                        def bitrate(self, *args, **kwargs):
                            """
                            Set video bitrate(kbits/sec) for exporting video file.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/video/advance_quality/bitrate").execute(*args, **kwargs)
                        def enable_h264(self, *args, **kwargs):
                            """
                            H264 encoding flag.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/video/advance_quality/enable_h264").execute(*args, **kwargs)
                        def bitrate_scale(self, *args, **kwargs):
                            """
                            Mp4 bitrate scale - Best-64000 High-32000 Medium-16000 Low-8000.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/video/advance_quality/bitrate_scale").execute(*args, **kwargs)
                        def keyframe(self, *args, **kwargs):
                            """
                            Set video keyframe rate for exporting video file.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/playback/video/advance_quality/keyframe").execute(*args, **kwargs)

            class pulse(TUIMenu):
                """
                Enter the pulse animation menu (only available when one or more particle track or pathline graphics objects are defined).
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.hardcopy = self.__class__.hardcopy(service, version, mode, path + ["hardcopy"])
                    self.video = self.__class__.video(service, version, mode, path + ["video"])
                    super().__init__(service, version, mode, path)
                def write(self, *args, **kwargs):
                    """
                    Select a pathline or particle track graphics object, specify whether you want to write a video file or picture files, and enter the destination directory for the files. Continuous pulse animations result in a 5 second video. Single pulse animations run for a full cycle.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/write").execute(*args, **kwargs)
                def pulse_mode(self, *args, **kwargs):
                    """
                    Set whether the pulse is a single pulse or continuous.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/pulse_mode").execute(*args, **kwargs)

                class hardcopy(TUIMenu):
                    """
                    Hardcopy options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.driver = self.__class__.driver(service, version, mode, path + ["driver"])
                        self.color_mode = self.__class__.color_mode(service, version, mode, path + ["color_mode"])
                        super().__init__(service, version, mode, path)
                    def jpeg_hardcopy_quality(self, *args, **kwargs):
                        """
                        To set jpeg hardcopy quality.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/jpeg_hardcopy_quality").execute(*args, **kwargs)
                    def landscape(self, *args, **kwargs):
                        """
                        Plot hardcopies in landscape or portrait orientation.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/landscape").execute(*args, **kwargs)
                    def dpi(self, *args, **kwargs):
                        """
                        Set the DPI for EPS and Postscript files, specifies the resolution in dots per inch (DPI) instead of setting the width and height.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/dpi").execute(*args, **kwargs)
                    def use_window_resolution(self, *args, **kwargs):
                        """
                        Use the currently active window's resolution for hardcopy (ignores the x-resolution and y-resolution in this case).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/use_window_resolution").execute(*args, **kwargs)
                    def set_standard_resolution(self, *args, **kwargs):
                        """
                        Select from pre-defined resolution list.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/set_standard_resolution").execute(*args, **kwargs)
                    def raytracer_image(self, *args, **kwargs):
                        """
                        Enable raytracering rendering.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/raytracer_image").execute(*args, **kwargs)
                    def preview(self, *args, **kwargs):
                        """
                        Display a preview image of a hardcopy.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/preview").execute(*args, **kwargs)
                    def invert_background(self, *args, **kwargs):
                        """
                        Use a white background when the picture is saved.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/invert_background").execute(*args, **kwargs)
                    def y_resolution(self, *args, **kwargs):
                        """
                        Set the height of raster-formatted images in pixels (0 implies current window size).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/y_resolution").execute(*args, **kwargs)
                    def x_resolution(self, *args, **kwargs):
                        """
                        Set the width of raster-formatted images in pixels (0 implies current window size).
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/x_resolution").execute(*args, **kwargs)

                    class driver(TUIMenu):
                        """
                        Enter the set hardcopy driver menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            self.post_format = self.__class__.post_format(service, version, mode, path + ["post_format"])
                            super().__init__(service, version, mode, path)
                        def vrml(self, *args, **kwargs):
                            """
                            Use VRML output for hardcopies.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/vrml").execute(*args, **kwargs)
                        def png(self, *args, **kwargs):
                            """
                            Use PNG output for hardcopies.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/png").execute(*args, **kwargs)
                        def hsf(self, *args, **kwargs):
                            """
                            Use HSF output for hardcopies.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/hsf").execute(*args, **kwargs)
                        def glb(self, *args, **kwargs):
                            """
                            Use GLB output for hardcopies.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/glb").execute(*args, **kwargs)
                        def avz(self, *args, **kwargs):
                            """
                            Use AVZ output for hardcopies.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/avz").execute(*args, **kwargs)
                        def dump_window(self, *args, **kwargs):
                            """
                            Set the command used to dump the graphics window to a file.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/dump_window").execute(*args, **kwargs)
                        def list(self, *args, **kwargs):
                            """
                            List the current hardcopy driver.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/list").execute(*args, **kwargs)
                        def eps(self, *args, **kwargs):
                            """
                            Produce encapsulated PostScript (EPS) output for hardcopies.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/eps").execute(*args, **kwargs)
                        def options(self, *args, **kwargs):
                            """
                            Set the hardcopy options. Available options are:
                            "no gamma correction", disables gamma correction of colors,
                            "physical size = (width,height)", where width and height
                            are the actual measurements of the printable area of the page
                            in centimeters.
                            "subscreen = (left,right,bottom,top)", where left,right,
                            bottom, and top are numbers in [-1,1] describing a subwindow on
                            the page in which to place the hardcopy.
                            The options may be combined by separating them with commas.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/options").execute(*args, **kwargs)
                        def ppm(self, *args, **kwargs):
                            """
                            Produce PPM output for hardcopies.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/ppm").execute(*args, **kwargs)
                        def post_script(self, *args, **kwargs):
                            """
                            Produce PostScript output for hardcopies.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/post_script").execute(*args, **kwargs)
                        def tiff(self, *args, **kwargs):
                            """
                            Use TIFF output for hardcopies.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/tiff").execute(*args, **kwargs)
                        def jpeg(self, *args, **kwargs):
                            """
                            Produce JPEG output for hardcopies.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/jpeg").execute(*args, **kwargs)

                        class post_format(TUIMenu):
                            """
                            Enter the PostScript driver format menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self._service = service
                                self._version = version
                                self._mode = mode
                                self._path = path
                                super().__init__(service, version, mode, path)
                            def raster(self, *args, **kwargs):
                                """
                                Use the original raster format.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/post_format/raster").execute(*args, **kwargs)
                            def fast_raster(self, *args, **kwargs):
                                """
                                Use the new raster format.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/post_format/fast_raster").execute(*args, **kwargs)
                            def rle_raster(self, *args, **kwargs):
                                """
                                Use the run-length encoded raster format.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/post_format/rle_raster").execute(*args, **kwargs)
                            def vector(self, *args, **kwargs):
                                """
                                Use vector format.
                                """
                                return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/driver/post_format/vector").execute(*args, **kwargs)

                    class color_mode(TUIMenu):
                        """
                        Enter the hardcopy color mode menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def list(self, *args, **kwargs):
                            """
                            Display the current hardcopy color mode.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/color_mode/list").execute(*args, **kwargs)
                        def mono_chrome(self, *args, **kwargs):
                            """
                            Convert color to monochrome (black and white) for hardcopy.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/color_mode/mono_chrome").execute(*args, **kwargs)
                        def color(self, *args, **kwargs):
                            """
                            Plot hardcopies in color.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/color_mode/color").execute(*args, **kwargs)
                        def gray_scale(self, *args, **kwargs):
                            """
                            Convert color to grayscale for hardcopy.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/hardcopy/color_mode/gray_scale").execute(*args, **kwargs)

                class video(TUIMenu):
                    """
                    Enter the video window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        self.advance_quality = self.__class__.advance_quality(service, version, mode, path + ["advance_quality"])
                        super().__init__(service, version, mode, path)
                    def use_original_resolution(self, *args, **kwargs):
                        """
                        Enable original resolution.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/video/use_original_resolution").execute(*args, **kwargs)
                    def fps(self, *args, **kwargs):
                        """
                        Set the Frame Per Sec(FPS) for exporting video file.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/video/fps").execute(*args, **kwargs)
                    def format(self, *args, **kwargs):
                        """
                        Set format for exporting video file.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/video/format").execute(*args, **kwargs)
                    def width(self, *args, **kwargs):
                        """
                        Set the width for exporting video file.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/video/width").execute(*args, **kwargs)
                    def quality(self, *args, **kwargs):
                        """
                        Set quality for exporting video file.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/video/quality").execute(*args, **kwargs)
                    def name(self, *args, **kwargs):
                        """
                        Exporting video file name.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/video/name").execute(*args, **kwargs)
                    def scale(self, *args, **kwargs):
                        """
                        Set scale by which video resolution will expand.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/video/scale").execute(*args, **kwargs)
                    def set_standard_resolution(self, *args, **kwargs):
                        """
                        Select from pre-defined resolution list.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/video/set_standard_resolution").execute(*args, **kwargs)
                    def height(self, *args, **kwargs):
                        """
                        Set the height for exporting video file.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/video/height").execute(*args, **kwargs)

                    class advance_quality(TUIMenu):
                        """
                        Advance Quality setting.
                        """
                        def __init__(self, service, version, mode, path):
                            self._service = service
                            self._version = version
                            self._mode = mode
                            self._path = path
                            super().__init__(service, version, mode, path)
                        def keyframe(self, *args, **kwargs):
                            """
                            Set video keyframe rate for exporting video file.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/video/advance_quality/keyframe").execute(*args, **kwargs)
                        def bitrate(self, *args, **kwargs):
                            """
                            Set video bitrate(kbits/sec) for exporting video file.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/video/advance_quality/bitrate").execute(*args, **kwargs)
                        def bitrate_scale(self, *args, **kwargs):
                            """
                            Mp4 bitrate scale - Best-64000 High-32000 Medium-16000 Low-8000.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/video/advance_quality/bitrate_scale").execute(*args, **kwargs)
                        def enable_h264(self, *args, **kwargs):
                            """
                            H264 encoding flag.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/video/advance_quality/enable_h264").execute(*args, **kwargs)
                        def compression_method(self, *args, **kwargs):
                            """
                            Compression methode for Microsoft AVI movie.
                            """
                            return PyMenu(self._service, self._version, self._mode, "/solve/animate/pulse/video/advance_quality/compression_method").execute(*args, **kwargs)

        class initialize(TUIMenu):
            """
            Enters the flow initialization menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.mp_localized_turb_init = self.__class__.mp_localized_turb_init(service, version, mode, path + ["mp_localized_turb_init"])
                self.set_hyb_initialization = self.__class__.set_hyb_initialization(service, version, mode, path + ["set_hyb_initialization"])
                self.compute_defaults = self.__class__.compute_defaults(service, version, mode, path + ["compute_defaults"])
                self.vof_patch_smooth_options = self.__class__.vof_patch_smooth_options(service, version, mode, path + ["vof_patch_smooth_options"])
                self.set_fmg_options = self.__class__.set_fmg_options(service, version, mode, path + ["set_fmg_options"])
                super().__init__(service, version, mode, path)
            def initialize_flow(self, *args, **kwargs):
                """
                Initializes the flow field with the current default values.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/initialize_flow").execute(*args, **kwargs)
            def list_defaults(self, *args, **kwargs):
                """
                Lists default values.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/list_defaults").execute(*args, **kwargs)
            def open_channel_auto_init(self, *args, **kwargs):
                """
                Opens channel automatic initialization.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/open_channel_auto_init").execute(*args, **kwargs)
            def init_turb_vel_fluctuations(self, *args, **kwargs):
                """
                Initializes instantaneous velocity field out of steady state RANS results, for use before enabling a scale resolving simulation such as LES.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/init_turb_vel_fluctuations").execute(*args, **kwargs)
            def init_flow_statistics(self, *args, **kwargs):
                """
                Initializes unsteady statistics.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/init_flow_statistics").execute(*args, **kwargs)
            def set_defaults(self, *args, **kwargs):
                """
                Sets default initial values.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/set_defaults").execute(*args, **kwargs)
            def repair_wall_distance(self, *args, **kwargs):
                """
                Corrects wall distance at very high aspect ratio hexahedral/polyhedral cells.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/repair_wall_distance").execute(*args, **kwargs)
            def fmg_initialization(self, *args, **kwargs):
                """
                Initializes using the full-multigrid initialization (FMG).
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/fmg_initialization").execute(*args, **kwargs)
            def init_instantaneous_vel(self, *args, **kwargs):
                """
                Initialize unsteady velocity.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/init_instantaneous_vel").execute(*args, **kwargs)
            def set_fmg_initialization(self, *args, **kwargs):
                """
                Enters the set full-multigrid for initialization menu. Initial values for each variable can be set within this menu.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/set_fmg_initialization").execute(*args, **kwargs)
            def hyb_initialization(self, *args, **kwargs):
                """
                Initializes using the hybrid initialization method.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/hyb_initialization").execute(*args, **kwargs)
            def init_acoustics_options(self, *args, **kwargs):
                """
                Specifies the number of timesteps for ramping of sound sources and re-initializes the acoustics wave equation solution. For the initialized acoustics solution, Fluent reports the current state of the sound sources ramping.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/init_acoustics_options").execute(*args, **kwargs)
            def reference_frame(self, *args, **kwargs):
                """
                Sets reference frame to absolute or relative.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/reference_frame").execute(*args, **kwargs)
            def dpm_reset(self, *args, **kwargs):
                """
                Resets discrete phase source terms to zero.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/dpm_reset").execute(*args, **kwargs)
            def show_iterations_sampled(self, *args, **kwargs):
                """
                Displays the number of iterations covered by the data sampled for steady statistics.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/show_iterations_sampled").execute(*args, **kwargs)
            def show_time_sampled(self, *args, **kwargs):
                """
                Displays the amount of simulated time covered by the data sampled for unsteady statistics.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/show_time_sampled").execute(*args, **kwargs)
            def lwf_initialization(self, *args, **kwargs):
                """
                Deletes wall film particles and initializes wall film variables to zero. This option is available only with the wall-film DPM boundary condition.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/lwf_initialization").execute(*args, **kwargs)
            def levelset_auto_init(self, *args, **kwargs):
                """
                Levelset function automatic initialization.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/initialize/levelset_auto_init").execute(*args, **kwargs)

            class mp_localized_turb_init(TUIMenu):
                """
                Enters the menu for localized turbulent flow initialization.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def turb_init_parameters(self, *args, **kwargs):
                    """
                    Sets values for the turbulent intensity and turbulent viscosity ratio for localized initialization.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/mp_localized_turb_init/turb_init_parameters").execute(*args, **kwargs)
                def enable(self, *args, **kwargs):
                    """
                    Enables/disables localized initialization of turbulent flow variables.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/mp_localized_turb_init/enable").execute(*args, **kwargs)

            class set_hyb_initialization(TUIMenu):
                """
                Enters the hybrid initialization menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def turbulent_settings(self, *args, **kwargs):
                    """
                    Enter the turbulent settings menu.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/set_hyb_initialization/turbulent_settings").execute(*args, **kwargs)
                def species_settings(self, *args, **kwargs):
                    """
                    Enters the species-settings menu.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/set_hyb_initialization/species_settings").execute(*args, **kwargs)
                def general_settings(self, *args, **kwargs):
                    """
                    Enters the general settings menu.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/set_hyb_initialization/general_settings").execute(*args, **kwargs)

            class compute_defaults(TUIMenu):
                """
                Enters the compute default values menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def all_zones(self, *args, **kwargs):
                    """
                    Initializes the flow field with the default values.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/all_zones").execute(*args, **kwargs)
                def geometry(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/geometry").execute(*args, **kwargs)
                def exhaust_fan(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/exhaust_fan").execute(*args, **kwargs)
                def symmetry(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/symmetry").execute(*args, **kwargs)
                def mass_flow_outlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/mass_flow_outlet").execute(*args, **kwargs)
                def periodic(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/periodic").execute(*args, **kwargs)
                def recirculation_outlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/recirculation_outlet").execute(*args, **kwargs)
                def rans_les_interface(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/rans_les_interface").execute(*args, **kwargs)
                def outlet_vent(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/outlet_vent").execute(*args, **kwargs)
                def network_end(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/network_end").execute(*args, **kwargs)
                def inlet_vent(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/inlet_vent").execute(*args, **kwargs)
                def wall(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/wall").execute(*args, **kwargs)
                def radiator(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/radiator").execute(*args, **kwargs)
                def fluid(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/fluid").execute(*args, **kwargs)
                def interface(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/interface").execute(*args, **kwargs)
                def dummy_entry(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/dummy_entry").execute(*args, **kwargs)
                def degassing(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/degassing").execute(*args, **kwargs)
                def fan(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/fan").execute(*args, **kwargs)
                def recirculation_inlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/recirculation_inlet").execute(*args, **kwargs)
                def porous_jump(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/porous_jump").execute(*args, **kwargs)
                def pressure_far_field(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/pressure_far_field").execute(*args, **kwargs)
                def solid(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/solid").execute(*args, **kwargs)
                def outflow(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/outflow").execute(*args, **kwargs)
                def interior(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/interior").execute(*args, **kwargs)
                def overset(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/overset").execute(*args, **kwargs)
                def velocity_inlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/velocity_inlet").execute(*args, **kwargs)
                def shadow(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/shadow").execute(*args, **kwargs)
                def pressure_outlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/pressure_outlet").execute(*args, **kwargs)
                def mass_flow_inlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/mass_flow_inlet").execute(*args, **kwargs)
                def network(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/network").execute(*args, **kwargs)
                def intake_fan(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/intake_fan").execute(*args, **kwargs)
                def pressure_inlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/pressure_inlet").execute(*args, **kwargs)
                def axis(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/compute_defaults/axis").execute(*args, **kwargs)

            class vof_patch_smooth_options(TUIMenu):
                """
                Enters the vof patch/smooth options menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def set_options(self, *args, **kwargs):
                    """
                    Sets options for patching and smoothing volume fraction.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/vof_patch_smooth_options/set_options").execute(*args, **kwargs)
                def execute_smoothing(self, *args, **kwargs):
                    """
                    Execute volumetric smoothing for volume fraction.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/vof_patch_smooth_options/execute_smoothing").execute(*args, **kwargs)

            class set_fmg_options(TUIMenu):
                """
                Enter the full-multigrid option menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def viscous_terms(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/set_fmg_options/viscous_terms").execute(*args, **kwargs)
                def reset_to_defaults(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/set_fmg_options/reset_to_defaults").execute(*args, **kwargs)
                def set_turbulent_viscosity_ratio(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/set_fmg_options/set_turbulent_viscosity_ratio").execute(*args, **kwargs)
                def species_reactions(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/initialize/set_fmg_options/species_reactions").execute(*args, **kwargs)

        class report_definitions(TUIMenu):
            """
            Enters the report definitions menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def compute(self, *args, **kwargs):
                """
                Computes selected report definition.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_definitions/compute").execute(*args, **kwargs)
            def rename(self, *args, **kwargs):
                """
                Renames a report definition.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_definitions/rename").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                Lists the properties of a report definition.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_definitions/list_properties").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Deletes a report definition.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_definitions/delete").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                Lists all defined report definitions.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_definitions/list").execute(*args, **kwargs)
            def add(self, *args, **kwargs):
                """
                Add a new object.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_definitions/add").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edits a report definition.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_definitions/edit").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Deletes all of the report definition objects.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_definitions/delete_all").execute(*args, **kwargs)
            def convert_monitors_to_report_defns(self, *args, **kwargs):
                """
                Converts all monitors to Report Definitions and create new Report Sets/Plot Sets if required.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_definitions/convert_monitors_to_report_defns").execute(*args, **kwargs)
            def copy(self, *args, **kwargs):
                """
                Creates a copy of a report definition.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/report_definitions/copy").execute(*args, **kwargs)

        class monitors(TUIMenu):
            """
            Sets solution monitors.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
                self.statistic = self.__class__.statistic(service, version, mode, path + ["statistic"])
                self.residual = self.__class__.residual(service, version, mode, path + ["residual"])
                self.force = self.__class__.force(service, version, mode, path + ["force"])
                self.volume = self.__class__.volume(service, version, mode, path + ["volume"])
                self.convergence = self.__class__.convergence(service, version, mode, path + ["convergence"])
                super().__init__(service, version, mode, path)
            def set_average_over(self, *args, **kwargs):
                """
                Set the average over input for monitors.
                """
                return PyMenu(self._service, self._version, self._mode, "/solve/monitors/set_average_over").execute(*args, **kwargs)

            class surface(TUIMenu):
                """
                Enter the surface menu to set integrated scalar quantities on surface(s) monitors.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    self.curves = self.__class__.curves(service, version, mode, path + ["curves"])
                    super().__init__(service, version, mode, path)
                def clear_monitors(self, *args, **kwargs):
                    """
                    Remove all defined surface monitors.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/surface/clear_monitors").execute(*args, **kwargs)
                def list_monitors(self, *args, **kwargs):
                    """
                    List defined surface monitors.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/surface/list_monitors").execute(*args, **kwargs)
                def set_monitor(self, *args, **kwargs):
                    """
                    Define or modify a surface monitor.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/surface/set_monitor").execute(*args, **kwargs)
                def clear_data(self, *args, **kwargs):
                    """
                    Clear current surface monitor data.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/surface/clear_data").execute(*args, **kwargs)

                class curves(TUIMenu):
                    """
                    Enter the curves menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self._service = service
                        self._version = version
                        self._mode = mode
                        self._path = path
                        super().__init__(service, version, mode, path)
                    def lines(self, *args, **kwargs):
                        """
                        Set lines parameters for surface monitors.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/monitors/surface/curves/lines").execute(*args, **kwargs)
                    def markers(self, *args, **kwargs):
                        """
                        Set markers parameters for surface monitors.
                        """
                        return PyMenu(self._service, self._version, self._mode, "/solve/monitors/surface/curves/markers").execute(*args, **kwargs)

            class statistic(TUIMenu):
                """
                Enter the statistic monitors menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def plot(self, *args, **kwargs):
                    """
                    Enable/disable plotting of statistics during iteration.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/statistic/plot").execute(*args, **kwargs)
                def window(self, *args, **kwargs):
                    """
                    Specify first window in which statistics will be plotted during iteration.
                    Multiple statistics are plotted in separate windows, beginning with this one.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/statistic/window").execute(*args, **kwargs)
                def x_axis(self, *args, **kwargs):
                    """
                    Choose what quantity to use on the abscissa in the plot and in the data written to files.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/statistic/x_axis").execute(*args, **kwargs)
                def file_basename(self, *args, **kwargs):
                    """
                    Specify the file basename and extension. The name of the individual monitor will be insterted automatically.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/statistic/file_basename").execute(*args, **kwargs)
                def write(self, *args, **kwargs):
                    """
                    Enable/disable writing of statistics during iteration.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/statistic/write").execute(*args, **kwargs)
                def print(self, *args, **kwargs):
                    """
                    Enable/disable printing of statistics during iteration.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/statistic/print").execute(*args, **kwargs)
                def monitors(self, *args, **kwargs):
                    """
                    Choose which statistics to monitor as printed and/or plotted output.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/statistic/monitors").execute(*args, **kwargs)

            class residual(TUIMenu):
                """
                Enters the residual monitors menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def normalization_factors(self, *args, **kwargs):
                    """
                    Sets normalization factors for currently monitored residuals (if normalize? is set to yes).
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/normalization_factors").execute(*args, **kwargs)
                def print(self, *args, **kwargs):
                    """
                    Chooses whether residuals will be printed during iteration.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/print").execute(*args, **kwargs)
                def n_display(self, *args, **kwargs):
                    """
                    Sets the number of most recent residuals to display in plots.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/n_display").execute(*args, **kwargs)
                def plot(self, *args, **kwargs):
                    """
                    Chooses whether residuals will be plotted during iteration.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/plot").execute(*args, **kwargs)
                def window(self, *args, **kwargs):
                    """
                    Specifies window in which residuals will be plotted during iteration.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/window").execute(*args, **kwargs)
                def convergence_criteria(self, *args, **kwargs):
                    """
                    Sets convergence criteria for residuals that are currently being both monitored and checked.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/convergence_criteria").execute(*args, **kwargs)
                def monitor(self, *args, **kwargs):
                    """
                    Chooses which residuals to monitor as printed and/or plotted output.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/monitor").execute(*args, **kwargs)
                def reset(self, *args, **kwargs):
                    """
                    Chooses whether to delete the residual history and reset iteration counter to 1.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/reset").execute(*args, **kwargs)
                def check_convergence(self, *args, **kwargs):
                    """
                    Chooses which currently monitored residuals should be checked for convergence.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/check_convergence").execute(*args, **kwargs)
                def re_normalize(self, *args, **kwargs):
                    """
                    Re-normalize residuals by maximum values.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/re_normalize").execute(*args, **kwargs)
                def relative_conv_criteria(self, *args, **kwargs):
                    """
                    Sets relative convergence criteria for residuals that are currently being both monitored and checked.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/relative_conv_criteria").execute(*args, **kwargs)
                def criterion_type(self, *args, **kwargs):
                    """
                    Sets convergence criterion type.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/criterion_type").execute(*args, **kwargs)
                def enhanced_continuity_residual(self, *args, **kwargs):
                    """
                    Enables/disables an enhanced formulation for the local scaling of the continuity residuals with the pressure-based solver, so that the absolute mass flow rate at each cell is used. This text command is only available when the computing of the local scale is enabled through the solve/monitors/residual/scale-by-coefficient? text command.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/enhanced_continuity_residual").execute(*args, **kwargs)
                def scale_by_coefficient(self, *args, **kwargs):
                    """
                    Chooses whether to scale residuals by coefficient sum in printed and plotted output.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/scale_by_coefficient").execute(*args, **kwargs)
                def normalize(self, *args, **kwargs):
                    """
                    Chooses whether to normalize residuals in printed and plotted output.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/normalize").execute(*args, **kwargs)
                def n_save(self, *args, **kwargs):
                    """
                    Sets number of residuals to be saved with data. History is automatically compacted when buffer becomes full.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/n_save").execute(*args, **kwargs)
                def n_maximize_norms(self, *args, **kwargs):
                    """
                    Sets the number of iterations through which normalization factors will be maximized.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/residual/n_maximize_norms").execute(*args, **kwargs)

            class force(TUIMenu):
                """
                Enter the force monitors menu.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def set_moment_monitor(self, *args, **kwargs):
                    """
                    Set variables for monitoring the moment coefficient.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/force/set_moment_monitor").execute(*args, **kwargs)
                def delete_monitors(self, *args, **kwargs):
                    """
                    Delete the specified monitor.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/force/delete_monitors").execute(*args, **kwargs)
                def unscaled(self, *args, **kwargs):
                    """
                    Specify whether unscaled values are desired.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/force/unscaled").execute(*args, **kwargs)
                def clear_drag_monitor_data(self, *args, **kwargs):
                    """
                    Clear the drag monitoring data.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/force/clear_drag_monitor_data").execute(*args, **kwargs)
                def lift_coefficient(self, *args, **kwargs):
                    """
                    Set variables for monitoring the lift coefficient.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/force/lift_coefficient").execute(*args, **kwargs)
                def clear_lift_monitor_data(self, *args, **kwargs):
                    """
                    Clear the lift monitoring data.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/force/clear_lift_monitor_data").execute(*args, **kwargs)
                def clear_all_monitors_data(self, *args, **kwargs):
                    """
                    Clear all monitoring data.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/force/clear_all_monitors_data").execute(*args, **kwargs)
                def clear_moment_monitor_data(self, *args, **kwargs):
                    """
                    Clear the moment monitoring data.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/force/clear_moment_monitor_data").execute(*args, **kwargs)
                def moment_coefficient(self, *args, **kwargs):
                    """
                    Set variables for monitoring the moment coefficient.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/force/moment_coefficient").execute(*args, **kwargs)
                def set_drag_monitor(self, *args, **kwargs):
                    """
                    Set variables for monitoring the drag coefficient.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/force/set_drag_monitor").execute(*args, **kwargs)
                def clear_monitors(self, *args, **kwargs):
                    """
                    Clear all or specified monitor data.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/force/clear_monitors").execute(*args, **kwargs)
                def set_lift_monitor(self, *args, **kwargs):
                    """
                    Set variables for monitoring the lift coefficient.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/force/set_lift_monitor").execute(*args, **kwargs)
                def list_monitors(self, *args, **kwargs):
                    """
                    List defined force monitors.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/force/list_monitors").execute(*args, **kwargs)
                def drag_coefficient(self, *args, **kwargs):
                    """
                    Set variables for monitoring the drag coefficient.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/force/drag_coefficient").execute(*args, **kwargs)
                def monitor_unsteady_iters(self, *args, **kwargs):
                    """
                    Specify whether monitors are updated every iteration or every time step for transient calculations.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/force/monitor_unsteady_iters").execute(*args, **kwargs)

            class volume(TUIMenu):
                """
                Enter the volume menu to set integrated scalar quantities on volume(s) monitors.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def clear_monitors(self, *args, **kwargs):
                    """
                    Remove all defined volume monitors.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/volume/clear_monitors").execute(*args, **kwargs)
                def list_monitors(self, *args, **kwargs):
                    """
                    List defined volume monitors.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/volume/list_monitors").execute(*args, **kwargs)
                def clear_data(self, *args, **kwargs):
                    """
                    Clear current volume monitor data.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/volume/clear_data").execute(*args, **kwargs)
                def set_monitor(self, *args, **kwargs):
                    """
                    Define or modify a volume monitor.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/volume/set_monitor").execute(*args, **kwargs)

            class convergence(TUIMenu):
                """
                Enter the convergence menu to add surface, volume, drag, lift and moment monitors to convergence criteria.
                """
                def __init__(self, service, version, mode, path):
                    self._service = service
                    self._version = version
                    self._mode = mode
                    self._path = path
                    super().__init__(service, version, mode, path)
                def frequency(self, *args, **kwargs):
                    """
                    To set how often convergence checks are done with respect to iterations or time steps.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/convergence/frequency").execute(*args, **kwargs)
                def average_over_last_n_iterations_timesteps(self, *args, **kwargs):
                    """
                    Option to average over previous values for checking convergence.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/convergence/average_over_last_n_iterations_timesteps").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete a monitor from convergence criteria.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/convergence/delete").execute(*args, **kwargs)
                def condition(self, *args, **kwargs):
                    """
                    Option to stop the calculations. All convergence conditions are met or any convergence condition is met.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/convergence/condition").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List defined convergence criteria for monitors.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/convergence/list").execute(*args, **kwargs)
                def add_edit(self, *args, **kwargs):
                    """
                    Add or edit convergence criterion for surface, volume, drag, lift and moment monitors.
                    """
                    return PyMenu(self._service, self._version, self._mode, "/solve/monitors/convergence/add_edit").execute(*args, **kwargs)

    class surface(TUIMenu):
        """
        Enter the data surface manipulation menu.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            self.query = self.__class__.query(service, version, mode, path + ["query"])
            self.post_processing_volume = self.__class__.post_processing_volume(service, version, mode, path + ["post_processing_volume"])
            super().__init__(service, version, mode, path)
        def structural_point_surface(self, *args, **kwargs):
            """
            Defines a structural point" surface by specifying the coordinates.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/structural_point_surface").execute(*args, **kwargs)
        def plane_surface(self, *args, **kwargs):
            """
            Create a plane from a coordinate plane, point and normal, or three points.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/plane_surface").execute(*args, **kwargs)
        def closest_point_search(self, *args, **kwargs):
            """
            Enable the point surface algorithm to look for the nearest point instead of reporting a creation failure.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/closest_point_search").execute(*args, **kwargs)
        def mouse_plane(self, *args, **kwargs):
            """
            Extracts a planar surface defined by selecting three points with the mouse.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/mouse_plane").execute(*args, **kwargs)
        def sphere_slice(self, *args, **kwargs):
            """
            Extracts a spherical slice.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/sphere_slice").execute(*args, **kwargs)
        def cone_slice(self, *args, **kwargs):
            """
            Extract a cone slice.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/cone_slice").execute(*args, **kwargs)
        def expression_volume(self, *args, **kwargs):
            """
            Create volume with boolean expression.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/expression_volume").execute(*args, **kwargs)
        def multiple_zone_surfaces(self, *args, **kwargs):
            """
            Creates multiple data surfaces at one time. Accepts zone names, lists of zone IDs, and wildcards.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/multiple_zone_surfaces").execute(*args, **kwargs)
        def reset_zone_surfaces(self, *args, **kwargs):
            """
            Recreates missing surface zones by resetting the case surface list.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/reset_zone_surfaces").execute(*args, **kwargs)
        def ungroup_surface(self, *args, **kwargs):
            """
            Ungroup the surface(if grouped).
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/ungroup_surface").execute(*args, **kwargs)
        def plane_slice(self, *args, **kwargs):
            """
            Extracts a planar slice.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/plane_slice").execute(*args, **kwargs)
        def partition_surface(self, *args, **kwargs):
            """
            Defines a data surface consisting of mesh faces on the partition boundary.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/partition_surface").execute(*args, **kwargs)
        def delete_surface(self, *args, **kwargs):
            """
            Removes a defined data surface.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/delete_surface").execute(*args, **kwargs)
        def list_surfaces(self, *args, **kwargs):
            """
            Displays the ID and name, and the number of point, curve, and surface facets of the current surfaces.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/list_surfaces").execute(*args, **kwargs)
        def iso_clip(self, *args, **kwargs):
            """
            Clips a data surface (surface, curve, or point) between two isovalues.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/iso_clip").execute(*args, **kwargs)
        def zone_surface(self, *args, **kwargs):
            """
            Creates a surface of a designated zone and gives it a specified name.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/zone_surface").execute(*args, **kwargs)
        def multiple_iso_surfaces(self, *args, **kwargs):
            """
            Creates multiple iso-surfaces at once. Accepts zone names, lists of zone IDs, and wildcards.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/multiple_iso_surfaces").execute(*args, **kwargs)
        def ellipsoid_slice(self, *args, **kwargs):
            """
            Extract a ellipsoid slice.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/ellipsoid_slice").execute(*args, **kwargs)
        def rename_surface(self, *args, **kwargs):
            """
            Renames a defined data surface.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/rename_surface").execute(*args, **kwargs)
        def plane(self, *args, **kwargs):
            """
            Create a plane given 3 points bounded by the domain.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/plane").execute(*args, **kwargs)
        def imprint_surface(self, *args, **kwargs):
            """
            Enters the list of surfaces to imprint from and the name of the new imprinted surface.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/imprint_surface").execute(*args, **kwargs)
        def point_array(self, *args, **kwargs):
            """
            Extracts a rectangular array of data points.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/point_array").execute(*args, **kwargs)
        def multiple_plane_surfaces(self, *args, **kwargs):
            """
            Creates multiple planes at once. Accepts zone names, lists of zone IDs, and wildcards.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/multiple_plane_surfaces").execute(*args, **kwargs)
        def transform_surface(self, *args, **kwargs):
            """
            Transforms surface.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/transform_surface").execute(*args, **kwargs)
        def plane_bounded(self, *args, **kwargs):
            """
            Create a bounded surface.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/plane_bounded").execute(*args, **kwargs)
        def rendering_priority(self, *args, **kwargs):
            """
            Define Priority for given surface
            id.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/rendering_priority").execute(*args, **kwargs)
        def rake_surface(self, *args, **kwargs):
            """
            Extracts a rake" surface, given the coordinates of the endpoints.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/rake_surface").execute(*args, **kwargs)
        def edit_surface(self, *args, **kwargs):
            """
            Allows you to edit any of the listed available surfaces.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/edit_surface").execute(*args, **kwargs)
        def circle_slice(self, *args, **kwargs):
            """
            Extracts a circular slice.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/circle_slice").execute(*args, **kwargs)
        def line_slice(self, *args, **kwargs):
            """
            Extracts a linear slice in 2D, given the normal to the line and a distance from the origin.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/line_slice").execute(*args, **kwargs)
        def line_surface(self, *args, **kwargs):
            """
            Defines a line" surface by specifying the two endpoint coordinates.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/line_surface").execute(*args, **kwargs)
        def iso_clip_multiple(self, *args, **kwargs):
            """
            Clip a data surface (surface, curve, or point) between two iso-values.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/iso_clip_multiple").execute(*args, **kwargs)
        def plane_view_plane_align(self, *args, **kwargs):
            """
            Create a plane aligned to a view-plane.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/plane_view_plane_align").execute(*args, **kwargs)
        def mouse_line(self, *args, **kwargs):
            """
            Extracts a line surface that you define by using the mouse to select the endpoints.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/mouse_line").execute(*args, **kwargs)
        def plane_surf_aligned(self, *args, **kwargs):
            """
            Create a plane aligned to a surface.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/plane_surf_aligned").execute(*args, **kwargs)
        def mouse_rake(self, *args, **kwargs):
            """
            Extracts a rake" surface that you define by using the mouse to select the endpoints.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/mouse_rake").execute(*args, **kwargs)
        def point_surface(self, *args, **kwargs):
            """
            Defines a point" surface by specifying the coordinates.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/point_surface").execute(*args, **kwargs)
        def surface_cells(self, *args, **kwargs):
            """
            Extracts all cells intersected by a data surface.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/surface_cells").execute(*args, **kwargs)
        def quadric_slice(self, *args, **kwargs):
            """
            Extracts a quadric slice.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/quadric_slice").execute(*args, **kwargs)
        def plane_point_n_normal(self, *args, **kwargs):
            """
            Create a plane from a point and normal.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/plane_point_n_normal").execute(*args, **kwargs)
        def group_surfaces(self, *args, **kwargs):
            """
            Group a set of surfaces.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/group_surfaces").execute(*args, **kwargs)
        def iso_surface(self, *args, **kwargs):
            """
            Extracts an iso-surface (surface, curve, or point) from the current data field.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/iso_surface").execute(*args, **kwargs)
        def create_imprint_surface(self, *args, **kwargs):
            """
            Imprint surface.
            """
            return PyMenu(self._service, self._version, self._mode, "/surface/create_imprint_surface").execute(*args, **kwargs)

        class query(TUIMenu):
            """
            Enter surface query menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def list_queries(self, *args, **kwargs):
                """
                List all saved queries.
                """
                return PyMenu(self._service, self._version, self._mode, "/surface/query/list_queries").execute(*args, **kwargs)
            def list_named_selection(self, *args, **kwargs):
                """
                List named selection of surface type.
                """
                return PyMenu(self._service, self._version, self._mode, "/surface/query/list_named_selection").execute(*args, **kwargs)
            def named_surface_list(self, *args, **kwargs):
                """
                Create named list of surfaces.
                """
                return PyMenu(self._service, self._version, self._mode, "/surface/query/named_surface_list").execute(*args, **kwargs)
            def list_surfaces(self, *args, **kwargs):
                """
                List surfaces.
                """
                return PyMenu(self._service, self._version, self._mode, "/surface/query/list_surfaces").execute(*args, **kwargs)
            def delete_query(self, *args, **kwargs):
                """
                Delete saved query.
                """
                return PyMenu(self._service, self._version, self._mode, "/surface/query/delete_query").execute(*args, **kwargs)

        class post_processing_volume(TUIMenu):
            """
            Enter post-processing volume menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def create_from_file(self, *args, **kwargs):
                """
                Read post-processing mesh from file.
                """
                return PyMenu(self._service, self._version, self._mode, "/surface/post_processing_volume/create_from_file").execute(*args, **kwargs)
            def create_octree(self, *args, **kwargs):
                """
                Create post-processing octree mesh based on current case.
                """
                return PyMenu(self._service, self._version, self._mode, "/surface/post_processing_volume/create_octree").execute(*args, **kwargs)

    class plot(TUIMenu):
        """
        Enter the XY plot menu.
        """
        def __init__(self, service, version, mode, path):
            self._service = service
            self._version = version
            self._mode = mode
            self._path = path
            self.vrx_sound_analysis = self.__class__.vrx_sound_analysis(service, version, mode, path + ["vrx_sound_analysis"])
            self.cumulative_plot = self.__class__.cumulative_plot(service, version, mode, path + ["cumulative_plot"])
            self.flamelet_curves = self.__class__.flamelet_curves(service, version, mode, path + ["flamelet_curves"])
            self.ansys_sound_analysis = self.__class__.ansys_sound_analysis(service, version, mode, path + ["ansys_sound_analysis"])
            super().__init__(service, version, mode, path)
        def file_list(self, *args, **kwargs):
            """
            Plots data from multiple external files.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/file_list").execute(*args, **kwargs)
        def change_fft_ref_pressure(self, *args, **kwargs):
            """
            Changes reference acoustic pressure.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/change_fft_ref_pressure").execute(*args, **kwargs)
        def plot_direction(self, *args, **kwargs):
            """
            Sets plot direction for XY plot.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/plot_direction").execute(*args, **kwargs)
        def fft_set(self, *args, **kwargs):
            """
            Enter the menu to set histogram plot parameters.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/fft_set").execute(*args, **kwargs)
        def plot(self, *args, **kwargs):
            """
            Plots solution on surfaces.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/plot").execute(*args, **kwargs)
        def file(self, *args, **kwargs):
            """
            Plots data from an external file.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/file").execute(*args, **kwargs)
        def residuals_set(self, *args, **kwargs):
            """
            Sets residual plot parameters. Sub-menu items are the same as file-set/ above.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/residuals_set").execute(*args, **kwargs)
        def datasources(self, *args, **kwargs):
            """
            Enters the menu for creating and modifying plots containing multiple data sources.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/datasources").execute(*args, **kwargs)
        def circum_avg_axial(self, *args, **kwargs):
            """
            Computes iso-axial band surfaces and plots data vs. axial coordinate on them.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/circum_avg_axial").execute(*args, **kwargs)
        def label_alignment(self, *args, **kwargs):
            """
            Set the orientation of XY plot axis labels as either horizontal or axis-aligned.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/label_alignment").execute(*args, **kwargs)
        def histogram_set(self, *args, **kwargs):
            """
            Sets histogram plot parameters. Sub-menu items are the same as file-set/ above.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/histogram_set").execute(*args, **kwargs)
        def display_profile_data(self, *args, **kwargs):
            """
            Plots profile data.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/display_profile_data").execute(*args, **kwargs)
        def circum_avg_radial(self, *args, **kwargs):
            """
            Computes iso-radial band surfaces and plots data vs. radius on them.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/circum_avg_radial").execute(*args, **kwargs)
        def solution_set(self, *args, **kwargs):
            """
            Sets solution plot parameters. Sub-menu items are the same as file-set/ above.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/solution_set").execute(*args, **kwargs)
        def set_boundary_val_off(self, *args, **kwargs):
            """
            Disables the use of boundary face values when node values are disabled in solution XY plots. This option is disabled by default, that is, boundary face values are used when node values are disabled.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/set_boundary_val_off").execute(*args, **kwargs)
        def solution(self, *args, **kwargs):
            """
            Plots solution on surfaces and/or zones. Zone and surface names can be indicated using a  wildcard (\\*).
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/solution").execute(*args, **kwargs)
        def fft(self, *args, **kwargs):
            """
            Plots fast Fourier transform (FFT) of file data. If you respond yes to Acoustic Analysis?, then additional Y axis functions are made available.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/fft").execute(*args, **kwargs)
        def histogram(self, *args, **kwargs):
            """
            Plots a histogram of the specified solution variable using the defined range and number of intervals.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/histogram").execute(*args, **kwargs)
        def file_set(self, *args, **kwargs):
            """
            Sets file plot parameters.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/file_set").execute(*args, **kwargs)
        def residuals(self, *args, **kwargs):
            """
            Contains commands that allow you to select the variables for which you want to display XY plots of residual histories in the active graphics window.
            """
            return PyMenu(self._service, self._version, self._mode, "/plot/residuals").execute(*args, **kwargs)

        class vrx_sound_analysis(TUIMenu):
            """
            Ansys Sound analysis and specification.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def write_files(self, *args, **kwargs):
                """
                Write Ansys Sound out files.
                """
                return PyMenu(self._service, self._version, self._mode, "/plot/vrx_sound_analysis/write_files").execute(*args, **kwargs)
            def print_indicators(self, *args, **kwargs):
                """
                Print Ansys Sound indicators.
                """
                return PyMenu(self._service, self._version, self._mode, "/plot/vrx_sound_analysis/print_indicators").execute(*args, **kwargs)

        class cumulative_plot(TUIMenu):
            """
            Plot the development of force, force coefficient, moment, or moment coefficient across the specified wall zones.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def delete(self, *args, **kwargs):
                """
                Delete an existing cumulative plot object.
                """
                return PyMenu(self._service, self._version, self._mode, "/plot/cumulative_plot/delete").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                Print the names of the existing cumulative plot objects to the console.
                """
                return PyMenu(self._service, self._version, self._mode, "/plot/cumulative_plot/list").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an existing cumulative plot object.
                """
                return PyMenu(self._service, self._version, self._mode, "/plot/cumulative_plot/edit").execute(*args, **kwargs)
            def plot(self, *args, **kwargs):
                """
                Plot a cumulative plot in the graphics window.
                """
                return PyMenu(self._service, self._version, self._mode, "/plot/cumulative_plot/plot").execute(*args, **kwargs)
            def print(self, *args, **kwargs):
                """
                Print the value of a cumulative plot to the console.
                """
                return PyMenu(self._service, self._version, self._mode, "/plot/cumulative_plot/print").execute(*args, **kwargs)
            def write(self, *args, **kwargs):
                """
                Write a cumulative plot to a file.
                """
                return PyMenu(self._service, self._version, self._mode, "/plot/cumulative_plot/write").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                Print the properties of the specified cumulative plot object to the console.
                """
                return PyMenu(self._service, self._version, self._mode, "/plot/cumulative_plot/list_properties").execute(*args, **kwargs)
            def axes(self, *args, **kwargs):
                """
                Set axes options of an object.
                """
                return PyMenu(self._service, self._version, self._mode, "/plot/cumulative_plot/axes").execute(*args, **kwargs)
            def curves(self, *args, **kwargs):
                """
                Set curves options of an object.
                """
                return PyMenu(self._service, self._version, self._mode, "/plot/cumulative_plot/curves").execute(*args, **kwargs)
            def add(self, *args, **kwargs):
                """
                Create a new cumulative plot.
                """
                return PyMenu(self._service, self._version, self._mode, "/plot/cumulative_plot/add").execute(*args, **kwargs)

        class flamelet_curves(TUIMenu):
            """
            Enters the flamelet curves menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def plot_curves(self, *args, **kwargs):
                """
                Plots of a curve property.
                """
                return PyMenu(self._service, self._version, self._mode, "/plot/flamelet_curves/plot_curves").execute(*args, **kwargs)
            def write_to_file(self, *args, **kwargs):
                """
                Writes curve to a file instead of plot.
                """
                return PyMenu(self._service, self._version, self._mode, "/plot/flamelet_curves/write_to_file").execute(*args, **kwargs)

        class ansys_sound_analysis(TUIMenu):
            """
            Enter the Ansys sound analysis menu.
            """
            def __init__(self, service, version, mode, path):
                self._service = service
                self._version = version
                self._mode = mode
                self._path = path
                super().__init__(service, version, mode, path)
            def print_indicators(self, *args, **kwargs):
                """
                Read in a pressure signal or spectrum file, then optionally read in a frequency response function (FRF) or transfer function file, before printing the acoustics indicators.
                """
                return PyMenu(self._service, self._version, self._mode, "/plot/ansys_sound_analysis/print_indicators").execute(*args, **kwargs)
            def write_files(self, *args, **kwargs):
                """
                Read in a pressure signal or spectrum file, then optionally read in a frequency response function (FRF) or transfer function file, before writing a WAV, output pressure, and/or acoustic indicators file.
                """
                return PyMenu(self._service, self._version, self._mode, "/plot/ansys_sound_analysis/write_files").execute(*args, **kwargs)
