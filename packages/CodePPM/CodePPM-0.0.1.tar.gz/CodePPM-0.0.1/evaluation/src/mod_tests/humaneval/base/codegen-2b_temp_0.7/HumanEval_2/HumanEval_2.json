{"name": "HumanEval_2_truncate_number", "language": "py", "prompt": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n", "tests": "def check(candidate):\n    total_tests = 0\n    failed_tests = 0\n\n    try:\n        total_tests += 1\n        assert candidate(3.5) == 0.5\n    except AssertionError:\n        failed_tests += 1\n\n    try:\n        total_tests += 1\n        assert candidate(1.25) == 0.25\n    except AssertionError:\n        failed_tests += 1\n\n    try:\n        total_tests += 1\n        assert candidate(123.0) == 0.0\n    except AssertionError:\n        failed_tests += 1\n    print(total_tests, failed_tests)\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n", "completions": ["    leftover = float(number)\n    integer = 0\n\n    while leftover > 1:\n        integer += 1\n        leftover *= 10\n        leftover = leftover - int(leftover)\n\n    return integer\n\n", "    decimals = number % 1\n    if decimals < 0.5:\n        return int(number)\n    else:\n        return int(number) + 1\n\n", "    return number - int(number)\n\n", "    # return float(int(number)) - number % 1\n    return number - int(number)\n", "    integer, decimal = math.modf(number)\n    return int(integer)\n\n", "    return number - math.floor(number)\n\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n\n", "    if number < 1:\n        return 0\n    elif number == 1:\n        return 0\n    else:\n        return number % 1\n", "    return number - math.floor(number)\n\n", "    if not isinstance(number, float):\n        raise ValueError(\"Only floats are supported\")\n    decimals = number - math.floor(number)\n    return math.floor(number) + decimals\n\n", "    if number == 0:\n        return 0\n    elif number < 0:\n        return truncate_number(-number)\n    elif number > 0:\n        return number // 1\n\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n\n    return decimal_part\n\n", "    n = int(number)\n    d = number - n\n    return d\n\n", "    # Find the largest integer smaller than number.\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n\n", "    return float(number)\n\n", "    # Find the integer part of the number\n    integer_part = int(number)\n    # Find the decimals part of the number\n    decimal_part = number - integer_part\n\n    return decimal_part\n\n", "    if number == 0:\n        return 0\n    n = number * 10\n    i = n // 1\n    n = n - i\n    return float(i) + n\n\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n\n", "    whole_part = math.floor(number)\n    decimal_part = number - whole_part\n    return whole_part, decimal_part\n", "    # The following can be simplified into a single Python expression\n    # (but that is not the answer)\n    #\n    # if number < 0:\n    #     return 0\n    #\n    # i = int(number)\n    # fraction = number - i\n    #\n    # if fraction > 0.5:\n    #     i += 1\n    #     fraction -= 0.5\n    #\n    # return i + fraction\n\n    # However, this is more readable:\n    return number - math.floor(number)\n\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n\n", "    return float(int(number))\n\n", "    # integer part\n    int_part = int(number)\n\n    # leftover part\n    leftover = number - int_part\n\n    # return leftover\n    return leftover\n", "    return number % 1\n\n", "    # Set maximum integer part\n    max_int_part = int(number)\n    # If number is smaller than maximum integer part,\n    # return the integer part, and remove decimal part\n    if number - max_int_part < 1:\n        return max_int_part\n    # Else, return the largest integer part and remaining decimal part\n    else:\n        return max_int_part, number - max_int_part\n", "    whole_part = math.floor(number)\n    decimal_part = number - whole_part\n    return decimal_part\n", "    if not isinstance(number, float):\n        raise ValueError(\"Number must be float\")\n    if number == 0.0:\n        return 0.0\n\n    # we need to find the largest integer smaller than the given number\n    decimals_sum = 0\n    while number > 0:\n        number = number - (number % 1)\n        decimals_sum = decimals_sum + 1\n    return number\n\n", "    # TODO: Implement\n    return number - int(number)\n", "    if number < 1:\n        return 0\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n\n", "    if number == 0:\n        return 0\n\n    integer_part = int(number)\n    decimal_part = number - integer_part\n\n    return integer_part + truncate_number(decimal_part)\n\n", "    if number == 0:\n        return 0.0\n    if number < 0:\n        return 0.0\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n\n", "    int_part, dec_part = math.modf(number)\n    if int_part == 0:\n        return dec_part\n    else:\n        return int(int_part)\n\n", "    return number - math.floor(number)\n\n", "    # if number is less than 1, return it\n    if number < 1:\n        return number\n    # extract integer part and decimal part\n    integer = number - math.floor(number)\n    decimal = number - integer\n    # return decimal part\n    return decimal\n\n", "    n = int(number)\n    d = number - n\n    return n, d\n", "    return number - math.floor(number)\n\n", "    if number < 1:\n        raise ValueError(\"Only positive numbers can be truncated\")\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return integer_part, decimal_part\n\n", "    if not isinstance(number, float) or number < 0:\n        raise ValueError('Only positive numbers are accepted!')\n    if number == 0:\n        return 0.0\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n\n", "    if number < 0:\n        return 0\n    else:\n        integer, decimals = divmod(number, 1)\n        if decimals < 0.5:\n            return integer\n        else:\n            return integer + 1\n\n", "    whole, dec = math.modf(number)\n    return whole\n\n", "    return number - math.floor(number)\n", "    return number % 1\n\n", "    integer_part = int(number)\n    decimals = number - integer_part\n    return decimals\n", "    # This is the largest integer smaller than given number\n    integer_part = int(number)\n    # This is the leftover part\n    decimal_part = number - integer_part\n    return decimal_part\n\n", "    if number < 0:\n        raise ValueError(f\"{number} is not a positive number\")\n    integer, decimal = math.modf(number)\n    return int(integer)\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n", "    integer, decimals = divmod(number, 1)\n    return decimals\n", "    decimal_part = number - math.floor(number)\n    return math.floor(number) + decimal_part\n\n", "    # TODO: Finish this function\n\n", "    return number - int(number)\n\n", "    # your code here\n    if number < 0:\n        raise ValueError(\"Cannot truncate a negative number\")\n\n    return number - math.floor(number)\n\n", "    if number == 0:\n        return 0\n    decimal = number - int(number)\n    if decimal == 0:\n        return int(number)\n    return int(number) + 1 - decimal\n\n", "    n = number\n    decimal_part = n - int(n)\n    return decimal_part\n\n", "    int_part, decimal_part = math.modf(number)\n\n    if int_part == 0.0:\n        return decimal_part\n    else:\n        return int_part\n\n", "    integer_part = math.floor(number)\n    decimal_part = number - integer_part\n    return decimal_part\n", "    if number < 0:\n        number = -number\n    integer = math.floor(number)\n    decimal = number - integer\n    return decimal\n", "    if number < 0:\n        raise ValueError(\"number must be positive\")\n    # TODO: complete the function\n    return number % 1\n\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n    if decimal_part >= 1:\n        return integer_part + 1\n    return integer_part\n\n", "    return number - int(number)\n\n", "    int_part = int(number)\n    decimal_part = number - int_part\n\n    return decimal_part\n\n", "    assert number > 0, \"Error, number should be positive.\"\n    if int(number) == number:\n        return 0\n    else:\n        return int(number)\n\n", "    return number - math.floor(number)\n\n", "    integer_part = int(number)\n    decimals = number - integer_part\n    return decimals\n\n", "    integer, decimals = math.modf(number)\n    integer = int(integer)\n    return decimals if decimals else integer\n\n", "    if number < 0:\n        raise ValueError(\"Can't truncate negative numbers\")\n    if number == 0:\n        return 0\n    decimal_part = number - int(number)\n    return decimal_part\n", "    # Split the number into integer and decimals\n    integer, decimals = math.modf(number)\n    # Handle case where integer is negative\n    if integer < 0:\n        integer = -integer\n        decimals = -decimals\n    # Return integer part\n    return integer\n", "    sign = 1 if number >= 0 else -1\n    number = abs(number)\n    if number < 0.5:\n        return 0\n    elif number < 1:\n        return number\n    else:\n        quotient, remainder = divmod(number, 1)\n        return truncate_number(quotient) + sign * remainder\n", "    # you may also try to use float(str(number)).is_integer()\n    return int(number)\n\n", "    # some hints\n    # return the float number if it is already smaller than 1\n    if number < 1:\n        return number\n\n    # get the integer part\n    integer = int(number)\n\n    # compute the decimal part\n    decimal = number - integer\n    return decimal\n\n", "    integer = int(number)\n    fraction = number - integer\n    return fraction\n\n", "    if number == 0:\n        return 0\n    else:\n        integer_part = int(number)\n        decimal_part = number - integer_part\n        if decimal_part >= 1:\n            return float(integer_part) + float(decimal_part)\n        else:\n            return float(integer_part)\n\n", "    # YOUR CODE HERE\n    return number - math.floor(number)\n\n", "    if number < 0:\n        raise ValueError(\"Cannot truncate negative number\")\n\n    if number == 0:\n        return 0.0\n\n    if number == 1:\n        return 0.0\n\n    max_int = int(number)\n    remainder = number - max_int\n\n    if remainder == 0:\n        return max_int\n\n    return max_int + 1.0\n\n", "    if number < 0:\n        raise ValueError(\"Truncate a non-negative number\")\n    integer, decimals = math.modf(number)\n    return decimals\n\n", "    integer = int(number)\n    decimal = number - integer\n    return decimal\n\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n    if decimal_part < 0.5:\n        return integer_part\n    else:\n        return integer_part + 1\n", "    whole_number = int(number)\n    decimal_part = number - whole_number\n\n    return decimal_part\n\n", "    whole_number = int(number)\n    decimal_number = number - whole_number\n\n    return decimal_number\n\n", "    if number == 0:\n        return 0\n    if number < 1:\n        raise ValueError(f\"{number} is not a positive number.\")\n    integer_part, decimals = math.modf(number)\n    return decimals\n\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n\n", "    return number - math.floor(number)\n\n", "    decimal = number - math.floor(number)\n    return decimal\n\n", "    n = abs(number)\n    d = n - int(n)\n\n    if n - int(n) < 0.5:\n        return int(n)\n    else:\n        return int(n) + 1 - d\n\n", "    int_part = math.floor(number)\n    decimal_part = number - int_part\n    return decimal_part\n", "    if number < 0:\n        raise ValueError(f\"number should be positive, but got {number}\")\n    integer_part = int(number)\n    decimal_part = number - integer_part\n\n    return decimal_part\n\n", "    integer, leftover = math.modf(number)\n    return int(integer)\n", "    if number >= 0:\n        return int(number)\n    else:\n        return -int(number)\n", "    # TODO: YOUR CODE HERE\n    if isinstance(number, float):\n        number = int(number)\n\n    if number < 1:\n        return 0\n\n    integer = number // 1\n    decimal = number - integer\n\n    return decimal\n\n", "    # Simplify:\n    if number == 0:\n        return 0.0\n\n    # Find largest integer smaller than number:\n    max_int = int(number)\n\n    # Find the largest integer smaller than number,\n    # and subtract it from number to get the rest:\n    max_int_minus_number = max_int - number\n\n    # If max_int_minus_number is negative,\n    # max_int is not smaller than number.\n    if max_int_minus_number < 0:\n        return number\n\n    # Return the remainder of max_int_minus_number / 10.\n    return max_int_minus_number / 10.0\n", "    number = float(number)\n    if number == int(number):\n        number = int(number)\n    return number - int(number)\n\n", "    if number < 1:\n        return 0\n    else:\n        integer, decimals = math.modf(number)\n        integer = int(integer)\n        return decimal_to_truncate(decimals)\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n\n", "    # Decimals are represented as a float of magnitude less than 1,\n    # so it's safe to just take the integer part of the number.\n    return float(int(number))\n\n", "    if number < 0:\n        return number\n    else:\n        integer_part = int(number)\n        decimal_part = number - integer_part\n        if decimal_part == 0.0:\n            return integer_part\n        else:\n            return integer_part + 1\n\n", "    # How many decimal places to round to?\n    # How many digits should we keep after the decimal point?\n    decimal_places = int(math.floor(math.log10(number)))\n    digits = decimal_places + 1\n    # How many digits to the left of the decimal point?\n    left_digits = digits - decimal_places\n    # Integer part\n    integer = int(number)\n    # Decimal part\n    decimal = number - integer\n    # Rounding up\n    decimal = math.ceil(decimal * 10 ** decimal_places) / 10 ** decimal_places\n    # Remove leading 0s\n    while decimal_places > 0 and decimal == 0:\n        decimal_places -= 1\n        decimal = int(number) - integer\n        integer = int(number)\n    # Remove trailing 0s\n    while decimal_places > 0 and decimal == 0:\n        integer -= 1\n        decimal = int(number) - integer\n        number = int(number)\n    # Left pad the integer part\n    integer_string = str(integer)\n    if len(integer_string) < left_digits:\n        integer_string = (left_digits - len(integer_string)) * '0' + integer_string\n    integer = integer_string\n    # Left pad the decimal part\n    decimal_string = str(decimal)\n    if len(decimal_string) < decimal_places:\n        decimal_string = (decimal_places - len(decimal_string)) * '0' + decimal_string\n    decimal = decimal_string\n    return decimal\n\n", "    integer_part, decimals = math.modf(number)\n    if decimals == 0:\n        return integer_part\n    else:\n        return integer_part + decimals\n\n", "    # get the absolute value of the number\n    abs_num = abs(number)\n\n    # get the largest integer smaller than the number\n    int_part = int(abs_num)\n\n    # get the leftover part\n    leftover = abs_num - int_part\n\n    return leftover\n\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n\n    return decimal_part\n\n", "    if number < 0:\n        raise ValueError(\"Number should be positive\")\n\n    # Find the largest integer smaller than the given number\n    integer_part = int(math.floor(number))\n\n    # Find the decimal part\n    decimal_part = number - integer_part\n    return decimal_part\n", "    decimals = int(number % 1 * 10)\n    return number - decimals\n\n", "    if number == int(number):\n        return int(number)\n    if number > 0:\n        integer_part = number // 1\n        decimal_part = number - integer_part * 1\n    elif number < 0:\n        integer_part = -number // 1\n        decimal_part = number - integer_part * 1\n    return decimal_part\n\n", "    if number == 0:\n        return 0.0\n\n    decimal_part = number - math.floor(number)\n\n    return decimal_part\n\n", "    if number == 0.0:\n        return 0.0\n    if number < 0.0:\n        raise ValueError('Number should be positive')\n\n    decimals = math.floor(math.log10(number))\n    return number - math.pow(10, decimals)\n", "    return number % 1\n", "    # I have no idea if the while loop below is necessary\n    # but if it is removed, the test will fail.\n    if number < 0:\n        raise ValueError(\"truncate_number: number must be positive\")\n    decimal_part = 0\n    while number > 1:\n        number /= 10\n        decimal_part += 1\n    return decimal_part\n\n", "    if number < 1:\n        return number\n    whole_number = int(number)\n    decimal_part = number - whole_number\n    return whole_number + decimal_part\n", "    assert isinstance(number, float)\n    assert number >= 0\n\n    int_part = int(number)\n    decimal_part = number - int_part\n\n    return decimal_part\n", "    return number - math.floor(number)\n\n", "    assert number > 0\n    # Handle the case when number is zero.\n    if number == 0:\n        return 0\n    # Find the integer part of the number.\n    integer_part = number // 1\n    # Find the leftmost non-zero decimal part.\n    decimal_part = number - integer_part * 1\n    return integer_part + decimal_part / 10 ** len(str(decimal_part))\n\n", "    integer, decimals = divmod(number, 1)\n    return decimals\n\n", "    if number == 0:\n        return 0\n    if number < 0:\n        return -truncate_number(-number)\n    # Find largest integer smaller than number\n    positive_integer = int(number)\n    while positive_integer < number:\n        positive_integer *= 2\n    decimals = number - positive_integer\n    return positive_integer + decimals\n\n", "    if number == 0:\n        return 0\n    # find the largest integer smaller than given number\n    integer_part = int(number)\n    # find the largest integer smaller than given number\n    decimal_part = number - integer_part\n    return decimal_part\n\n", "    return round(number, -int(math.floor(math.log10(abs(number))) + 1))\n", "    if number < 0:\n        raise ValueError(\"number must be positive\")\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n", "    if number < 1:\n        return 0\n    else:\n        n = int(number)\n        return number - n\n", "    return number - int(number)\n\n", "    if number < 0:\n        raise ValueError('number must be positive')\n    else:\n        integer, decimal = math.modf(number)\n        if decimal < 1:\n            return integer\n        else:\n            return truncate_number(integer)\n", "    integer, decimals = math.modf(number)\n    return int(integer) + decimals\n", "    return number - int(number)\n\n", "    return number - int(number)\n\n", "    integer_part, decimals = math.modf(number)\n    integer_part = int(integer_part)\n    return decimals\n", "    number = float(number)\n\n    # Find largest integer smaller than given number\n    int_part = int(number)\n    while int_part < number:\n        int_part += 1\n\n    return number - int_part\n\n", "    return int(number)\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n", "    if number == 0:\n        return 0\n    if number > 0:\n        integer_part = math.floor(number)\n        decimals = number - integer_part\n    else:\n        integer_part = -math.floor(-number)\n        decimals = number + integer_part\n    return decimals\n\n", "    return Decimal(number).quantize(1)\n\n", "    # Truncate towards zero\n    largest_int = int(number)\n    remainder = number - largest_int\n\n    return largest_int + (remainder * 1 / 10 ** len(str(number)))\n", "    integer = int(number)\n    decimal = number - integer\n    return decimal\n", "    # todo: complete this function\n    # 1. The integer part is the largest integer smaller than the number\n    integer_part = int(number)\n    # 2. The decimal part is the leftover part\n    decimal_part = number - integer_part\n\n    return decimal_part\n", "    if number < 1:\n        return number\n    integer_part, decimal_part = math.modf(number)\n    integer_part = int(integer_part)\n    return integer_part + decimal_part\n", "    if number == 0:\n        return 0\n    if number < 0:\n        number = -number\n    if number % 1 == 0:\n        return int(number)\n    else:\n        return int(number) + 1\n\n", "    assert number > 0, 'Only positive numbers are supported'\n\n    integer_part = int(number)\n    decimal_part = number - integer_part\n\n    if decimal_part == 0:\n        return integer_part\n    return integer_part + 1\n", "    whole_part = int(number)\n    decimal_part = number - whole_part\n\n    if decimal_part < 1:\n        return whole_part\n\n    return whole_part + 1\n", "    #...\n", "    if number == 0:\n        return 0\n    elif number < 0:\n        return -truncate_number(-number)\n    else:\n        integer_part, decimals = math.modf(number)\n        return int(integer_part)\n\n", "    integer = int(number)\n    decimal = number - integer\n    return decimal\n\n", "    # If the number is not positive, return it as is\n    if number <= 0:\n        return number\n    # Remove the integer part\n    integer_part = int(number)\n    # If there are no decimals, return the integer part\n    if number - integer_part < 1:\n        return integer_part\n    # If there are decimals, calculate the ratio\n    decimals = number - integer_part\n    return integer_part + decimals\n", "    if number < 1:\n        raise ValueError(\"number should be positive\")\n\n    return int(number)\n\n", "    integer, leftover = divmod(number, 1)\n    return leftover\n\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n\n", "    return number - math.floor(number)\n\n", "    if number < 0:\n        raise ValueError(\"Number must be positive\")\n    if number == 0:\n        return 0\n    sign = 1 if number >= 0 else -1\n    number *= sign\n    factor = 1\n    while number > factor:\n        factor *= 10\n    factor //= 10\n    return sign * number / factor\n\n", "    if number < 0:\n        raise ValueError('number should be a positive number')\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n\n", "    return number - int(number)\n\n", "    # integer part of the number\n    integer_part = int(number)\n\n    # remainder of the number\n    remainder = number - integer_part\n\n    return integer_part + remainder\n\n", "    number = Decimal(number)\n    i = number.to_integral_value(rounding=ROUND_HALF_UP)\n    return i - number\n", "    # We get the integer part first:\n    integer_part = int(number)\n\n    # We get the largest integer smaller than number:\n    if number - integer_part > 1:\n        integer_part += 1\n        \n    # We get the decimal part:\n    decimal_part = number - integer_part\n\n    # We return the integer part:\n    return integer_part\n", "    n = number\n    # find the integer part\n    # this is the only way to get the integer part of the float (i.e. not just\n    # get the integer part of the int)\n    # use numpy?\n    # e.g. np.floor(n)\n    while n - int(n) > 1:\n        n = n - int(n)\n    return n\n\n", "    return number - int(number)\n\n", "    if number == 0:\n        return 0\n    i = int(number)\n    f = number - i\n    return i + truncate_number(f)\n", "    a = float(number)\n    if a < 1:\n        return a\n    else:\n        return truncate_number(a - a % 1)\n\n", "    int_part = int(number)\n    decimals = number - int_part\n    return decimals\n", "    n = math.floor(number)\n    d = math.fmod(number - n, 1)\n    return n, d\n\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n\n", "    # Python's round() function can round a number to a given number of\n    # decimal places, e.g. round(3.5, 2) == 3.56\n    # round() returns the smallest integer that is greater than or equal to\n    # the given float\n    # round(x, y) -> integer\n    return float(round(number, 2))\n\n", "    if number == 0:\n        return 0\n    if number == 1:\n        return 1\n    if number < 1:\n        raise ValueError\n    integer_part, decimal_part = divmod(number, 1)\n    return truncate_number(integer_part) + truncate_number(decimal_part)\n\n", "    integer_part = int(number)\n    decimals = number - integer_part\n    return decimals\n", "    integer, decimal = divmod(number, 1)\n    return int(integer)\n\n", "    # Find largest integer smaller than given number\n    positive_integer = number // 1\n    while True:\n        positive_integer -= 1\n        if positive_integer * 1 < number:\n            break\n    # Decompose number into integer part and decimals\n    integer_part = positive_integer\n    decimal_part = number - integer_part\n    return integer_part, decimal_part\n", "    if number == 0:\n        return 0\n    else:\n        return number - math.floor(number)\n\n", "    integer, decimals = integer_part(number)\n    return decimals\n", "    integer, decimals = math.modf(number)\n    return int(integer)\n", "    int_part = int(number)\n    decimal_part = number - int_part\n    return decimal_part\n", "    return round(number - math.floor(number), 2)\n", "    integer, decimal = math.modf(number)\n    return decimal\n\n", "    if number < 0:\n        raise ValueError(\"number < 0\")\n    if number == 0:\n        return 0\n    integer, decimals = math.modf(number)\n    return decimals\n\n", "    integer, decimals = math.modf(number)\n    integer = int(integer)\n    if decimals == 0:\n        return integer\n    elif decimals < 0:\n        return truncate_number(integer - 1)\n    elif decimals > 0:\n        return truncate_number(integer + 1)\n\n", "    # Decimals are always non-negative.\n    # Dividing by zero raises ZeroDivisionError.\n    return number - int(number)\n\n", "    if number < 1:\n        return number\n\n    integer_part, decimals = integer_part_and_decimals(number)\n    return truncate_number(decimals) + integer_part\n\n", "    decimal_part = number - int(number)\n\n    return decimal_part\n\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n\n", "    # Decimal part\n    decimal_part = abs(number - int(number))\n    # Integer part\n    integer_part = int(number)\n    # Truncate integer part\n    integer_part = integer_part if integer_part > 0 else 0\n    # Return the decimal part\n    return decimal_part + integer_part\n", "    if number < 1:\n        return 0\n    leftover = number\n    integer = 0\n    while leftover >= 1:\n        integer += 1\n        leftover = leftover - 1\n    return integer\n\n", "    integer, decimals = get_integer_and_decimals(number)\n    return decimals\n\n", "    if number == int(number):\n        return int(number)\n    else:\n        return number - int(number)\n\n", "    integer, decimal = math.modf(number)\n    return float(integer)\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n", "    a = int(number)\n    b = number - a\n    return b\n\n", "    integer_part = math.floor(number)\n    decimal_part = number - integer_part\n\n    return decimal_part\n\n", "    integer, remainder = divmod(number, 1)\n    return integer\n", "    # TODO: complete this function\n    integer, decimals = math.modf(number)\n    return int(integer)\n\n", "    integer, leftover = divmod(number, 1)\n    return integer\n\n", "    if number < 1:\n        return number\n    integer, decimal = math.modf(number)\n    return truncate_number(integer) + (decimal / 10)\n\n", "    integer = int(number)\n    decimal = number - integer\n    return decimal\n\n", "    if number == 0:\n        return 0\n    else:\n        return number - math.floor(number)\n\n", "    return math.modf(number)[1]\n\n", "    whole, decimals = math.modf(number)\n    return whole\n", "    if number < 1:\n        return 0\n    else:\n        decimal = math.modf(number)[0]\n        integer = math.floor(number)\n        return decimal\n", "    integer = math.floor(number)\n    decimal = number - integer\n    return decimal\n\n", "    i, d = math.modf(number)\n    return d\n\n", "    if number >= 1:\n        integer_part = int(number)\n        decimal_part = number - integer_part\n        return decimal_part\n    else:\n        return number\n\n", "    whole, decimal = math.modf(number)\n    whole = int(whole)\n    return decimal if decimal >= 0.5 else whole\n\n", "    return int(number)\n\n", "    if number < 0:\n        raise ValueError('Number must be positive')\n    if number == 0:\n        return 0\n    else:\n        whole_number = int(number)\n        decimals = number - whole_number\n\n        if whole_number == 0:\n            return decimals\n        else:\n            return whole_number\n\n", "    int_part = int(number)\n    decimal_part = number - int_part\n    return decimal_part\n", "    assert number >= 0, 'Number should be positive'\n    integer, leftover = divmod(number, 1)\n    return integer\n\n", "    return number - int(number)\n\n", "    integer, decimals = divmod(number, 1)\n    return int(integer) if integer == number else float(decimals)\n\n", "    integer_part = int(number)\n    decimals = number - integer_part\n\n    if decimals == 0:\n        return integer_part\n\n    return decimals\n\n"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"]}