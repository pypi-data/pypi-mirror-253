from __future__ import annotations
from typing import Iterable, Iterator, Type, cast
from numlib.utils import xgcd

class ZModPMeta(type, Iterable['ZModP']):
    order: tuple[int, int]
    @classmethod
    def __iter__(cls, units_: bool = False) -> Iterator['ZModP']: ...
    @classmethod
    def units(cls) -> Iterator['ZModP']: ...
    @classmethod
    def __str__(cls) -> str: ...
    @classmethod
    def __repr__(cls) -> str: ...
    #@classmethod
    #def indet(cls, indet: str) -> FPolynomial['ZModP']: ...

class ZModP(int, metaclass=ZModPMeta):
    def __add__(self, other: int|'ZModP') -> 'ZModP': ...
    def __radd__(self, other: int) -> 'ZModP': ...
    def __sub__(self, other: int|'ZModP') -> 'ZModP': ...
    def __rsub__(self, other: int) -> 'ZModP': ...
    def __neg__(self) -> 'ZModP': ...
    def __mul__(self, other: int|'ZModP') -> 'ZModP': ...
    def __rmul__(self, other: int) -> 'ZModP': ...
    def __pow__(self, m: int) -> 'ZModP': ... # type: ignore[override]
    def __truediv__(self, other: int|'ZModP') -> 'ZModP': ...
    def __rtruediv__(self, other: int) -> 'ZModP': ... # type: ignore[misc]
    def isunit(self) -> bool: ...

def Zmodp(p: int, mp: bool =False, negatives: bool =True) -> Type[ZModP]:
    """Quotient the integers by the principal ideal generated by n.

    This returns a class that can be used to work in the ring of int-
    egers modulo the prime p: instances of the returned class are
    elements of the ring, Z/p.

    Args:

        p (int): a prime defining the ideal ideal by which we quotient.

        mp (bool): whether to use multiprecision integers (requires the
            gmpy2 module).

        negatives (bool): whether to balance representations by using
            negative numbers; i.e., -1 instead of n-1, etc.

    Returns:

        (type). A class, instances of which represent the equivalence
            classes of integers modulo the ideal <n>.

    Examples (see also the examples for Zmod):

        >>> F = Zmodp(43, negatives=False)  # the integers modulo 43
        >>> print(F)
        Z/43

        Let us find a generator of the multiplicative group of units:

        >>> def order(x):
        ...     for j in range(1, 43):
        ...         if x**j == 1:
        ...             return j
        >>> for x in F:
        ...     if order(x) == 42:
        ...         print(x, "is a generator")
        ...         break
        3 is a generator
    """
    class ZModPMeta_(ZModPMeta):

        order = (p, 1)

        @classmethod
        def __iter__(cls, units_: bool = False) -> Iterator['ZModP']:
            for i in (
                range(-((p - 1) // 2), p - ((p - 1) // 2)) if negatives else range(p)
            ):
                if i == 0 and units_:
                    continue
                yield ZModP_(i)

        @classmethod
        def units(cls) -> Iterator['ZModP']:  # NOTE: REMOVE THIS?
            if p == 1:
                return iter([])
            else:
                return cls.__iter__(units_=True) # type: ignore[call-arg]

        @classmethod
        def __str__(cls) -> str:
            return f"Z/{p}"

        @classmethod
        def __repr__(cls) -> str:
            return f"Z/{p}"

        #@classmethod
        #def indet(cls, indet: str = 'x-') -> FPolynomial['ZModP']:
        #    return FPolynomial([ZModP_(0), ZModP_(1)], x=indet)

    class ZModP_(ZModP, metaclass=ZModPMeta_):
        if negatives:
           def __new__(cls: type, value: int) -> 'ZModP_':
               half = -((p - 1) // 2)
               if value < half or value > -half + (p + 1) % 2:
                   value = value % p
                   if value >= p // 2 + 1:
                       value = value - p
               #return super(Z_Mod_, cls).__new__(cls, value)
               return cast(ZModP_, ZModP.__new__(cls, value))
        else:
           def __new__(cls: type, value: int) -> 'ZModP_':
               if value < 0 or value >= p:
                   value = value % p

               #return super(Z_Mod_, cls).__new__(cls, value)
               return cast(ZModP_, ZModP.__new__(cls, value))

        def __add__(self, other: int|'ZModP_') -> 'ZModP_':
            return ZModP_(super(ZModP, self).__add__(other))

        def __radd__(self, other: int) -> 'ZModP_':
            return ZModP_(super(ZModP, self).__radd__(other))

        def __neg__(self) -> 'ZModP_':
            return ZModP_(super(ZModP, self).__neg__())

        def __sub__(self, other: int|'ZModP_') -> 'ZModP_':
            return ZModP_(super(ZModP, self).__sub__(other))

        def __rsub__(self, other: int) -> 'ZModP_':
            return ZModP_(super(ZModP, self).__rsub__(other))

        def __mul__(self, other: int|'ZModP_') -> 'ZModP_':
            return ZModP_(super(ZModP, self).__mul__(other))

        def __rmul__(self, other: int) -> 'ZModP_':
            return ZModP_(super(ZModP, self).__rmul__(other))

        def __truediv__(self, other: int|'ZModP_') -> 'ZModP_':
            assert other != 0, "Cannot divide by zero."
            g, inv, _ = xgcd(int(other), p)
            return ZModP_(super(ZModP, self).__mul__(inv * g))

        def __rtruediv__(self, other: int) -> 'ZModP_': # type: ignore[misc]
            assert self != 0, "Cannot divide by zero."
            return ZModP_(other).__truediv__(self)

        def __pow__(self, m: int) -> None|'ZModP_': # type: ignore[override]
            if m > 0:
                return ZModP_(pow(int(self), m, p))
            elif m < 0:
                return ZModP_(1)/ZModP_(pow(int(self), -m, p))
            else:
                return ZModP_(1)

        def __eq__(self, other: int|'ZModP_') -> bool: # type: ignore[override]
            return (int(self) - int(other)) % p == 0

        def __ne__(self, other: int|'ZModP_') -> bool: # type: ignore[override]
            return (int(self) - int(other)) % p != 0

        def __hash__(self) -> int:
            return hash((int(self), p))

        def __repr__(self) -> str:
            return f"{super().__repr__()} + <{p}>"

        def __str__(self) -> str:
            return super().__repr__()  # for Python 3.9

        def isunit(self) -> bool:
            return self != 0

    ZModP_.__name__ = f"Z/{p}"

    return ZModP_

if __name__ == '__main__':
    F = Zmodp(101)
    x = F(2)
    #print(type(F))
    #print(type(x))
    #print(type(F).order)
    #print(type(x).order)
    #print(dir(F))
    #print(dir(x))
    #print(dir(type(F)))
    #print(dir(type(x)))
