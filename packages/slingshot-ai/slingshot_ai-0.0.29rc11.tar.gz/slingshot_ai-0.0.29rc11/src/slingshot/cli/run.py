from __future__ import annotations

import subprocess
from datetime import datetime
from pathlib import Path
from typing import Optional

import typer
from rich.table import Table

from .. import schemas
from ..schemas import remote_mount_spec_to_local
from ..sdk.config import client_settings
from ..sdk.errors import SlingshotException
from ..sdk.graphql import fragments
from ..sdk.slingshot_sdk import SlingshotSDK
from ..sdk.utils import console
from ..shared.config import load_slingshot_project_config
from .config.slingshot_cli import SlingshotCLIApp
from .shared import (
    filter_for_runs,
    follow_run_logs_until_done,
    get_run_config_from_file,
    parse_extra_args,
    prompt_for_component_spec,
    prompt_push_code,
    run_by_name_or_prompt,
    seconds_to_human_readable,
)
from .shared.ssh import ensure_user_is_configured_for_ssh, start_ssh_for_run

app = SlingshotCLIApp()


def _override_mount_tags(
    mount_spec: schemas.MountSpecUnion, input_tag: str | None, output_tag: str | None
) -> schemas.MountSpecUnion:
    match mount_spec:
        case schemas.DownloadMountSpec():
            tag_override = input_tag or mount_spec.selector.tag
            return mount_spec.model_copy(
                update={'selector': mount_spec.selector.model_copy(update={'tag': tag_override})}, deep=True
            )
        case schemas.UploadMountSpec():
            tag_override = (
                ','.join((mount_spec.target.tag or '').split(',') + ([output_tag] if output_tag else []))
            ) or None
            return mount_spec.model_copy(
                update={'target': mount_spec.target.model_copy(update={'tag': tag_override})}, deep=True
            )
        case other:
            return other.model_copy(deep=True)


@app.command(
    "start",
    context_settings={"allow_extra_args": True, "ignore_unknown_options": True},
    requires_auth=True,
    requires_project=True,
)
async def start_run(
    ctx: typer.Context,
    *,
    sdk: SlingshotSDK,
    template_name: Optional[str] = typer.Argument(None, help="Name of the run template to use."),
    run_name: Optional[str] = typer.Option(
        None,
        '--run-name',
        '-n',
        help="The name to give to the run. If not specified, a name will be generated for you. If the "
        "name has already been used for a previous run for the same template, this will be treated as a restart "
        "and the run will have a suffix applied to make it unique (-1, -2, etc).",
    ),
    attach: Optional[bool] = typer.Option(
        None, '--attach', '-a', help="If specified, attaches an interactive terminal to the run once started"
    ),
    input_tag: Optional[str] = typer.Option(
        None,
        '--input-tag',
        '-i',
        help="If specified, the tag of any inputs (such as download mounts) will be overridden to use this value",
    ),
    output_tag: Optional[str] = typer.Option(
        None,
        '--output-tag',
        '-o',
        help="If specified, the tag of any outputs (such as upload mounts) will have this value added",
    ),
    config_file: Optional[str] = typer.Option(None, "--config", "-C", help="Path to config file for run."),
    debug: bool = typer.Option(False, "--debug", "-d", help="Run in debug mode.", hidden=True),
    # NOTE: We also parse extra args in code below, interpreting them as config options
) -> None:
    """Start a run"""
    if debug:
        console.log("Debug mode enabled.")

    if attach:
        await ensure_user_is_configured_for_ssh(sdk)

    source_code_id = await prompt_push_code(sdk)
    run_config_from_cli = parse_extra_args(ctx.args)
    run_config_from_file = await get_run_config_from_file(Path(config_file)) if config_file else {}
    run_config = {**run_config_from_file, **run_config_from_cli}

    run_spec = await _get_and_apply_run_spec(template_name, sdk)

    from_run_id: str | None = None
    if run_name is not None:
        existing_run = await sdk.get_run(run_name)
        if existing_run:
            console.print(f"Run with name '{run_name}' already exists, treating this as a restart ...")
            run_name = None  # The name will be inferred and generated by the server
            from_run_id = existing_run.run_id

    mount_specs = None
    if input_tag or output_tag:
        # Customize the mount specs based on the configured run config, but with tags adjusted to reflect tag overrides
        mount_specs = [
            _override_mount_tags(remote_mount_spec_to_local(mount_spec), input_tag=input_tag, output_tag=output_tag)
            for mount_spec in run_spec.mount_specs
        ]

    new_run = await sdk.start_run(
        run_template_name=run_spec.spec_name,
        source_code_id=source_code_id,
        configuration=run_config,
        run_name=run_name,
        from_run_id=from_run_id,
        mount_specs=mount_specs,
        debug_mode=debug,
    )
    link = await sdk.web_path_util.run(new_run)
    console.print(f"Run created with name '{new_run.run_name}', view in browser at {link}")

    if attach:
        await _attach_run(new_run, sdk=sdk)
    else:
        console.print(
            f"Following logs. Ctrl-C to stop, and run 'slingshot run logs {new_run.run_name} --follow' to follow again"
        )
        await follow_run_logs_until_done(sdk, run_id=new_run.run_id)


@app.command("stop", requires_project=True)
async def stop_run(name: Optional[str] = typer.Argument(None, help="Run name"), *, sdk: SlingshotSDK) -> None:
    """Stop a run"""
    run = await run_by_name_or_prompt(
        sdk,
        name=name,
        allowed_status=set(schemas.ComponentInstanceStatus.active_statuses()),
        error_message='No active runs found to stop',
        skip_if_one_value=False,
    )
    await sdk.stop_run(run_name=run.run_name)
    console.print("Run stopped successfully!")


@app.command(name="logs", requires_project=True)
async def run_logs(
    name: Optional[str] = typer.Argument(None, help="Run name"),
    follow: bool = typer.Option(False, "--follow", "-f", help="Follow logs"),
    refresh_rate: float = typer.Option(3.0, "--refresh-rate", "-r", help="Refresh rate in seconds"),
    *,
    sdk: SlingshotSDK,
) -> None:
    """Get logs for a run."""
    run = await run_by_name_or_prompt(sdk, name=name)
    await sdk.print_logs(run_id=run.run_id, follow=follow, refresh_rate_s=refresh_rate)


@app.command("open", requires_project=True)
async def open_run(name: Optional[str] = typer.Argument(None, help="Run name"), *, sdk: SlingshotSDK) -> None:
    """Open a run in the browser."""
    run = await run_by_name_or_prompt(sdk, name=name)
    assert sdk.project
    link = await sdk.web_path_util.run(run)
    console.print(f"[green]Opening {link}[/green]")
    typer.launch(link)


@app.command("list", requires_project=True)
async def list_runs(sdk: SlingshotSDK) -> None:
    """List all runs in the project."""
    runs = await sdk.list_runs()
    if not runs:
        run_templates = await sdk.list_run_templates()
        if not run_templates:
            console.print(
                "No runs found! "
                "Edit [yellow]slingshot.yaml[/yellow] or use [yellow]slingshot add[/yellow] to add a run template."
            )
            return
        console.print("No runs found! Use [yellow]slingshot run start[/yellow] to start a run.")
        console.print("Available run templates:")
        console.print("\n".join(f"    - [cyan]{run_template.spec_name}[/cyan]" for run_template in run_templates))
        return

    table = Table(title="Runs")
    table.add_column("Run Name", style="cyan")
    table.add_column("Status", style="cyan")
    table.add_column("Environment", style="cyan")
    table.add_column("Source Code", style="cyan")
    table.add_column("Machine Size", style="cyan")
    table.add_column("Duration", style="cyan")
    for run in runs:
        duration_seconds = None
        if run.start_time and not run.end_time:
            duration_seconds = (datetime.utcnow() - run.start_time).total_seconds()
        elif run.start_time and run.end_time:
            duration_seconds = (run.end_time - run.start_time).total_seconds()

        row = [
            run.run_name,
            run.run_status,
            run.environment_instance.execution_environment_spec.execution_environment_spec_name,
            run.source_code.blob_artifact.name,
            run.machine_size,
            f"{seconds_to_human_readable(duration_seconds)}" if duration_seconds is not None else "N/A",
        ]
        table.add_row(*row)
    console.print(table)


@app.command("enter", requires_auth=True, requires_project=True, hidden=True)
async def enter_run(
    *, sdk: SlingshotSDK, name: Optional[str] = typer.Argument(None, help="Name of the run use.")
) -> None:
    """Enters the environment of an active run by SSH:ing into it."""

    await ensure_user_is_configured_for_ssh(sdk)
    run = await run_by_name_or_prompt(
        sdk,
        name=name,
        allowed_status={schemas.ComponentInstanceStatus.RUNNING},
        error_message='No active runs found to enter',
    )
    await _ssh_into_run(sdk=sdk, run=run)


@app.command("attach", requires_auth=True, requires_project=True, hidden=True)
async def attach_run(
    *, sdk: SlingshotSDK, name: Optional[str] = typer.Argument(None, help="Name of the run use.")
) -> None:
    """Attach an interactive terminal to a currently executing run."""

    await ensure_user_is_configured_for_ssh(sdk)
    run = await run_by_name_or_prompt(
        sdk,
        name=name,
        allowed_status={schemas.ComponentInstanceStatus.RUNNING},
        error_message='No active runs found to attach to',
    )
    await _ssh_into_run(sdk=sdk, run=run, command='screen -rx slingshot_launcher')


async def _attach_run(new_run: fragments.Run, sdk: SlingshotSDK) -> None:
    console.print(f"Waiting for run to start ...")
    ready_run: fragments.Run | None = None
    async for status in sdk.api.follow_run_status(new_run.run_id):
        if status.is_failed:
            raise SlingshotException(f"Run failed with an error before we could attach.")
        elif status.is_terminal:
            raise SlingshotException(f"Run has already been completed or has been stopped.")
        elif status.is_running:
            # Refresh the run, we need the URL ...
            ready_run = await sdk.get_run(new_run.run_name)
            break

    console.print(f"Attaching interactive terminal to run ...")
    assert ready_run, "Run was started but now does not exist"
    await _ssh_into_run(sdk=sdk, run=ready_run, command='screen -rx slingshot_launcher')


async def _ssh_into_run(
    *, sdk: SlingshotSDK, run: fragments.Run, command: Optional[str] = None, interactive: bool = True
) -> None:
    ssh_connection_details = await start_ssh_for_run(run, sdk=sdk)
    console.print(
        f"Connecting to {ssh_connection_details.username}@{ssh_connection_details.hostname}:{ssh_connection_details.port}"
    )
    ssh_cmd = (
        f"ssh {ssh_connection_details.username}@{ssh_connection_details.hostname} -p {ssh_connection_details.port} "
        + ('-t ' if interactive else '')
        + f"-o UserKnownHostsFile={client_settings.slingshot_ssh_known_hosts_file} "
        + (command or '')
    )
    subprocess.run(ssh_cmd, shell=True)


# TODO: refactor this with apps/deployments to share code
async def _get_and_apply_run_spec(template_name: str | None, sdk: SlingshotSDK) -> fragments.ComponentSpec:
    local_manifest = load_slingshot_project_config(force_reload=True, silence_warnings=True)
    local_runs = local_manifest.runs
    local_run_names = [run.name for run in local_runs]
    if not template_name:
        _, template_name = await prompt_for_component_spec(
            sdk, filter_for_runs, local_spec_names=local_run_names, component_display_name="run"
        )

    assert sdk.project_id is not None, "Project ID is not set"
    run_spec = await sdk.api.get_component_spec_by_name(template_name, sdk.project_id)
    spec_exists_or_is_local = run_spec is not None or template_name in local_run_names

    # Show diff if the run exists, or if it's a local run that hasn't been created yet
    if spec_exists_or_is_local:
        await sdk.apply_component(schemas.ComponentType.RUN, component_name=template_name)
        run_spec = await sdk.api.get_component_spec_by_name(template_name, sdk.project_id)

    if not run_spec:
        raise SlingshotException(f"Run '{template_name}' does not exist yet")
    return run_spec
