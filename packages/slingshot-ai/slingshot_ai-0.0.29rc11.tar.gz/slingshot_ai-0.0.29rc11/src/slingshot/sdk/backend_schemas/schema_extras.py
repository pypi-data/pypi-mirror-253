"""
Our autogenerated schemas aren't perfect. This file contains extra classes not generated by the automagic.
We also have classes in schema_overrides.py that shadow generated classes.
"""
import uuid
from enum import Enum
from typing import Any, Generic, Optional, Protocol, TypeVar

from pydantic import BaseModel, ConfigDict, Field, field_validator
from pydantic_core.core_schema import FieldValidationInfo
from typing_extensions import Self

from .generated import schemas as generated_schemas

RunConfiguration = dict[str, Any]

DataT = TypeVar("DataT")


class Response(BaseModel, Generic[DataT]):
    data: Optional[DataT] = None
    error: Optional[generated_schemas.SlingshotLogicalError] = None


class Project(Protocol):
    project_id: str
    display_name: str


class ProjectImpl(BaseModel):
    project_id: str
    display_name: str


class HasRunId(Protocol):
    run_id: str


class HasExecutionEnvironmentSpecId(Protocol):
    execution_environment_spec_id: str


class HasExecutionEnvironmentId(Protocol):
    execution_environment_id: str


class HasComponentSpecId(Protocol):
    spec_id: str


class HasSourceCodeId(Protocol):
    source_code_id: str
    source_code_name: str


class HasBlobArtifactId(Protocol):
    blob_artifact_id: str


# TODO: A lot of status checking logic here is duplicated in the backend definition of this enum :'(
class ComponentInstanceStatus(str, Enum):
    NEW = "NEW"  # The component instance has just been created. This should be a transient state

    # The instance has been enqueued onto the compute platform (e.g. k8s resource have been created), but is not yet
    # running anywhere.
    QUEUED = "QUEUED"

    # The instance is initializing. No user code is running yet, but warmup tasks including preparing mounts are being
    # executed.
    INITIALIZING = "INITIALIZING"

    # User code of this instance is being executed. For apps that expose a port, we have not yet confirmed that the
    # app is listening to requests and traffic will not yet be served by the instance.
    RUNNING = "RUNNING"

    # The instance is running user code and is accepting requests.
    READY = "READY"

    # The instance has been requested to be stopped, but has not yet been terminated.
    STOPPING = "STOPPING"

    # The instance has been stopped as requested by a user (or in favour of a newer version for apps).
    STOPPED = "STOPPED"

    # The instance has completed successfully (for runs only).
    COMPLETED = "COMPLETED"

    # The instance stopped with an error.
    ERROR = "ERROR"

    @classmethod
    def active_statuses(cls) -> list["ComponentInstanceStatus"]:
        return [cls.NEW, cls.QUEUED, cls.RUNNING, cls.INITIALIZING, cls.READY]

    @property
    def is_starting(self) -> bool:
        """The instance is in the startup phase (new, queued, or initializing but not yet running, nor stopped)."""
        return self in [self.NEW, self.QUEUED, self.INITIALIZING]

    @property
    def is_running(self) -> bool:
        """The instance is currently running user code."""
        return self in [self.RUNNING, self.READY]

    @property
    def is_active(self) -> bool:
        """The instance is still intended to be running (starting or running but not stopping or completed)."""
        return self.is_starting or self.is_running

    @property
    def is_ready(self) -> bool:
        """The instance is ready and available to serve traffic."""
        return self in [self.READY]

    @property
    def is_stopping(self) -> bool:
        """The instance is shutting down (but not yet stopped)."""
        return self in [self.STOPPING]

    @property
    def is_terminal(self) -> bool:
        """The instance is in a terminal state (stopped, completed, or failed with an error)."""
        return self in [self.STOPPED, self.COMPLETED, self.ERROR]

    @property
    def is_failed(self) -> bool:
        """The instance is in a failed state."""
        return self in [self.ERROR]


class AuthTokenUnion(BaseModel):
    token: str
    user_id: Optional[str] = None
    service_account_id: Optional[str] = None

    @classmethod
    def from_auth_token(cls, auth_token: generated_schemas.AuthToken) -> Self:
        return cls(token=auth_token.token, user_id=auth_token.user_id, service_account_id=None)

    @classmethod
    def from_service_account_token(cls, service_account_token: generated_schemas.ServiceAccountToken) -> Self:
        return cls(
            token=service_account_token.token, user_id=None, service_account_id=service_account_token.service_account_id
        )

    @property
    def is_service_account(self) -> bool:
        return self.service_account_id is not None

    @property
    def is_user(self) -> bool:
        return self.user_id is not None

    @field_validator("service_account_id")
    def validate_xor(cls, v: str | None, info: FieldValidationInfo) -> str | None:
        if v is None and info.data.get("user_id") is None:
            raise ValueError("Both service_account_id and user_id cannot be None")
        if v is not None and info.data.get("user_id") is not None:
            raise ValueError("Both service_account_id and user_id cannot be set")
        return v


# Note: these are copied from the backend schemas, but should ideally be generated from those.
class Result(BaseModel):
    model_config = ConfigDict(extra='allow', populate_by_name=True)


class ExampleResult(BaseModel):
    example_id: str = Field(default_factory=lambda: uuid.uuid4().hex[:8], alias="exampleId")
    result: Result = Field(..., description="Result for the given example")
    model_config = ConfigDict(populate_by_name=True)


class Example(BaseModel):
    example_id: str = Field(default_factory=lambda: uuid.uuid4().hex[:8], alias="exampleId")
    model_config = ConfigDict(populate_by_name=True, extra="allow")
